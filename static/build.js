!function(e){function r(e,r,o){return 4===arguments.length?t.apply(this,arguments):void n(e,{declarative:!0,deps:r,declare:o})}function t(e,r,t,o){n(e,{declarative:!1,deps:r,executingRequire:t,execute:o})}function n(e,r){r.name=e,e in v||(v[e]=r),r.normalizedDeps=r.deps}function o(e,r){if(r[e.groupIndex]=r[e.groupIndex]||[],-1==g.call(r[e.groupIndex],e)){r[e.groupIndex].push(e);for(var t=0,n=e.normalizedDeps.length;n>t;t++){var a=e.normalizedDeps[t],u=v[a];if(u&&!u.evaluated){var d=e.groupIndex+(u.declarative!=e.declarative);if(void 0===u.groupIndex||u.groupIndex<d){if(void 0!==u.groupIndex&&(r[u.groupIndex].splice(g.call(r[u.groupIndex],u),1),0==r[u.groupIndex].length))throw new TypeError("Mixed dependency cycle detected");u.groupIndex=d}o(u,r)}}}}function a(e){var r=v[e];r.groupIndex=0;var t=[];o(r,t);for(var n=!!r.declarative==t.length%2,a=t.length-1;a>=0;a--){for(var u=t[a],i=0;i<u.length;i++){var s=u[i];n?d(s):l(s)}n=!n}}function u(e){return y[e]||(y[e]={name:e,dependencies:[],exports:{},importers:[]})}function d(r){if(!r.module){var t=r.module=u(r.name),n=r.module.exports,o=r.declare.call(e,function(e,r){if(t.locked=!0,"object"==typeof e)for(var o in e)n[o]=e[o];else n[e]=r;for(var a=0,u=t.importers.length;u>a;a++){var d=t.importers[a];if(!d.locked)for(var i=0;i<d.dependencies.length;++i)d.dependencies[i]===t&&d.setters[i](n)}return t.locked=!1,r},r.name);t.setters=o.setters,t.execute=o.execute;for(var a=0,i=r.normalizedDeps.length;i>a;a++){var l,s=r.normalizedDeps[a],c=v[s],f=y[s];f?l=f.exports:c&&!c.declarative?l=c.esModule:c?(d(c),f=c.module,l=f.exports):l=p(s),f&&f.importers?(f.importers.push(t),t.dependencies.push(f)):t.dependencies.push(null),t.setters[a]&&t.setters[a](l)}}}function i(e){var r,t=v[e];if(t)t.declarative?f(e,[]):t.evaluated||l(t),r=t.module.exports;else if(r=p(e),!r)throw new Error("Unable to load dependency "+e+".");return(!t||t.declarative)&&r&&r.__useDefault?r["default"]:r}function l(r){if(!r.module){var t={},n=r.module={exports:t,id:r.name};if(!r.executingRequire)for(var o=0,a=r.normalizedDeps.length;a>o;o++){var u=r.normalizedDeps[o],d=v[u];d&&l(d)}r.evaluated=!0;var c=r.execute.call(e,function(e){for(var t=0,n=r.deps.length;n>t;t++)if(r.deps[t]==e)return i(r.normalizedDeps[t]);throw new TypeError("Module "+e+" not declared as a dependency.")},t,n);c&&(n.exports=c),t=n.exports,t&&t.__esModule?r.esModule=t:r.esModule=s(t)}}function s(r){var t={};if(("object"==typeof r||"function"==typeof r)&&r!==e)if(m)for(var n in r)"default"!==n&&c(t,r,n);else{var o=r&&r.hasOwnProperty;for(var n in r)"default"===n||o&&!r.hasOwnProperty(n)||(t[n]=r[n])}return t["default"]=r,x(t,"__useDefault",{value:!0}),t}function c(e,r,t){try{var n;(n=Object.getOwnPropertyDescriptor(r,t))&&x(e,t,n)}catch(o){return e[t]=r[t],!1}}function f(r,t){var n=v[r];if(n&&!n.evaluated&&n.declarative){t.push(r);for(var o=0,a=n.normalizedDeps.length;a>o;o++){var u=n.normalizedDeps[o];-1==g.call(t,u)&&(v[u]?f(u,t):p(u))}n.evaluated||(n.evaluated=!0,n.module.execute.call(e))}}function p(e){if(I[e])return I[e];if("@node/"==e.substr(0,6))return D(e.substr(6));var r=v[e];if(!r)throw"Module "+e+" not present.";return a(e),f(e,[]),v[e]=void 0,r.declarative&&x(r.module.exports,"__esModule",{value:!0}),I[e]=r.declarative?r.module.exports:r.esModule}var v={},g=Array.prototype.indexOf||function(e){for(var r=0,t=this.length;t>r;r++)if(this[r]===e)return r;return-1},m=!0;try{Object.getOwnPropertyDescriptor({a:0},"a")}catch(h){m=!1}var x;!function(){try{Object.defineProperty({},"a",{})&&(x=Object.defineProperty)}catch(e){x=function(e,r,t){try{e[r]=t.value||t.get.call(e)}catch(n){}}}}();var y={},D="undefined"!=typeof System&&System._nodeRequire||"undefined"!=typeof require&&require.resolve&&"undefined"!=typeof process&&require,I={"@empty":{}};return function(e,n,o,a){return function(u){u(function(u){for(var d={_nodeRequire:D,register:r,registerDynamic:t,get:p,set:function(e,r){I[e]=r},newModule:function(e){return e}},i=0;i<n.length;i++)(function(e,r){r&&r.__esModule?I[e]=r:I[e]=s(r)})(n[i],arguments[i]);a(d);var l=p(e[0]);if(e.length>1)for(var i=1;i<e.length;i++)p(e[i]);return o?l["default"]:l})}}}("undefined"!=typeof self?self:global)

(["1"], [], false, function($__System) {
var require = this.require, exports = this.exports, module = this.module;
!function(e){function r(e,r){for(var n=e.split(".");n.length;)r=r[n.shift()];return r}function n(n){if("string"==typeof n)return r(n,e);if(!(n instanceof Array))throw new Error("Global exports must be a string or array.");for(var t={},o=!0,f=0;f<n.length;f++){var i=r(n[f],e);o&&(t["default"]=i,o=!1),t[n[f].split(".").pop()]=i}return t}function t(r){if(Object.keys)Object.keys(e).forEach(r);else for(var n in e)a.call(e,n)&&r(n)}function o(r){t(function(n){if(-1==l.call(s,n)){try{var t=e[n]}catch(o){s.push(n)}r(n,t)}})}var f,i=$__System,a=Object.prototype.hasOwnProperty,l=Array.prototype.indexOf||function(e){for(var r=0,n=this.length;n>r;r++)if(this[r]===e)return r;return-1},s=["_g","sessionStorage","localStorage","clipboardData","frames","frameElement","external","mozAnimationStartTime","webkitStorageInfo","webkitIndexedDB","mozInnerScreenY","mozInnerScreenX"];i.set("@@global-helpers",i.newModule({prepareGlobal:function(r,t,i){var a=e.define;e.define=void 0;var l;if(i){l={};for(var s in i)l[s]=e[s],e[s]=i[s]}return t||(f={},o(function(e,r){f[e]=r})),function(){var r;if(t)r=n(t);else{r={};var i,s;o(function(e,n){f[e]!==n&&"undefined"!=typeof n&&(r[e]=n,"undefined"!=typeof i?s||i===n||(s=!0):i=n)}),r=s?r:i}if(l)for(var u in l)e[u]=l[u];return e.define=a,r}}}))}("undefined"!=typeof self?self:global);
$__System.register("2", [], function() { return { setters: [], execute: function() {} } });

$__System.register("3", [], function() { return { setters: [], execute: function() {} } });

$__System.registerDynamic("4", ["5"], false, function($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);
  (function() {
    "format global";
    "deps angular";
    (function(window, angular) {
      'use strict';
      var noop = angular.noop;
      var copy = angular.copy;
      var extend = angular.extend;
      var jqLite = angular.element;
      var forEach = angular.forEach;
      var isArray = angular.isArray;
      var isString = angular.isString;
      var isObject = angular.isObject;
      var isUndefined = angular.isUndefined;
      var isDefined = angular.isDefined;
      var isFunction = angular.isFunction;
      var isElement = angular.isElement;
      var ELEMENT_NODE = 1;
      var COMMENT_NODE = 8;
      var ADD_CLASS_SUFFIX = '-add';
      var REMOVE_CLASS_SUFFIX = '-remove';
      var EVENT_CLASS_PREFIX = 'ng-';
      var ACTIVE_CLASS_SUFFIX = '-active';
      var PREPARE_CLASS_SUFFIX = '-prepare';
      var NG_ANIMATE_CLASSNAME = 'ng-animate';
      var NG_ANIMATE_CHILDREN_DATA = '$$ngAnimateChildren';
      var CSS_PREFIX = '',
          TRANSITION_PROP,
          TRANSITIONEND_EVENT,
          ANIMATION_PROP,
          ANIMATIONEND_EVENT;
      if (isUndefined(window.ontransitionend) && isDefined(window.onwebkittransitionend)) {
        CSS_PREFIX = '-webkit-';
        TRANSITION_PROP = 'WebkitTransition';
        TRANSITIONEND_EVENT = 'webkitTransitionEnd transitionend';
      } else {
        TRANSITION_PROP = 'transition';
        TRANSITIONEND_EVENT = 'transitionend';
      }
      if (isUndefined(window.onanimationend) && isDefined(window.onwebkitanimationend)) {
        CSS_PREFIX = '-webkit-';
        ANIMATION_PROP = 'WebkitAnimation';
        ANIMATIONEND_EVENT = 'webkitAnimationEnd animationend';
      } else {
        ANIMATION_PROP = 'animation';
        ANIMATIONEND_EVENT = 'animationend';
      }
      var DURATION_KEY = 'Duration';
      var PROPERTY_KEY = 'Property';
      var DELAY_KEY = 'Delay';
      var TIMING_KEY = 'TimingFunction';
      var ANIMATION_ITERATION_COUNT_KEY = 'IterationCount';
      var ANIMATION_PLAYSTATE_KEY = 'PlayState';
      var SAFE_FAST_FORWARD_DURATION_VALUE = 9999;
      var ANIMATION_DELAY_PROP = ANIMATION_PROP + DELAY_KEY;
      var ANIMATION_DURATION_PROP = ANIMATION_PROP + DURATION_KEY;
      var TRANSITION_DELAY_PROP = TRANSITION_PROP + DELAY_KEY;
      var TRANSITION_DURATION_PROP = TRANSITION_PROP + DURATION_KEY;
      var isPromiseLike = function(p) {
        return p && p.then ? true : false;
      };
      var ngMinErr = angular.$$minErr('ng');
      function assertArg(arg, name, reason) {
        if (!arg) {
          throw ngMinErr('areq', "Argument '{0}' is {1}", (name || '?'), (reason || "required"));
        }
        return arg;
      }
      function mergeClasses(a, b) {
        if (!a && !b)
          return '';
        if (!a)
          return b;
        if (!b)
          return a;
        if (isArray(a))
          a = a.join(' ');
        if (isArray(b))
          b = b.join(' ');
        return a + ' ' + b;
      }
      function packageStyles(options) {
        var styles = {};
        if (options && (options.to || options.from)) {
          styles.to = options.to;
          styles.from = options.from;
        }
        return styles;
      }
      function pendClasses(classes, fix, isPrefix) {
        var className = '';
        classes = isArray(classes) ? classes : classes && isString(classes) && classes.length ? classes.split(/\s+/) : [];
        forEach(classes, function(klass, i) {
          if (klass && klass.length > 0) {
            className += (i > 0) ? ' ' : '';
            className += isPrefix ? fix + klass : klass + fix;
          }
        });
        return className;
      }
      function removeFromArray(arr, val) {
        var index = arr.indexOf(val);
        if (val >= 0) {
          arr.splice(index, 1);
        }
      }
      function stripCommentsFromElement(element) {
        if (element instanceof jqLite) {
          switch (element.length) {
            case 0:
              return [];
              break;
            case 1:
              if (element[0].nodeType === ELEMENT_NODE) {
                return element;
              }
              break;
            default:
              return jqLite(extractElementNode(element));
              break;
          }
        }
        if (element.nodeType === ELEMENT_NODE) {
          return jqLite(element);
        }
      }
      function extractElementNode(element) {
        if (!element[0])
          return element;
        for (var i = 0; i < element.length; i++) {
          var elm = element[i];
          if (elm.nodeType == ELEMENT_NODE) {
            return elm;
          }
        }
      }
      function $$addClass($$jqLite, element, className) {
        forEach(element, function(elm) {
          $$jqLite.addClass(elm, className);
        });
      }
      function $$removeClass($$jqLite, element, className) {
        forEach(element, function(elm) {
          $$jqLite.removeClass(elm, className);
        });
      }
      function applyAnimationClassesFactory($$jqLite) {
        return function(element, options) {
          if (options.addClass) {
            $$addClass($$jqLite, element, options.addClass);
            options.addClass = null;
          }
          if (options.removeClass) {
            $$removeClass($$jqLite, element, options.removeClass);
            options.removeClass = null;
          }
        };
      }
      function prepareAnimationOptions(options) {
        options = options || {};
        if (!options.$$prepared) {
          var domOperation = options.domOperation || noop;
          options.domOperation = function() {
            options.$$domOperationFired = true;
            domOperation();
            domOperation = noop;
          };
          options.$$prepared = true;
        }
        return options;
      }
      function applyAnimationStyles(element, options) {
        applyAnimationFromStyles(element, options);
        applyAnimationToStyles(element, options);
      }
      function applyAnimationFromStyles(element, options) {
        if (options.from) {
          element.css(options.from);
          options.from = null;
        }
      }
      function applyAnimationToStyles(element, options) {
        if (options.to) {
          element.css(options.to);
          options.to = null;
        }
      }
      function mergeAnimationDetails(element, oldAnimation, newAnimation) {
        var target = oldAnimation.options || {};
        var newOptions = newAnimation.options || {};
        var toAdd = (target.addClass || '') + ' ' + (newOptions.addClass || '');
        var toRemove = (target.removeClass || '') + ' ' + (newOptions.removeClass || '');
        var classes = resolveElementClasses(element.attr('class'), toAdd, toRemove);
        if (newOptions.preparationClasses) {
          target.preparationClasses = concatWithSpace(newOptions.preparationClasses, target.preparationClasses);
          delete newOptions.preparationClasses;
        }
        var realDomOperation = target.domOperation !== noop ? target.domOperation : null;
        extend(target, newOptions);
        if (realDomOperation) {
          target.domOperation = realDomOperation;
        }
        if (classes.addClass) {
          target.addClass = classes.addClass;
        } else {
          target.addClass = null;
        }
        if (classes.removeClass) {
          target.removeClass = classes.removeClass;
        } else {
          target.removeClass = null;
        }
        oldAnimation.addClass = target.addClass;
        oldAnimation.removeClass = target.removeClass;
        return target;
      }
      function resolveElementClasses(existing, toAdd, toRemove) {
        var ADD_CLASS = 1;
        var REMOVE_CLASS = -1;
        var flags = {};
        existing = splitClassesToLookup(existing);
        toAdd = splitClassesToLookup(toAdd);
        forEach(toAdd, function(value, key) {
          flags[key] = ADD_CLASS;
        });
        toRemove = splitClassesToLookup(toRemove);
        forEach(toRemove, function(value, key) {
          flags[key] = flags[key] === ADD_CLASS ? null : REMOVE_CLASS;
        });
        var classes = {
          addClass: '',
          removeClass: ''
        };
        forEach(flags, function(val, klass) {
          var prop,
              allow;
          if (val === ADD_CLASS) {
            prop = 'addClass';
            allow = !existing[klass];
          } else if (val === REMOVE_CLASS) {
            prop = 'removeClass';
            allow = existing[klass];
          }
          if (allow) {
            if (classes[prop].length) {
              classes[prop] += ' ';
            }
            classes[prop] += klass;
          }
        });
        function splitClassesToLookup(classes) {
          if (isString(classes)) {
            classes = classes.split(' ');
          }
          var obj = {};
          forEach(classes, function(klass) {
            if (klass.length) {
              obj[klass] = true;
            }
          });
          return obj;
        }
        return classes;
      }
      function getDomNode(element) {
        return (element instanceof angular.element) ? element[0] : element;
      }
      function applyGeneratedPreparationClasses(element, event, options) {
        var classes = '';
        if (event) {
          classes = pendClasses(event, EVENT_CLASS_PREFIX, true);
        }
        if (options.addClass) {
          classes = concatWithSpace(classes, pendClasses(options.addClass, ADD_CLASS_SUFFIX));
        }
        if (options.removeClass) {
          classes = concatWithSpace(classes, pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX));
        }
        if (classes.length) {
          options.preparationClasses = classes;
          element.addClass(classes);
        }
      }
      function clearGeneratedClasses(element, options) {
        if (options.preparationClasses) {
          element.removeClass(options.preparationClasses);
          options.preparationClasses = null;
        }
        if (options.activeClasses) {
          element.removeClass(options.activeClasses);
          options.activeClasses = null;
        }
      }
      function blockTransitions(node, duration) {
        var value = duration ? '-' + duration + 's' : '';
        applyInlineStyle(node, [TRANSITION_DELAY_PROP, value]);
        return [TRANSITION_DELAY_PROP, value];
      }
      function blockKeyframeAnimations(node, applyBlock) {
        var value = applyBlock ? 'paused' : '';
        var key = ANIMATION_PROP + ANIMATION_PLAYSTATE_KEY;
        applyInlineStyle(node, [key, value]);
        return [key, value];
      }
      function applyInlineStyle(node, styleTuple) {
        var prop = styleTuple[0];
        var value = styleTuple[1];
        node.style[prop] = value;
      }
      function concatWithSpace(a, b) {
        if (!a)
          return b;
        if (!b)
          return a;
        return a + ' ' + b;
      }
      var $$rAFSchedulerFactory = ['$$rAF', function($$rAF) {
        var queue,
            cancelFn;
        function scheduler(tasks) {
          queue = queue.concat(tasks);
          nextTick();
        }
        queue = scheduler.queue = [];
        scheduler.waitUntilQuiet = function(fn) {
          if (cancelFn)
            cancelFn();
          cancelFn = $$rAF(function() {
            cancelFn = null;
            fn();
            nextTick();
          });
        };
        return scheduler;
        function nextTick() {
          if (!queue.length)
            return;
          var items = queue.shift();
          for (var i = 0; i < items.length; i++) {
            items[i]();
          }
          if (!cancelFn) {
            $$rAF(function() {
              if (!cancelFn)
                nextTick();
            });
          }
        }
      }];
      var $$AnimateChildrenDirective = ['$interpolate', function($interpolate) {
        return {link: function(scope, element, attrs) {
            var val = attrs.ngAnimateChildren;
            if (angular.isString(val) && val.length === 0) {
              element.data(NG_ANIMATE_CHILDREN_DATA, true);
            } else {
              setData($interpolate(val)(scope));
              attrs.$observe('ngAnimateChildren', setData);
            }
            function setData(value) {
              value = value === 'on' || value === 'true';
              element.data(NG_ANIMATE_CHILDREN_DATA, value);
            }
          }};
      }];
      var ANIMATE_TIMER_KEY = '$$animateCss';
      var ONE_SECOND = 1000;
      var BASE_TEN = 10;
      var ELAPSED_TIME_MAX_DECIMAL_PLACES = 3;
      var CLOSING_TIME_BUFFER = 1.5;
      var DETECT_CSS_PROPERTIES = {
        transitionDuration: TRANSITION_DURATION_PROP,
        transitionDelay: TRANSITION_DELAY_PROP,
        transitionProperty: TRANSITION_PROP + PROPERTY_KEY,
        animationDuration: ANIMATION_DURATION_PROP,
        animationDelay: ANIMATION_DELAY_PROP,
        animationIterationCount: ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY
      };
      var DETECT_STAGGER_CSS_PROPERTIES = {
        transitionDuration: TRANSITION_DURATION_PROP,
        transitionDelay: TRANSITION_DELAY_PROP,
        animationDuration: ANIMATION_DURATION_PROP,
        animationDelay: ANIMATION_DELAY_PROP
      };
      function getCssKeyframeDurationStyle(duration) {
        return [ANIMATION_DURATION_PROP, duration + 's'];
      }
      function getCssDelayStyle(delay, isKeyframeAnimation) {
        var prop = isKeyframeAnimation ? ANIMATION_DELAY_PROP : TRANSITION_DELAY_PROP;
        return [prop, delay + 's'];
      }
      function computeCssStyles($window, element, properties) {
        var styles = Object.create(null);
        var detectedStyles = $window.getComputedStyle(element) || {};
        forEach(properties, function(formalStyleName, actualStyleName) {
          var val = detectedStyles[formalStyleName];
          if (val) {
            var c = val.charAt(0);
            if (c === '-' || c === '+' || c >= 0) {
              val = parseMaxTime(val);
            }
            if (val === 0) {
              val = null;
            }
            styles[actualStyleName] = val;
          }
        });
        return styles;
      }
      function parseMaxTime(str) {
        var maxValue = 0;
        var values = str.split(/\s*,\s*/);
        forEach(values, function(value) {
          if (value.charAt(value.length - 1) == 's') {
            value = value.substring(0, value.length - 1);
          }
          value = parseFloat(value) || 0;
          maxValue = maxValue ? Math.max(value, maxValue) : value;
        });
        return maxValue;
      }
      function truthyTimingValue(val) {
        return val === 0 || val != null;
      }
      function getCssTransitionDurationStyle(duration, applyOnlyDuration) {
        var style = TRANSITION_PROP;
        var value = duration + 's';
        if (applyOnlyDuration) {
          style += DURATION_KEY;
        } else {
          value += ' linear all';
        }
        return [style, value];
      }
      function createLocalCacheLookup() {
        var cache = Object.create(null);
        return {
          flush: function() {
            cache = Object.create(null);
          },
          count: function(key) {
            var entry = cache[key];
            return entry ? entry.total : 0;
          },
          get: function(key) {
            var entry = cache[key];
            return entry && entry.value;
          },
          put: function(key, value) {
            if (!cache[key]) {
              cache[key] = {
                total: 1,
                value: value
              };
            } else {
              cache[key].total++;
            }
          }
        };
      }
      function registerRestorableStyles(backup, node, properties) {
        forEach(properties, function(prop) {
          backup[prop] = isDefined(backup[prop]) ? backup[prop] : node.style.getPropertyValue(prop);
        });
      }
      var $AnimateCssProvider = ['$animateProvider', function($animateProvider) {
        var gcsLookup = createLocalCacheLookup();
        var gcsStaggerLookup = createLocalCacheLookup();
        this.$get = ['$window', '$$jqLite', '$$AnimateRunner', '$timeout', '$$forceReflow', '$sniffer', '$$rAFScheduler', '$$animateQueue', function($window, $$jqLite, $$AnimateRunner, $timeout, $$forceReflow, $sniffer, $$rAFScheduler, $$animateQueue) {
          var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
          var parentCounter = 0;
          function gcsHashFn(node, extraClasses) {
            var KEY = "$$ngAnimateParentKey";
            var parentNode = node.parentNode;
            var parentID = parentNode[KEY] || (parentNode[KEY] = ++parentCounter);
            return parentID + '-' + node.getAttribute('class') + '-' + extraClasses;
          }
          function computeCachedCssStyles(node, className, cacheKey, properties) {
            var timings = gcsLookup.get(cacheKey);
            if (!timings) {
              timings = computeCssStyles($window, node, properties);
              if (timings.animationIterationCount === 'infinite') {
                timings.animationIterationCount = 1;
              }
            }
            gcsLookup.put(cacheKey, timings);
            return timings;
          }
          function computeCachedCssStaggerStyles(node, className, cacheKey, properties) {
            var stagger;
            if (gcsLookup.count(cacheKey) > 0) {
              stagger = gcsStaggerLookup.get(cacheKey);
              if (!stagger) {
                var staggerClassName = pendClasses(className, '-stagger');
                $$jqLite.addClass(node, staggerClassName);
                stagger = computeCssStyles($window, node, properties);
                stagger.animationDuration = Math.max(stagger.animationDuration, 0);
                stagger.transitionDuration = Math.max(stagger.transitionDuration, 0);
                $$jqLite.removeClass(node, staggerClassName);
                gcsStaggerLookup.put(cacheKey, stagger);
              }
            }
            return stagger || {};
          }
          var cancelLastRAFRequest;
          var rafWaitQueue = [];
          function waitUntilQuiet(callback) {
            rafWaitQueue.push(callback);
            $$rAFScheduler.waitUntilQuiet(function() {
              gcsLookup.flush();
              gcsStaggerLookup.flush();
              var pageWidth = $$forceReflow();
              for (var i = 0; i < rafWaitQueue.length; i++) {
                rafWaitQueue[i](pageWidth);
              }
              rafWaitQueue.length = 0;
            });
          }
          function computeTimings(node, className, cacheKey) {
            var timings = computeCachedCssStyles(node, className, cacheKey, DETECT_CSS_PROPERTIES);
            var aD = timings.animationDelay;
            var tD = timings.transitionDelay;
            timings.maxDelay = aD && tD ? Math.max(aD, tD) : (aD || tD);
            timings.maxDuration = Math.max(timings.animationDuration * timings.animationIterationCount, timings.transitionDuration);
            return timings;
          }
          return function init(element, initialOptions) {
            var options = initialOptions || {};
            if (!options.$$prepared) {
              options = prepareAnimationOptions(copy(options));
            }
            var restoreStyles = {};
            var node = getDomNode(element);
            if (!node || !node.parentNode || !$$animateQueue.enabled()) {
              return closeAndReturnNoopAnimator();
            }
            var temporaryStyles = [];
            var classes = element.attr('class');
            var styles = packageStyles(options);
            var animationClosed;
            var animationPaused;
            var animationCompleted;
            var runner;
            var runnerHost;
            var maxDelay;
            var maxDelayTime;
            var maxDuration;
            var maxDurationTime;
            var startTime;
            var events = [];
            if (options.duration === 0 || (!$sniffer.animations && !$sniffer.transitions)) {
              return closeAndReturnNoopAnimator();
            }
            var method = options.event && isArray(options.event) ? options.event.join(' ') : options.event;
            var isStructural = method && options.structural;
            var structuralClassName = '';
            var addRemoveClassName = '';
            if (isStructural) {
              structuralClassName = pendClasses(method, EVENT_CLASS_PREFIX, true);
            } else if (method) {
              structuralClassName = method;
            }
            if (options.addClass) {
              addRemoveClassName += pendClasses(options.addClass, ADD_CLASS_SUFFIX);
            }
            if (options.removeClass) {
              if (addRemoveClassName.length) {
                addRemoveClassName += ' ';
              }
              addRemoveClassName += pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX);
            }
            if (options.applyClassesEarly && addRemoveClassName.length) {
              applyAnimationClasses(element, options);
            }
            var preparationClasses = [structuralClassName, addRemoveClassName].join(' ').trim();
            var fullClassName = classes + ' ' + preparationClasses;
            var activeClasses = pendClasses(preparationClasses, ACTIVE_CLASS_SUFFIX);
            var hasToStyles = styles.to && Object.keys(styles.to).length > 0;
            var containsKeyframeAnimation = (options.keyframeStyle || '').length > 0;
            if (!containsKeyframeAnimation && !hasToStyles && !preparationClasses) {
              return closeAndReturnNoopAnimator();
            }
            var cacheKey,
                stagger;
            if (options.stagger > 0) {
              var staggerVal = parseFloat(options.stagger);
              stagger = {
                transitionDelay: staggerVal,
                animationDelay: staggerVal,
                transitionDuration: 0,
                animationDuration: 0
              };
            } else {
              cacheKey = gcsHashFn(node, fullClassName);
              stagger = computeCachedCssStaggerStyles(node, preparationClasses, cacheKey, DETECT_STAGGER_CSS_PROPERTIES);
            }
            if (!options.$$skipPreparationClasses) {
              $$jqLite.addClass(element, preparationClasses);
            }
            var applyOnlyDuration;
            if (options.transitionStyle) {
              var transitionStyle = [TRANSITION_PROP, options.transitionStyle];
              applyInlineStyle(node, transitionStyle);
              temporaryStyles.push(transitionStyle);
            }
            if (options.duration >= 0) {
              applyOnlyDuration = node.style[TRANSITION_PROP].length > 0;
              var durationStyle = getCssTransitionDurationStyle(options.duration, applyOnlyDuration);
              applyInlineStyle(node, durationStyle);
              temporaryStyles.push(durationStyle);
            }
            if (options.keyframeStyle) {
              var keyframeStyle = [ANIMATION_PROP, options.keyframeStyle];
              applyInlineStyle(node, keyframeStyle);
              temporaryStyles.push(keyframeStyle);
            }
            var itemIndex = stagger ? options.staggerIndex >= 0 ? options.staggerIndex : gcsLookup.count(cacheKey) : 0;
            var isFirst = itemIndex === 0;
            if (isFirst && !options.skipBlocking) {
              blockTransitions(node, SAFE_FAST_FORWARD_DURATION_VALUE);
            }
            var timings = computeTimings(node, fullClassName, cacheKey);
            var relativeDelay = timings.maxDelay;
            maxDelay = Math.max(relativeDelay, 0);
            maxDuration = timings.maxDuration;
            var flags = {};
            flags.hasTransitions = timings.transitionDuration > 0;
            flags.hasAnimations = timings.animationDuration > 0;
            flags.hasTransitionAll = flags.hasTransitions && timings.transitionProperty == 'all';
            flags.applyTransitionDuration = hasToStyles && ((flags.hasTransitions && !flags.hasTransitionAll) || (flags.hasAnimations && !flags.hasTransitions));
            flags.applyAnimationDuration = options.duration && flags.hasAnimations;
            flags.applyTransitionDelay = truthyTimingValue(options.delay) && (flags.applyTransitionDuration || flags.hasTransitions);
            flags.applyAnimationDelay = truthyTimingValue(options.delay) && flags.hasAnimations;
            flags.recalculateTimingStyles = addRemoveClassName.length > 0;
            if (flags.applyTransitionDuration || flags.applyAnimationDuration) {
              maxDuration = options.duration ? parseFloat(options.duration) : maxDuration;
              if (flags.applyTransitionDuration) {
                flags.hasTransitions = true;
                timings.transitionDuration = maxDuration;
                applyOnlyDuration = node.style[TRANSITION_PROP + PROPERTY_KEY].length > 0;
                temporaryStyles.push(getCssTransitionDurationStyle(maxDuration, applyOnlyDuration));
              }
              if (flags.applyAnimationDuration) {
                flags.hasAnimations = true;
                timings.animationDuration = maxDuration;
                temporaryStyles.push(getCssKeyframeDurationStyle(maxDuration));
              }
            }
            if (maxDuration === 0 && !flags.recalculateTimingStyles) {
              return closeAndReturnNoopAnimator();
            }
            if (options.delay != null) {
              var delayStyle;
              if (typeof options.delay !== "boolean") {
                delayStyle = parseFloat(options.delay);
                maxDelay = Math.max(delayStyle, 0);
              }
              if (flags.applyTransitionDelay) {
                temporaryStyles.push(getCssDelayStyle(delayStyle));
              }
              if (flags.applyAnimationDelay) {
                temporaryStyles.push(getCssDelayStyle(delayStyle, true));
              }
            }
            if (options.duration == null && timings.transitionDuration > 0) {
              flags.recalculateTimingStyles = flags.recalculateTimingStyles || isFirst;
            }
            maxDelayTime = maxDelay * ONE_SECOND;
            maxDurationTime = maxDuration * ONE_SECOND;
            if (!options.skipBlocking) {
              flags.blockTransition = timings.transitionDuration > 0;
              flags.blockKeyframeAnimation = timings.animationDuration > 0 && stagger.animationDelay > 0 && stagger.animationDuration === 0;
            }
            if (options.from) {
              if (options.cleanupStyles) {
                registerRestorableStyles(restoreStyles, node, Object.keys(options.from));
              }
              applyAnimationFromStyles(element, options);
            }
            if (flags.blockTransition || flags.blockKeyframeAnimation) {
              applyBlocking(maxDuration);
            } else if (!options.skipBlocking) {
              blockTransitions(node, false);
            }
            return {
              $$willAnimate: true,
              end: endFn,
              start: function() {
                if (animationClosed)
                  return;
                runnerHost = {
                  end: endFn,
                  cancel: cancelFn,
                  resume: null,
                  pause: null
                };
                runner = new $$AnimateRunner(runnerHost);
                waitUntilQuiet(start);
                return runner;
              }
            };
            function endFn() {
              close();
            }
            function cancelFn() {
              close(true);
            }
            function close(rejected) {
              if (animationClosed || (animationCompleted && animationPaused))
                return;
              animationClosed = true;
              animationPaused = false;
              if (!options.$$skipPreparationClasses) {
                $$jqLite.removeClass(element, preparationClasses);
              }
              $$jqLite.removeClass(element, activeClasses);
              blockKeyframeAnimations(node, false);
              blockTransitions(node, false);
              forEach(temporaryStyles, function(entry) {
                node.style[entry[0]] = '';
              });
              applyAnimationClasses(element, options);
              applyAnimationStyles(element, options);
              if (Object.keys(restoreStyles).length) {
                forEach(restoreStyles, function(value, prop) {
                  value ? node.style.setProperty(prop, value) : node.style.removeProperty(prop);
                });
              }
              if (options.onDone) {
                options.onDone();
              }
              if (events && events.length) {
                element.off(events.join(' '), onAnimationProgress);
              }
              var animationTimerData = element.data(ANIMATE_TIMER_KEY);
              if (animationTimerData) {
                $timeout.cancel(animationTimerData[0].timer);
                element.removeData(ANIMATE_TIMER_KEY);
              }
              if (runner) {
                runner.complete(!rejected);
              }
            }
            function applyBlocking(duration) {
              if (flags.blockTransition) {
                blockTransitions(node, duration);
              }
              if (flags.blockKeyframeAnimation) {
                blockKeyframeAnimations(node, !!duration);
              }
            }
            function closeAndReturnNoopAnimator() {
              runner = new $$AnimateRunner({
                end: endFn,
                cancel: cancelFn
              });
              waitUntilQuiet(noop);
              close();
              return {
                $$willAnimate: false,
                start: function() {
                  return runner;
                },
                end: endFn
              };
            }
            function onAnimationProgress(event) {
              event.stopPropagation();
              var ev = event.originalEvent || event;
              var timeStamp = ev.$manualTimeStamp || Date.now();
              var elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES));
              if (Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration) {
                animationCompleted = true;
                close();
              }
            }
            function start() {
              if (animationClosed)
                return;
              if (!node.parentNode) {
                close();
                return;
              }
              var playPause = function(playAnimation) {
                if (!animationCompleted) {
                  animationPaused = !playAnimation;
                  if (timings.animationDuration) {
                    var value = blockKeyframeAnimations(node, animationPaused);
                    animationPaused ? temporaryStyles.push(value) : removeFromArray(temporaryStyles, value);
                  }
                } else if (animationPaused && playAnimation) {
                  animationPaused = false;
                  close();
                }
              };
              var maxStagger = itemIndex > 0 && ((timings.transitionDuration && stagger.transitionDuration === 0) || (timings.animationDuration && stagger.animationDuration === 0)) && Math.max(stagger.animationDelay, stagger.transitionDelay);
              if (maxStagger) {
                $timeout(triggerAnimationStart, Math.floor(maxStagger * itemIndex * ONE_SECOND), false);
              } else {
                triggerAnimationStart();
              }
              runnerHost.resume = function() {
                playPause(true);
              };
              runnerHost.pause = function() {
                playPause(false);
              };
              function triggerAnimationStart() {
                if (animationClosed)
                  return;
                applyBlocking(false);
                forEach(temporaryStyles, function(entry) {
                  var key = entry[0];
                  var value = entry[1];
                  node.style[key] = value;
                });
                applyAnimationClasses(element, options);
                $$jqLite.addClass(element, activeClasses);
                if (flags.recalculateTimingStyles) {
                  fullClassName = node.className + ' ' + preparationClasses;
                  cacheKey = gcsHashFn(node, fullClassName);
                  timings = computeTimings(node, fullClassName, cacheKey);
                  relativeDelay = timings.maxDelay;
                  maxDelay = Math.max(relativeDelay, 0);
                  maxDuration = timings.maxDuration;
                  if (maxDuration === 0) {
                    close();
                    return;
                  }
                  flags.hasTransitions = timings.transitionDuration > 0;
                  flags.hasAnimations = timings.animationDuration > 0;
                }
                if (flags.applyAnimationDelay) {
                  relativeDelay = typeof options.delay !== "boolean" && truthyTimingValue(options.delay) ? parseFloat(options.delay) : relativeDelay;
                  maxDelay = Math.max(relativeDelay, 0);
                  timings.animationDelay = relativeDelay;
                  delayStyle = getCssDelayStyle(relativeDelay, true);
                  temporaryStyles.push(delayStyle);
                  node.style[delayStyle[0]] = delayStyle[1];
                }
                maxDelayTime = maxDelay * ONE_SECOND;
                maxDurationTime = maxDuration * ONE_SECOND;
                if (options.easing) {
                  var easeProp,
                      easeVal = options.easing;
                  if (flags.hasTransitions) {
                    easeProp = TRANSITION_PROP + TIMING_KEY;
                    temporaryStyles.push([easeProp, easeVal]);
                    node.style[easeProp] = easeVal;
                  }
                  if (flags.hasAnimations) {
                    easeProp = ANIMATION_PROP + TIMING_KEY;
                    temporaryStyles.push([easeProp, easeVal]);
                    node.style[easeProp] = easeVal;
                  }
                }
                if (timings.transitionDuration) {
                  events.push(TRANSITIONEND_EVENT);
                }
                if (timings.animationDuration) {
                  events.push(ANIMATIONEND_EVENT);
                }
                startTime = Date.now();
                var timerTime = maxDelayTime + CLOSING_TIME_BUFFER * maxDurationTime;
                var endTime = startTime + timerTime;
                var animationsData = element.data(ANIMATE_TIMER_KEY) || [];
                var setupFallbackTimer = true;
                if (animationsData.length) {
                  var currentTimerData = animationsData[0];
                  setupFallbackTimer = endTime > currentTimerData.expectedEndTime;
                  if (setupFallbackTimer) {
                    $timeout.cancel(currentTimerData.timer);
                  } else {
                    animationsData.push(close);
                  }
                }
                if (setupFallbackTimer) {
                  var timer = $timeout(onAnimationExpired, timerTime, false);
                  animationsData[0] = {
                    timer: timer,
                    expectedEndTime: endTime
                  };
                  animationsData.push(close);
                  element.data(ANIMATE_TIMER_KEY, animationsData);
                }
                if (events.length) {
                  element.on(events.join(' '), onAnimationProgress);
                }
                if (options.to) {
                  if (options.cleanupStyles) {
                    registerRestorableStyles(restoreStyles, node, Object.keys(options.to));
                  }
                  applyAnimationToStyles(element, options);
                }
              }
              function onAnimationExpired() {
                var animationsData = element.data(ANIMATE_TIMER_KEY);
                if (animationsData) {
                  for (var i = 1; i < animationsData.length; i++) {
                    animationsData[i]();
                  }
                  element.removeData(ANIMATE_TIMER_KEY);
                }
              }
            }
          };
        }];
      }];
      var $$AnimateCssDriverProvider = ['$$animationProvider', function($$animationProvider) {
        $$animationProvider.drivers.push('$$animateCssDriver');
        var NG_ANIMATE_SHIM_CLASS_NAME = 'ng-animate-shim';
        var NG_ANIMATE_ANCHOR_CLASS_NAME = 'ng-anchor';
        var NG_OUT_ANCHOR_CLASS_NAME = 'ng-anchor-out';
        var NG_IN_ANCHOR_CLASS_NAME = 'ng-anchor-in';
        function isDocumentFragment(node) {
          return node.parentNode && node.parentNode.nodeType === 11;
        }
        this.$get = ['$animateCss', '$rootScope', '$$AnimateRunner', '$rootElement', '$sniffer', '$$jqLite', '$document', function($animateCss, $rootScope, $$AnimateRunner, $rootElement, $sniffer, $$jqLite, $document) {
          if (!$sniffer.animations && !$sniffer.transitions)
            return noop;
          var bodyNode = $document[0].body;
          var rootNode = getDomNode($rootElement);
          var rootBodyElement = jqLite(isDocumentFragment(rootNode) || bodyNode.contains(rootNode) ? rootNode : bodyNode);
          var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
          return function initDriverFn(animationDetails) {
            return animationDetails.from && animationDetails.to ? prepareFromToAnchorAnimation(animationDetails.from, animationDetails.to, animationDetails.classes, animationDetails.anchors) : prepareRegularAnimation(animationDetails);
          };
          function filterCssClasses(classes) {
            return classes.replace(/\bng-\S+\b/g, '');
          }
          function getUniqueValues(a, b) {
            if (isString(a))
              a = a.split(' ');
            if (isString(b))
              b = b.split(' ');
            return a.filter(function(val) {
              return b.indexOf(val) === -1;
            }).join(' ');
          }
          function prepareAnchoredAnimation(classes, outAnchor, inAnchor) {
            var clone = jqLite(getDomNode(outAnchor).cloneNode(true));
            var startingClasses = filterCssClasses(getClassVal(clone));
            outAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);
            inAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);
            clone.addClass(NG_ANIMATE_ANCHOR_CLASS_NAME);
            rootBodyElement.append(clone);
            var animatorIn,
                animatorOut = prepareOutAnimation();
            if (!animatorOut) {
              animatorIn = prepareInAnimation();
              if (!animatorIn) {
                return end();
              }
            }
            var startingAnimator = animatorOut || animatorIn;
            return {start: function() {
                var runner;
                var currentAnimation = startingAnimator.start();
                currentAnimation.done(function() {
                  currentAnimation = null;
                  if (!animatorIn) {
                    animatorIn = prepareInAnimation();
                    if (animatorIn) {
                      currentAnimation = animatorIn.start();
                      currentAnimation.done(function() {
                        currentAnimation = null;
                        end();
                        runner.complete();
                      });
                      return currentAnimation;
                    }
                  }
                  end();
                  runner.complete();
                });
                runner = new $$AnimateRunner({
                  end: endFn,
                  cancel: endFn
                });
                return runner;
                function endFn() {
                  if (currentAnimation) {
                    currentAnimation.end();
                  }
                }
              }};
            function calculateAnchorStyles(anchor) {
              var styles = {};
              var coords = getDomNode(anchor).getBoundingClientRect();
              forEach(['width', 'height', 'top', 'left'], function(key) {
                var value = coords[key];
                switch (key) {
                  case 'top':
                    value += bodyNode.scrollTop;
                    break;
                  case 'left':
                    value += bodyNode.scrollLeft;
                    break;
                }
                styles[key] = Math.floor(value) + 'px';
              });
              return styles;
            }
            function prepareOutAnimation() {
              var animator = $animateCss(clone, {
                addClass: NG_OUT_ANCHOR_CLASS_NAME,
                delay: true,
                from: calculateAnchorStyles(outAnchor)
              });
              return animator.$$willAnimate ? animator : null;
            }
            function getClassVal(element) {
              return element.attr('class') || '';
            }
            function prepareInAnimation() {
              var endingClasses = filterCssClasses(getClassVal(inAnchor));
              var toAdd = getUniqueValues(endingClasses, startingClasses);
              var toRemove = getUniqueValues(startingClasses, endingClasses);
              var animator = $animateCss(clone, {
                to: calculateAnchorStyles(inAnchor),
                addClass: NG_IN_ANCHOR_CLASS_NAME + ' ' + toAdd,
                removeClass: NG_OUT_ANCHOR_CLASS_NAME + ' ' + toRemove,
                delay: true
              });
              return animator.$$willAnimate ? animator : null;
            }
            function end() {
              clone.remove();
              outAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);
              inAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);
            }
          }
          function prepareFromToAnchorAnimation(from, to, classes, anchors) {
            var fromAnimation = prepareRegularAnimation(from, noop);
            var toAnimation = prepareRegularAnimation(to, noop);
            var anchorAnimations = [];
            forEach(anchors, function(anchor) {
              var outElement = anchor['out'];
              var inElement = anchor['in'];
              var animator = prepareAnchoredAnimation(classes, outElement, inElement);
              if (animator) {
                anchorAnimations.push(animator);
              }
            });
            if (!fromAnimation && !toAnimation && anchorAnimations.length === 0)
              return;
            return {start: function() {
                var animationRunners = [];
                if (fromAnimation) {
                  animationRunners.push(fromAnimation.start());
                }
                if (toAnimation) {
                  animationRunners.push(toAnimation.start());
                }
                forEach(anchorAnimations, function(animation) {
                  animationRunners.push(animation.start());
                });
                var runner = new $$AnimateRunner({
                  end: endFn,
                  cancel: endFn
                });
                $$AnimateRunner.all(animationRunners, function(status) {
                  runner.complete(status);
                });
                return runner;
                function endFn() {
                  forEach(animationRunners, function(runner) {
                    runner.end();
                  });
                }
              }};
          }
          function prepareRegularAnimation(animationDetails) {
            var element = animationDetails.element;
            var options = animationDetails.options || {};
            if (animationDetails.structural) {
              options.event = animationDetails.event;
              options.structural = true;
              options.applyClassesEarly = true;
              if (animationDetails.event === 'leave') {
                options.onDone = options.domOperation;
              }
            }
            if (options.preparationClasses) {
              options.event = concatWithSpace(options.event, options.preparationClasses);
            }
            var animator = $animateCss(element, options);
            return animator.$$willAnimate ? animator : null;
          }
        }];
      }];
      var $$AnimateJsProvider = ['$animateProvider', function($animateProvider) {
        this.$get = ['$injector', '$$AnimateRunner', '$$jqLite', function($injector, $$AnimateRunner, $$jqLite) {
          var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
          return function(element, event, classes, options) {
            var animationClosed = false;
            if (arguments.length === 3 && isObject(classes)) {
              options = classes;
              classes = null;
            }
            options = prepareAnimationOptions(options);
            if (!classes) {
              classes = element.attr('class') || '';
              if (options.addClass) {
                classes += ' ' + options.addClass;
              }
              if (options.removeClass) {
                classes += ' ' + options.removeClass;
              }
            }
            var classesToAdd = options.addClass;
            var classesToRemove = options.removeClass;
            var animations = lookupAnimations(classes);
            var before,
                after;
            if (animations.length) {
              var afterFn,
                  beforeFn;
              if (event == 'leave') {
                beforeFn = 'leave';
                afterFn = 'afterLeave';
              } else {
                beforeFn = 'before' + event.charAt(0).toUpperCase() + event.substr(1);
                afterFn = event;
              }
              if (event !== 'enter' && event !== 'move') {
                before = packageAnimations(element, event, options, animations, beforeFn);
              }
              after = packageAnimations(element, event, options, animations, afterFn);
            }
            if (!before && !after)
              return;
            function applyOptions() {
              options.domOperation();
              applyAnimationClasses(element, options);
            }
            function close() {
              animationClosed = true;
              applyOptions();
              applyAnimationStyles(element, options);
            }
            var runner;
            return {
              $$willAnimate: true,
              end: function() {
                if (runner) {
                  runner.end();
                } else {
                  close();
                  runner = new $$AnimateRunner();
                  runner.complete(true);
                }
                return runner;
              },
              start: function() {
                if (runner) {
                  return runner;
                }
                runner = new $$AnimateRunner();
                var closeActiveAnimations;
                var chain = [];
                if (before) {
                  chain.push(function(fn) {
                    closeActiveAnimations = before(fn);
                  });
                }
                if (chain.length) {
                  chain.push(function(fn) {
                    applyOptions();
                    fn(true);
                  });
                } else {
                  applyOptions();
                }
                if (after) {
                  chain.push(function(fn) {
                    closeActiveAnimations = after(fn);
                  });
                }
                runner.setHost({
                  end: function() {
                    endAnimations();
                  },
                  cancel: function() {
                    endAnimations(true);
                  }
                });
                $$AnimateRunner.chain(chain, onComplete);
                return runner;
                function onComplete(success) {
                  close(success);
                  runner.complete(success);
                }
                function endAnimations(cancelled) {
                  if (!animationClosed) {
                    (closeActiveAnimations || noop)(cancelled);
                    onComplete(cancelled);
                  }
                }
              }
            };
            function executeAnimationFn(fn, element, event, options, onDone) {
              var args;
              switch (event) {
                case 'animate':
                  args = [element, options.from, options.to, onDone];
                  break;
                case 'setClass':
                  args = [element, classesToAdd, classesToRemove, onDone];
                  break;
                case 'addClass':
                  args = [element, classesToAdd, onDone];
                  break;
                case 'removeClass':
                  args = [element, classesToRemove, onDone];
                  break;
                default:
                  args = [element, onDone];
                  break;
              }
              args.push(options);
              var value = fn.apply(fn, args);
              if (value) {
                if (isFunction(value.start)) {
                  value = value.start();
                }
                if (value instanceof $$AnimateRunner) {
                  value.done(onDone);
                } else if (isFunction(value)) {
                  return value;
                }
              }
              return noop;
            }
            function groupEventedAnimations(element, event, options, animations, fnName) {
              var operations = [];
              forEach(animations, function(ani) {
                var animation = ani[fnName];
                if (!animation)
                  return;
                operations.push(function() {
                  var runner;
                  var endProgressCb;
                  var resolved = false;
                  var onAnimationComplete = function(rejected) {
                    if (!resolved) {
                      resolved = true;
                      (endProgressCb || noop)(rejected);
                      runner.complete(!rejected);
                    }
                  };
                  runner = new $$AnimateRunner({
                    end: function() {
                      onAnimationComplete();
                    },
                    cancel: function() {
                      onAnimationComplete(true);
                    }
                  });
                  endProgressCb = executeAnimationFn(animation, element, event, options, function(result) {
                    var cancelled = result === false;
                    onAnimationComplete(cancelled);
                  });
                  return runner;
                });
              });
              return operations;
            }
            function packageAnimations(element, event, options, animations, fnName) {
              var operations = groupEventedAnimations(element, event, options, animations, fnName);
              if (operations.length === 0) {
                var a,
                    b;
                if (fnName === 'beforeSetClass') {
                  a = groupEventedAnimations(element, 'removeClass', options, animations, 'beforeRemoveClass');
                  b = groupEventedAnimations(element, 'addClass', options, animations, 'beforeAddClass');
                } else if (fnName === 'setClass') {
                  a = groupEventedAnimations(element, 'removeClass', options, animations, 'removeClass');
                  b = groupEventedAnimations(element, 'addClass', options, animations, 'addClass');
                }
                if (a) {
                  operations = operations.concat(a);
                }
                if (b) {
                  operations = operations.concat(b);
                }
              }
              if (operations.length === 0)
                return;
              return function startAnimation(callback) {
                var runners = [];
                if (operations.length) {
                  forEach(operations, function(animateFn) {
                    runners.push(animateFn());
                  });
                }
                runners.length ? $$AnimateRunner.all(runners, callback) : callback();
                return function endFn(reject) {
                  forEach(runners, function(runner) {
                    reject ? runner.cancel() : runner.end();
                  });
                };
              };
            }
          };
          function lookupAnimations(classes) {
            classes = isArray(classes) ? classes : classes.split(' ');
            var matches = [],
                flagMap = {};
            for (var i = 0; i < classes.length; i++) {
              var klass = classes[i],
                  animationFactory = $animateProvider.$$registeredAnimations[klass];
              if (animationFactory && !flagMap[klass]) {
                matches.push($injector.get(animationFactory));
                flagMap[klass] = true;
              }
            }
            return matches;
          }
        }];
      }];
      var $$AnimateJsDriverProvider = ['$$animationProvider', function($$animationProvider) {
        $$animationProvider.drivers.push('$$animateJsDriver');
        this.$get = ['$$animateJs', '$$AnimateRunner', function($$animateJs, $$AnimateRunner) {
          return function initDriverFn(animationDetails) {
            if (animationDetails.from && animationDetails.to) {
              var fromAnimation = prepareAnimation(animationDetails.from);
              var toAnimation = prepareAnimation(animationDetails.to);
              if (!fromAnimation && !toAnimation)
                return;
              return {start: function() {
                  var animationRunners = [];
                  if (fromAnimation) {
                    animationRunners.push(fromAnimation.start());
                  }
                  if (toAnimation) {
                    animationRunners.push(toAnimation.start());
                  }
                  $$AnimateRunner.all(animationRunners, done);
                  var runner = new $$AnimateRunner({
                    end: endFnFactory(),
                    cancel: endFnFactory()
                  });
                  return runner;
                  function endFnFactory() {
                    return function() {
                      forEach(animationRunners, function(runner) {
                        runner.end();
                      });
                    };
                  }
                  function done(status) {
                    runner.complete(status);
                  }
                }};
            } else {
              return prepareAnimation(animationDetails);
            }
          };
          function prepareAnimation(animationDetails) {
            var element = animationDetails.element;
            var event = animationDetails.event;
            var options = animationDetails.options;
            var classes = animationDetails.classes;
            return $$animateJs(element, event, classes, options);
          }
        }];
      }];
      var NG_ANIMATE_ATTR_NAME = 'data-ng-animate';
      var NG_ANIMATE_PIN_DATA = '$ngAnimatePin';
      var $$AnimateQueueProvider = ['$animateProvider', function($animateProvider) {
        var PRE_DIGEST_STATE = 1;
        var RUNNING_STATE = 2;
        var ONE_SPACE = ' ';
        var rules = this.rules = {
          skip: [],
          cancel: [],
          join: []
        };
        function makeTruthyCssClassMap(classString) {
          if (!classString) {
            return null;
          }
          var keys = classString.split(ONE_SPACE);
          var map = Object.create(null);
          forEach(keys, function(key) {
            map[key] = true;
          });
          return map;
        }
        function hasMatchingClasses(newClassString, currentClassString) {
          if (newClassString && currentClassString) {
            var currentClassMap = makeTruthyCssClassMap(currentClassString);
            return newClassString.split(ONE_SPACE).some(function(className) {
              return currentClassMap[className];
            });
          }
        }
        function isAllowed(ruleType, element, currentAnimation, previousAnimation) {
          return rules[ruleType].some(function(fn) {
            return fn(element, currentAnimation, previousAnimation);
          });
        }
        function hasAnimationClasses(animation, and) {
          var a = (animation.addClass || '').length > 0;
          var b = (animation.removeClass || '').length > 0;
          return and ? a && b : a || b;
        }
        rules.join.push(function(element, newAnimation, currentAnimation) {
          return !newAnimation.structural && hasAnimationClasses(newAnimation);
        });
        rules.skip.push(function(element, newAnimation, currentAnimation) {
          return !newAnimation.structural && !hasAnimationClasses(newAnimation);
        });
        rules.skip.push(function(element, newAnimation, currentAnimation) {
          return currentAnimation.event == 'leave' && newAnimation.structural;
        });
        rules.skip.push(function(element, newAnimation, currentAnimation) {
          return currentAnimation.structural && currentAnimation.state === RUNNING_STATE && !newAnimation.structural;
        });
        rules.cancel.push(function(element, newAnimation, currentAnimation) {
          return currentAnimation.structural && newAnimation.structural;
        });
        rules.cancel.push(function(element, newAnimation, currentAnimation) {
          return currentAnimation.state === RUNNING_STATE && newAnimation.structural;
        });
        rules.cancel.push(function(element, newAnimation, currentAnimation) {
          if (currentAnimation.structural)
            return false;
          var nA = newAnimation.addClass;
          var nR = newAnimation.removeClass;
          var cA = currentAnimation.addClass;
          var cR = currentAnimation.removeClass;
          if ((isUndefined(nA) && isUndefined(nR)) || (isUndefined(cA) && isUndefined(cR))) {
            return false;
          }
          return hasMatchingClasses(nA, cR) || hasMatchingClasses(nR, cA);
        });
        this.$get = ['$$rAF', '$rootScope', '$rootElement', '$document', '$$HashMap', '$$animation', '$$AnimateRunner', '$templateRequest', '$$jqLite', '$$forceReflow', function($$rAF, $rootScope, $rootElement, $document, $$HashMap, $$animation, $$AnimateRunner, $templateRequest, $$jqLite, $$forceReflow) {
          var activeAnimationsLookup = new $$HashMap();
          var disabledElementsLookup = new $$HashMap();
          var animationsEnabled = null;
          function postDigestTaskFactory() {
            var postDigestCalled = false;
            return function(fn) {
              if (postDigestCalled) {
                fn();
              } else {
                $rootScope.$$postDigest(function() {
                  postDigestCalled = true;
                  fn();
                });
              }
            };
          }
          var deregisterWatch = $rootScope.$watch(function() {
            return $templateRequest.totalPendingRequests === 0;
          }, function(isEmpty) {
            if (!isEmpty)
              return;
            deregisterWatch();
            $rootScope.$$postDigest(function() {
              $rootScope.$$postDigest(function() {
                if (animationsEnabled === null) {
                  animationsEnabled = true;
                }
              });
            });
          });
          var callbackRegistry = {};
          var classNameFilter = $animateProvider.classNameFilter();
          var isAnimatableClassName = !classNameFilter ? function() {
            return true;
          } : function(className) {
            return classNameFilter.test(className);
          };
          var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
          function normalizeAnimationDetails(element, animation) {
            return mergeAnimationDetails(element, animation, {});
          }
          var contains = window.Node.prototype.contains || function(arg) {
            return this === arg || !!(this.compareDocumentPosition(arg) & 16);
          };
          function findCallbacks(parent, element, event) {
            var targetNode = getDomNode(element);
            var targetParentNode = getDomNode(parent);
            var matches = [];
            var entries = callbackRegistry[event];
            if (entries) {
              forEach(entries, function(entry) {
                if (contains.call(entry.node, targetNode)) {
                  matches.push(entry.callback);
                } else if (event === 'leave' && contains.call(entry.node, targetParentNode)) {
                  matches.push(entry.callback);
                }
              });
            }
            return matches;
          }
          function filterFromRegistry(list, matchContainer, matchCallback) {
            var containerNode = extractElementNode(matchContainer);
            return list.filter(function(entry) {
              var isMatch = entry.node === containerNode && (!matchCallback || entry.callback === matchCallback);
              return !isMatch;
            });
          }
          function cleanupEventListeners(phase, element) {
            if (phase === 'close' && !element[0].parentNode) {
              $animate.off(element);
            }
          }
          var $animate = {
            on: function(event, container, callback) {
              var node = extractElementNode(container);
              callbackRegistry[event] = callbackRegistry[event] || [];
              callbackRegistry[event].push({
                node: node,
                callback: callback
              });
              jqLite(container).on('$destroy', function() {
                var animationDetails = activeAnimationsLookup.get(node);
                if (!animationDetails) {
                  $animate.off(event, container, callback);
                }
              });
            },
            off: function(event, container, callback) {
              if (arguments.length === 1 && !angular.isString(arguments[0])) {
                container = arguments[0];
                for (var eventType in callbackRegistry) {
                  callbackRegistry[eventType] = filterFromRegistry(callbackRegistry[eventType], container);
                }
                return;
              }
              var entries = callbackRegistry[event];
              if (!entries)
                return;
              callbackRegistry[event] = arguments.length === 1 ? null : filterFromRegistry(entries, container, callback);
            },
            pin: function(element, parentElement) {
              assertArg(isElement(element), 'element', 'not an element');
              assertArg(isElement(parentElement), 'parentElement', 'not an element');
              element.data(NG_ANIMATE_PIN_DATA, parentElement);
            },
            push: function(element, event, options, domOperation) {
              options = options || {};
              options.domOperation = domOperation;
              return queueAnimation(element, event, options);
            },
            enabled: function(element, bool) {
              var argCount = arguments.length;
              if (argCount === 0) {
                bool = !!animationsEnabled;
              } else {
                var hasElement = isElement(element);
                if (!hasElement) {
                  bool = animationsEnabled = !!element;
                } else {
                  var node = getDomNode(element);
                  var recordExists = disabledElementsLookup.get(node);
                  if (argCount === 1) {
                    bool = !recordExists;
                  } else {
                    disabledElementsLookup.put(node, !bool);
                  }
                }
              }
              return bool;
            }
          };
          return $animate;
          function queueAnimation(element, event, initialOptions) {
            var options = copy(initialOptions);
            var node,
                parent;
            element = stripCommentsFromElement(element);
            if (element) {
              node = getDomNode(element);
              parent = element.parent();
            }
            options = prepareAnimationOptions(options);
            var runner = new $$AnimateRunner();
            var runInNextPostDigestOrNow = postDigestTaskFactory();
            if (isArray(options.addClass)) {
              options.addClass = options.addClass.join(' ');
            }
            if (options.addClass && !isString(options.addClass)) {
              options.addClass = null;
            }
            if (isArray(options.removeClass)) {
              options.removeClass = options.removeClass.join(' ');
            }
            if (options.removeClass && !isString(options.removeClass)) {
              options.removeClass = null;
            }
            if (options.from && !isObject(options.from)) {
              options.from = null;
            }
            if (options.to && !isObject(options.to)) {
              options.to = null;
            }
            if (!node) {
              close();
              return runner;
            }
            var className = [node.className, options.addClass, options.removeClass].join(' ');
            if (!isAnimatableClassName(className)) {
              close();
              return runner;
            }
            var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;
            var documentHidden = $document[0].hidden;
            var skipAnimations = !animationsEnabled || documentHidden || disabledElementsLookup.get(node);
            var existingAnimation = (!skipAnimations && activeAnimationsLookup.get(node)) || {};
            var hasExistingAnimation = !!existingAnimation.state;
            if (!skipAnimations && (!hasExistingAnimation || existingAnimation.state != PRE_DIGEST_STATE)) {
              skipAnimations = !areAnimationsAllowed(element, parent, event);
            }
            if (skipAnimations) {
              if (documentHidden)
                notifyProgress(runner, event, 'start');
              close();
              if (documentHidden)
                notifyProgress(runner, event, 'close');
              return runner;
            }
            if (isStructural) {
              closeChildAnimations(element);
            }
            var newAnimation = {
              structural: isStructural,
              element: element,
              event: event,
              addClass: options.addClass,
              removeClass: options.removeClass,
              close: close,
              options: options,
              runner: runner
            };
            if (hasExistingAnimation) {
              var skipAnimationFlag = isAllowed('skip', element, newAnimation, existingAnimation);
              if (skipAnimationFlag) {
                if (existingAnimation.state === RUNNING_STATE) {
                  close();
                  return runner;
                } else {
                  mergeAnimationDetails(element, existingAnimation, newAnimation);
                  return existingAnimation.runner;
                }
              }
              var cancelAnimationFlag = isAllowed('cancel', element, newAnimation, existingAnimation);
              if (cancelAnimationFlag) {
                if (existingAnimation.state === RUNNING_STATE) {
                  existingAnimation.runner.end();
                } else if (existingAnimation.structural) {
                  existingAnimation.close();
                } else {
                  mergeAnimationDetails(element, existingAnimation, newAnimation);
                  return existingAnimation.runner;
                }
              } else {
                var joinAnimationFlag = isAllowed('join', element, newAnimation, existingAnimation);
                if (joinAnimationFlag) {
                  if (existingAnimation.state === RUNNING_STATE) {
                    normalizeAnimationDetails(element, newAnimation);
                  } else {
                    applyGeneratedPreparationClasses(element, isStructural ? event : null, options);
                    event = newAnimation.event = existingAnimation.event;
                    options = mergeAnimationDetails(element, existingAnimation, newAnimation);
                    return existingAnimation.runner;
                  }
                }
              }
            } else {
              normalizeAnimationDetails(element, newAnimation);
            }
            var isValidAnimation = newAnimation.structural;
            if (!isValidAnimation) {
              isValidAnimation = (newAnimation.event === 'animate' && Object.keys(newAnimation.options.to || {}).length > 0) || hasAnimationClasses(newAnimation);
            }
            if (!isValidAnimation) {
              close();
              clearElementAnimationState(element);
              return runner;
            }
            var counter = (existingAnimation.counter || 0) + 1;
            newAnimation.counter = counter;
            markElementAnimationState(element, PRE_DIGEST_STATE, newAnimation);
            $rootScope.$$postDigest(function() {
              var animationDetails = activeAnimationsLookup.get(node);
              var animationCancelled = !animationDetails;
              animationDetails = animationDetails || {};
              var parentElement = element.parent() || [];
              var isValidAnimation = parentElement.length > 0 && (animationDetails.event === 'animate' || animationDetails.structural || hasAnimationClasses(animationDetails));
              if (animationCancelled || animationDetails.counter !== counter || !isValidAnimation) {
                if (animationCancelled) {
                  applyAnimationClasses(element, options);
                  applyAnimationStyles(element, options);
                }
                if (animationCancelled || (isStructural && animationDetails.event !== event)) {
                  options.domOperation();
                  runner.end();
                }
                if (!isValidAnimation) {
                  clearElementAnimationState(element);
                }
                return;
              }
              event = !animationDetails.structural && hasAnimationClasses(animationDetails, true) ? 'setClass' : animationDetails.event;
              markElementAnimationState(element, RUNNING_STATE);
              var realRunner = $$animation(element, event, animationDetails.options);
              runner.setHost(realRunner);
              notifyProgress(runner, event, 'start', {});
              realRunner.done(function(status) {
                close(!status);
                var animationDetails = activeAnimationsLookup.get(node);
                if (animationDetails && animationDetails.counter === counter) {
                  clearElementAnimationState(getDomNode(element));
                }
                notifyProgress(runner, event, 'close', {});
              });
            });
            return runner;
            function notifyProgress(runner, event, phase, data) {
              runInNextPostDigestOrNow(function() {
                var callbacks = findCallbacks(parent, element, event);
                if (callbacks.length) {
                  $$rAF(function() {
                    forEach(callbacks, function(callback) {
                      callback(element, phase, data);
                    });
                    cleanupEventListeners(phase, element);
                  });
                } else {
                  cleanupEventListeners(phase, element);
                }
              });
              runner.progress(event, phase, data);
            }
            function close(reject) {
              clearGeneratedClasses(element, options);
              applyAnimationClasses(element, options);
              applyAnimationStyles(element, options);
              options.domOperation();
              runner.complete(!reject);
            }
          }
          function closeChildAnimations(element) {
            var node = getDomNode(element);
            var children = node.querySelectorAll('[' + NG_ANIMATE_ATTR_NAME + ']');
            forEach(children, function(child) {
              var state = parseInt(child.getAttribute(NG_ANIMATE_ATTR_NAME));
              var animationDetails = activeAnimationsLookup.get(child);
              if (animationDetails) {
                switch (state) {
                  case RUNNING_STATE:
                    animationDetails.runner.end();
                  case PRE_DIGEST_STATE:
                    activeAnimationsLookup.remove(child);
                    break;
                }
              }
            });
          }
          function clearElementAnimationState(element) {
            var node = getDomNode(element);
            node.removeAttribute(NG_ANIMATE_ATTR_NAME);
            activeAnimationsLookup.remove(node);
          }
          function isMatchingElement(nodeOrElmA, nodeOrElmB) {
            return getDomNode(nodeOrElmA) === getDomNode(nodeOrElmB);
          }
          function areAnimationsAllowed(element, parentElement, event) {
            var bodyElement = jqLite($document[0].body);
            var bodyElementDetected = isMatchingElement(element, bodyElement) || element[0].nodeName === 'HTML';
            var rootElementDetected = isMatchingElement(element, $rootElement);
            var parentAnimationDetected = false;
            var animateChildren;
            var elementDisabled = disabledElementsLookup.get(getDomNode(element));
            var parentHost = jqLite.data(element[0], NG_ANIMATE_PIN_DATA);
            if (parentHost) {
              parentElement = parentHost;
            }
            parentElement = getDomNode(parentElement);
            while (parentElement) {
              if (!rootElementDetected) {
                rootElementDetected = isMatchingElement(parentElement, $rootElement);
              }
              if (parentElement.nodeType !== ELEMENT_NODE) {
                break;
              }
              var details = activeAnimationsLookup.get(parentElement) || {};
              if (!parentAnimationDetected) {
                var parentElementDisabled = disabledElementsLookup.get(parentElement);
                if (parentElementDisabled === true && elementDisabled !== false) {
                  elementDisabled = true;
                  break;
                } else if (parentElementDisabled === false) {
                  elementDisabled = false;
                }
                parentAnimationDetected = details.structural;
              }
              if (isUndefined(animateChildren) || animateChildren === true) {
                var value = jqLite.data(parentElement, NG_ANIMATE_CHILDREN_DATA);
                if (isDefined(value)) {
                  animateChildren = value;
                }
              }
              if (parentAnimationDetected && animateChildren === false)
                break;
              if (!bodyElementDetected) {
                bodyElementDetected = isMatchingElement(parentElement, bodyElement);
              }
              if (bodyElementDetected && rootElementDetected) {
                break;
              }
              if (!rootElementDetected) {
                parentHost = jqLite.data(parentElement, NG_ANIMATE_PIN_DATA);
                if (parentHost) {
                  parentElement = getDomNode(parentHost);
                  continue;
                }
              }
              parentElement = parentElement.parentNode;
            }
            var allowAnimation = (!parentAnimationDetected || animateChildren) && elementDisabled !== true;
            return allowAnimation && rootElementDetected && bodyElementDetected;
          }
          function markElementAnimationState(element, state, details) {
            details = details || {};
            details.state = state;
            var node = getDomNode(element);
            node.setAttribute(NG_ANIMATE_ATTR_NAME, state);
            var oldValue = activeAnimationsLookup.get(node);
            var newValue = oldValue ? extend(oldValue, details) : details;
            activeAnimationsLookup.put(node, newValue);
          }
        }];
      }];
      var $$AnimationProvider = ['$animateProvider', function($animateProvider) {
        var NG_ANIMATE_REF_ATTR = 'ng-animate-ref';
        var drivers = this.drivers = [];
        var RUNNER_STORAGE_KEY = '$$animationRunner';
        function setRunner(element, runner) {
          element.data(RUNNER_STORAGE_KEY, runner);
        }
        function removeRunner(element) {
          element.removeData(RUNNER_STORAGE_KEY);
        }
        function getRunner(element) {
          return element.data(RUNNER_STORAGE_KEY);
        }
        this.$get = ['$$jqLite', '$rootScope', '$injector', '$$AnimateRunner', '$$HashMap', '$$rAFScheduler', function($$jqLite, $rootScope, $injector, $$AnimateRunner, $$HashMap, $$rAFScheduler) {
          var animationQueue = [];
          var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
          function sortAnimations(animations) {
            var tree = {children: []};
            var i,
                lookup = new $$HashMap();
            for (i = 0; i < animations.length; i++) {
              var animation = animations[i];
              lookup.put(animation.domNode, animations[i] = {
                domNode: animation.domNode,
                fn: animation.fn,
                children: []
              });
            }
            for (i = 0; i < animations.length; i++) {
              processNode(animations[i]);
            }
            return flatten(tree);
            function processNode(entry) {
              if (entry.processed)
                return entry;
              entry.processed = true;
              var elementNode = entry.domNode;
              var parentNode = elementNode.parentNode;
              lookup.put(elementNode, entry);
              var parentEntry;
              while (parentNode) {
                parentEntry = lookup.get(parentNode);
                if (parentEntry) {
                  if (!parentEntry.processed) {
                    parentEntry = processNode(parentEntry);
                  }
                  break;
                }
                parentNode = parentNode.parentNode;
              }
              (parentEntry || tree).children.push(entry);
              return entry;
            }
            function flatten(tree) {
              var result = [];
              var queue = [];
              var i;
              for (i = 0; i < tree.children.length; i++) {
                queue.push(tree.children[i]);
              }
              var remainingLevelEntries = queue.length;
              var nextLevelEntries = 0;
              var row = [];
              for (i = 0; i < queue.length; i++) {
                var entry = queue[i];
                if (remainingLevelEntries <= 0) {
                  remainingLevelEntries = nextLevelEntries;
                  nextLevelEntries = 0;
                  result.push(row);
                  row = [];
                }
                row.push(entry.fn);
                entry.children.forEach(function(childEntry) {
                  nextLevelEntries++;
                  queue.push(childEntry);
                });
                remainingLevelEntries--;
              }
              if (row.length) {
                result.push(row);
              }
              return result;
            }
          }
          return function(element, event, options) {
            options = prepareAnimationOptions(options);
            var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;
            var runner = new $$AnimateRunner({
              end: function() {
                close();
              },
              cancel: function() {
                close(true);
              }
            });
            if (!drivers.length) {
              close();
              return runner;
            }
            setRunner(element, runner);
            var classes = mergeClasses(element.attr('class'), mergeClasses(options.addClass, options.removeClass));
            var tempClasses = options.tempClasses;
            if (tempClasses) {
              classes += ' ' + tempClasses;
              options.tempClasses = null;
            }
            var prepareClassName;
            if (isStructural) {
              prepareClassName = 'ng-' + event + PREPARE_CLASS_SUFFIX;
              $$jqLite.addClass(element, prepareClassName);
            }
            animationQueue.push({
              element: element,
              classes: classes,
              event: event,
              structural: isStructural,
              options: options,
              beforeStart: beforeStart,
              close: close
            });
            element.on('$destroy', handleDestroyedElement);
            if (animationQueue.length > 1)
              return runner;
            $rootScope.$$postDigest(function() {
              var animations = [];
              forEach(animationQueue, function(entry) {
                if (getRunner(entry.element)) {
                  animations.push(entry);
                } else {
                  entry.close();
                }
              });
              animationQueue.length = 0;
              var groupedAnimations = groupAnimations(animations);
              var toBeSortedAnimations = [];
              forEach(groupedAnimations, function(animationEntry) {
                toBeSortedAnimations.push({
                  domNode: getDomNode(animationEntry.from ? animationEntry.from.element : animationEntry.element),
                  fn: function triggerAnimationStart() {
                    animationEntry.beforeStart();
                    var startAnimationFn,
                        closeFn = animationEntry.close;
                    var targetElement = animationEntry.anchors ? (animationEntry.from.element || animationEntry.to.element) : animationEntry.element;
                    if (getRunner(targetElement)) {
                      var operation = invokeFirstDriver(animationEntry);
                      if (operation) {
                        startAnimationFn = operation.start;
                      }
                    }
                    if (!startAnimationFn) {
                      closeFn();
                    } else {
                      var animationRunner = startAnimationFn();
                      animationRunner.done(function(status) {
                        closeFn(!status);
                      });
                      updateAnimationRunners(animationEntry, animationRunner);
                    }
                  }
                });
              });
              $$rAFScheduler(sortAnimations(toBeSortedAnimations));
            });
            return runner;
            function getAnchorNodes(node) {
              var SELECTOR = '[' + NG_ANIMATE_REF_ATTR + ']';
              var items = node.hasAttribute(NG_ANIMATE_REF_ATTR) ? [node] : node.querySelectorAll(SELECTOR);
              var anchors = [];
              forEach(items, function(node) {
                var attr = node.getAttribute(NG_ANIMATE_REF_ATTR);
                if (attr && attr.length) {
                  anchors.push(node);
                }
              });
              return anchors;
            }
            function groupAnimations(animations) {
              var preparedAnimations = [];
              var refLookup = {};
              forEach(animations, function(animation, index) {
                var element = animation.element;
                var node = getDomNode(element);
                var event = animation.event;
                var enterOrMove = ['enter', 'move'].indexOf(event) >= 0;
                var anchorNodes = animation.structural ? getAnchorNodes(node) : [];
                if (anchorNodes.length) {
                  var direction = enterOrMove ? 'to' : 'from';
                  forEach(anchorNodes, function(anchor) {
                    var key = anchor.getAttribute(NG_ANIMATE_REF_ATTR);
                    refLookup[key] = refLookup[key] || {};
                    refLookup[key][direction] = {
                      animationID: index,
                      element: jqLite(anchor)
                    };
                  });
                } else {
                  preparedAnimations.push(animation);
                }
              });
              var usedIndicesLookup = {};
              var anchorGroups = {};
              forEach(refLookup, function(operations, key) {
                var from = operations.from;
                var to = operations.to;
                if (!from || !to) {
                  var index = from ? from.animationID : to.animationID;
                  var indexKey = index.toString();
                  if (!usedIndicesLookup[indexKey]) {
                    usedIndicesLookup[indexKey] = true;
                    preparedAnimations.push(animations[index]);
                  }
                  return;
                }
                var fromAnimation = animations[from.animationID];
                var toAnimation = animations[to.animationID];
                var lookupKey = from.animationID.toString();
                if (!anchorGroups[lookupKey]) {
                  var group = anchorGroups[lookupKey] = {
                    structural: true,
                    beforeStart: function() {
                      fromAnimation.beforeStart();
                      toAnimation.beforeStart();
                    },
                    close: function() {
                      fromAnimation.close();
                      toAnimation.close();
                    },
                    classes: cssClassesIntersection(fromAnimation.classes, toAnimation.classes),
                    from: fromAnimation,
                    to: toAnimation,
                    anchors: []
                  };
                  if (group.classes.length) {
                    preparedAnimations.push(group);
                  } else {
                    preparedAnimations.push(fromAnimation);
                    preparedAnimations.push(toAnimation);
                  }
                }
                anchorGroups[lookupKey].anchors.push({
                  'out': from.element,
                  'in': to.element
                });
              });
              return preparedAnimations;
            }
            function cssClassesIntersection(a, b) {
              a = a.split(' ');
              b = b.split(' ');
              var matches = [];
              for (var i = 0; i < a.length; i++) {
                var aa = a[i];
                if (aa.substring(0, 3) === 'ng-')
                  continue;
                for (var j = 0; j < b.length; j++) {
                  if (aa === b[j]) {
                    matches.push(aa);
                    break;
                  }
                }
              }
              return matches.join(' ');
            }
            function invokeFirstDriver(animationDetails) {
              for (var i = drivers.length - 1; i >= 0; i--) {
                var driverName = drivers[i];
                if (!$injector.has(driverName))
                  continue;
                var factory = $injector.get(driverName);
                var driver = factory(animationDetails);
                if (driver) {
                  return driver;
                }
              }
            }
            function beforeStart() {
              element.addClass(NG_ANIMATE_CLASSNAME);
              if (tempClasses) {
                $$jqLite.addClass(element, tempClasses);
              }
              if (prepareClassName) {
                $$jqLite.removeClass(element, prepareClassName);
                prepareClassName = null;
              }
            }
            function updateAnimationRunners(animation, newRunner) {
              if (animation.from && animation.to) {
                update(animation.from.element);
                update(animation.to.element);
              } else {
                update(animation.element);
              }
              function update(element) {
                getRunner(element).setHost(newRunner);
              }
            }
            function handleDestroyedElement() {
              var runner = getRunner(element);
              if (runner && (event !== 'leave' || !options.$$domOperationFired)) {
                runner.end();
              }
            }
            function close(rejected) {
              element.off('$destroy', handleDestroyedElement);
              removeRunner(element);
              applyAnimationClasses(element, options);
              applyAnimationStyles(element, options);
              options.domOperation();
              if (tempClasses) {
                $$jqLite.removeClass(element, tempClasses);
              }
              element.removeClass(NG_ANIMATE_CLASSNAME);
              runner.complete(!rejected);
            }
          };
        }];
      }];
      var ngAnimateSwapDirective = ['$animate', '$rootScope', function($animate, $rootScope) {
        return {
          restrict: 'A',
          transclude: 'element',
          terminal: true,
          priority: 600,
          link: function(scope, $element, attrs, ctrl, $transclude) {
            var previousElement,
                previousScope;
            scope.$watchCollection(attrs.ngAnimateSwap || attrs['for'], function(value) {
              if (previousElement) {
                $animate.leave(previousElement);
              }
              if (previousScope) {
                previousScope.$destroy();
                previousScope = null;
              }
              if (value || value === 0) {
                previousScope = scope.$new();
                $transclude(previousScope, function(element) {
                  previousElement = element;
                  $animate.enter(element, null, $element);
                });
              }
            });
          }
        };
      }];
      angular.module('ngAnimate', []).directive('ngAnimateSwap', ngAnimateSwapDirective).directive('ngAnimateChildren', $$AnimateChildrenDirective).factory('$$rAFScheduler', $$rAFSchedulerFactory).provider('$$animateQueue', $$AnimateQueueProvider).provider('$$animation', $$AnimationProvider).provider('$animateCss', $AnimateCssProvider).provider('$$animateCssDriver', $$AnimateCssDriverProvider).provider('$$animateJs', $$AnimateJsProvider).provider('$$animateJsDriver', $$AnimateJsDriverProvider);
    })(window, window.angular);
  })();
  return _retrieveGlobal();
});

$__System.registerDynamic("6", ["4"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('4');
  return module.exports;
});

$__System.registerDynamic("7", [], false, function($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, "angular", null);
  (function() {
    "format global";
    "exports angular";
    (function(window) {
      'use strict';
      function minErr(module, ErrorConstructor) {
        ErrorConstructor = ErrorConstructor || Error;
        return function() {
          var SKIP_INDEXES = 2;
          var templateArgs = arguments,
              code = templateArgs[0],
              message = '[' + (module ? module + ':' : '') + code + '] ',
              template = templateArgs[1],
              paramPrefix,
              i;
          message += template.replace(/\{\d+\}/g, function(match) {
            var index = +match.slice(1, -1),
                shiftedIndex = index + SKIP_INDEXES;
            if (shiftedIndex < templateArgs.length) {
              return toDebugString(templateArgs[shiftedIndex]);
            }
            return match;
          });
          message += '\nhttp://errors.angularjs.org/1.5.7/' + (module ? module + '/' : '') + code;
          for (i = SKIP_INDEXES, paramPrefix = '?'; i < templateArgs.length; i++, paramPrefix = '&') {
            message += paramPrefix + 'p' + (i - SKIP_INDEXES) + '=' + encodeURIComponent(toDebugString(templateArgs[i]));
          }
          return new ErrorConstructor(message);
        };
      }
      var REGEX_STRING_REGEXP = /^\/(.+)\/([a-z]*)$/;
      var VALIDITY_STATE_PROPERTY = 'validity';
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var lowercase = function(string) {
        return isString(string) ? string.toLowerCase() : string;
      };
      var uppercase = function(string) {
        return isString(string) ? string.toUpperCase() : string;
      };
      var manualLowercase = function(s) {
        return isString(s) ? s.replace(/[A-Z]/g, function(ch) {
          return String.fromCharCode(ch.charCodeAt(0) | 32);
        }) : s;
      };
      var manualUppercase = function(s) {
        return isString(s) ? s.replace(/[a-z]/g, function(ch) {
          return String.fromCharCode(ch.charCodeAt(0) & ~32);
        }) : s;
      };
      if ('i' !== 'I'.toLowerCase()) {
        lowercase = manualLowercase;
        uppercase = manualUppercase;
      }
      var msie,
          jqLite,
          jQuery,
          slice = [].slice,
          splice = [].splice,
          push = [].push,
          toString = Object.prototype.toString,
          getPrototypeOf = Object.getPrototypeOf,
          ngMinErr = minErr('ng'),
          angular = window.angular || (window.angular = {}),
          angularModule,
          uid = 0;
      msie = window.document.documentMode;
      function isArrayLike(obj) {
        if (obj == null || isWindow(obj))
          return false;
        if (isArray(obj) || isString(obj) || (jqLite && obj instanceof jqLite))
          return true;
        var length = "length" in Object(obj) && obj.length;
        return isNumber(length) && (length >= 0 && ((length - 1) in obj || obj instanceof Array) || typeof obj.item == 'function');
      }
      function forEach(obj, iterator, context) {
        var key,
            length;
        if (obj) {
          if (isFunction(obj)) {
            for (key in obj) {
              if (key != 'prototype' && key != 'length' && key != 'name' && (!obj.hasOwnProperty || obj.hasOwnProperty(key))) {
                iterator.call(context, obj[key], key, obj);
              }
            }
          } else if (isArray(obj) || isArrayLike(obj)) {
            var isPrimitive = typeof obj !== 'object';
            for (key = 0, length = obj.length; key < length; key++) {
              if (isPrimitive || key in obj) {
                iterator.call(context, obj[key], key, obj);
              }
            }
          } else if (obj.forEach && obj.forEach !== forEach) {
            obj.forEach(iterator, context, obj);
          } else if (isBlankObject(obj)) {
            for (key in obj) {
              iterator.call(context, obj[key], key, obj);
            }
          } else if (typeof obj.hasOwnProperty === 'function') {
            for (key in obj) {
              if (obj.hasOwnProperty(key)) {
                iterator.call(context, obj[key], key, obj);
              }
            }
          } else {
            for (key in obj) {
              if (hasOwnProperty.call(obj, key)) {
                iterator.call(context, obj[key], key, obj);
              }
            }
          }
        }
        return obj;
      }
      function forEachSorted(obj, iterator, context) {
        var keys = Object.keys(obj).sort();
        for (var i = 0; i < keys.length; i++) {
          iterator.call(context, obj[keys[i]], keys[i]);
        }
        return keys;
      }
      function reverseParams(iteratorFn) {
        return function(value, key) {
          iteratorFn(key, value);
        };
      }
      function nextUid() {
        return ++uid;
      }
      function setHashKey(obj, h) {
        if (h) {
          obj.$$hashKey = h;
        } else {
          delete obj.$$hashKey;
        }
      }
      function baseExtend(dst, objs, deep) {
        var h = dst.$$hashKey;
        for (var i = 0,
            ii = objs.length; i < ii; ++i) {
          var obj = objs[i];
          if (!isObject(obj) && !isFunction(obj))
            continue;
          var keys = Object.keys(obj);
          for (var j = 0,
              jj = keys.length; j < jj; j++) {
            var key = keys[j];
            var src = obj[key];
            if (deep && isObject(src)) {
              if (isDate(src)) {
                dst[key] = new Date(src.valueOf());
              } else if (isRegExp(src)) {
                dst[key] = new RegExp(src);
              } else if (src.nodeName) {
                dst[key] = src.cloneNode(true);
              } else if (isElement(src)) {
                dst[key] = src.clone();
              } else {
                if (!isObject(dst[key]))
                  dst[key] = isArray(src) ? [] : {};
                baseExtend(dst[key], [src], true);
              }
            } else {
              dst[key] = src;
            }
          }
        }
        setHashKey(dst, h);
        return dst;
      }
      function extend(dst) {
        return baseExtend(dst, slice.call(arguments, 1), false);
      }
      function merge(dst) {
        return baseExtend(dst, slice.call(arguments, 1), true);
      }
      function toInt(str) {
        return parseInt(str, 10);
      }
      function inherit(parent, extra) {
        return extend(Object.create(parent), extra);
      }
      function noop() {}
      noop.$inject = [];
      function identity($) {
        return $;
      }
      identity.$inject = [];
      function valueFn(value) {
        return function valueRef() {
          return value;
        };
      }
      function hasCustomToString(obj) {
        return isFunction(obj.toString) && obj.toString !== toString;
      }
      function isUndefined(value) {
        return typeof value === 'undefined';
      }
      function isDefined(value) {
        return typeof value !== 'undefined';
      }
      function isObject(value) {
        return value !== null && typeof value === 'object';
      }
      function isBlankObject(value) {
        return value !== null && typeof value === 'object' && !getPrototypeOf(value);
      }
      function isString(value) {
        return typeof value === 'string';
      }
      function isNumber(value) {
        return typeof value === 'number';
      }
      function isDate(value) {
        return toString.call(value) === '[object Date]';
      }
      var isArray = Array.isArray;
      function isFunction(value) {
        return typeof value === 'function';
      }
      function isRegExp(value) {
        return toString.call(value) === '[object RegExp]';
      }
      function isWindow(obj) {
        return obj && obj.window === obj;
      }
      function isScope(obj) {
        return obj && obj.$evalAsync && obj.$watch;
      }
      function isFile(obj) {
        return toString.call(obj) === '[object File]';
      }
      function isFormData(obj) {
        return toString.call(obj) === '[object FormData]';
      }
      function isBlob(obj) {
        return toString.call(obj) === '[object Blob]';
      }
      function isBoolean(value) {
        return typeof value === 'boolean';
      }
      function isPromiseLike(obj) {
        return obj && isFunction(obj.then);
      }
      var TYPED_ARRAY_REGEXP = /^\[object (?:Uint8|Uint8Clamped|Uint16|Uint32|Int8|Int16|Int32|Float32|Float64)Array\]$/;
      function isTypedArray(value) {
        return value && isNumber(value.length) && TYPED_ARRAY_REGEXP.test(toString.call(value));
      }
      function isArrayBuffer(obj) {
        return toString.call(obj) === '[object ArrayBuffer]';
      }
      var trim = function(value) {
        return isString(value) ? value.trim() : value;
      };
      var escapeForRegexp = function(s) {
        return s.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1').replace(/\x08/g, '\\x08');
      };
      function isElement(node) {
        return !!(node && (node.nodeName || (node.prop && node.attr && node.find)));
      }
      function makeMap(str) {
        var obj = {},
            items = str.split(','),
            i;
        for (i = 0; i < items.length; i++) {
          obj[items[i]] = true;
        }
        return obj;
      }
      function nodeName_(element) {
        return lowercase(element.nodeName || (element[0] && element[0].nodeName));
      }
      function includes(array, obj) {
        return Array.prototype.indexOf.call(array, obj) != -1;
      }
      function arrayRemove(array, value) {
        var index = array.indexOf(value);
        if (index >= 0) {
          array.splice(index, 1);
        }
        return index;
      }
      function copy(source, destination) {
        var stackSource = [];
        var stackDest = [];
        if (destination) {
          if (isTypedArray(destination) || isArrayBuffer(destination)) {
            throw ngMinErr('cpta', "Can't copy! TypedArray destination cannot be mutated.");
          }
          if (source === destination) {
            throw ngMinErr('cpi', "Can't copy! Source and destination are identical.");
          }
          if (isArray(destination)) {
            destination.length = 0;
          } else {
            forEach(destination, function(value, key) {
              if (key !== '$$hashKey') {
                delete destination[key];
              }
            });
          }
          stackSource.push(source);
          stackDest.push(destination);
          return copyRecurse(source, destination);
        }
        return copyElement(source);
        function copyRecurse(source, destination) {
          var h = destination.$$hashKey;
          var key;
          if (isArray(source)) {
            for (var i = 0,
                ii = source.length; i < ii; i++) {
              destination.push(copyElement(source[i]));
            }
          } else if (isBlankObject(source)) {
            for (key in source) {
              destination[key] = copyElement(source[key]);
            }
          } else if (source && typeof source.hasOwnProperty === 'function') {
            for (key in source) {
              if (source.hasOwnProperty(key)) {
                destination[key] = copyElement(source[key]);
              }
            }
          } else {
            for (key in source) {
              if (hasOwnProperty.call(source, key)) {
                destination[key] = copyElement(source[key]);
              }
            }
          }
          setHashKey(destination, h);
          return destination;
        }
        function copyElement(source) {
          if (!isObject(source)) {
            return source;
          }
          var index = stackSource.indexOf(source);
          if (index !== -1) {
            return stackDest[index];
          }
          if (isWindow(source) || isScope(source)) {
            throw ngMinErr('cpws', "Can't copy! Making copies of Window or Scope instances is not supported.");
          }
          var needsRecurse = false;
          var destination = copyType(source);
          if (destination === undefined) {
            destination = isArray(source) ? [] : Object.create(getPrototypeOf(source));
            needsRecurse = true;
          }
          stackSource.push(source);
          stackDest.push(destination);
          return needsRecurse ? copyRecurse(source, destination) : destination;
        }
        function copyType(source) {
          switch (toString.call(source)) {
            case '[object Int8Array]':
            case '[object Int16Array]':
            case '[object Int32Array]':
            case '[object Float32Array]':
            case '[object Float64Array]':
            case '[object Uint8Array]':
            case '[object Uint8ClampedArray]':
            case '[object Uint16Array]':
            case '[object Uint32Array]':
              return new source.constructor(copyElement(source.buffer));
            case '[object ArrayBuffer]':
              if (!source.slice) {
                var copied = new ArrayBuffer(source.byteLength);
                new Uint8Array(copied).set(new Uint8Array(source));
                return copied;
              }
              return source.slice(0);
            case '[object Boolean]':
            case '[object Number]':
            case '[object String]':
            case '[object Date]':
              return new source.constructor(source.valueOf());
            case '[object RegExp]':
              var re = new RegExp(source.source, source.toString().match(/[^\/]*$/)[0]);
              re.lastIndex = source.lastIndex;
              return re;
            case '[object Blob]':
              return new source.constructor([source], {type: source.type});
          }
          if (isFunction(source.cloneNode)) {
            return source.cloneNode(true);
          }
        }
      }
      function equals(o1, o2) {
        if (o1 === o2)
          return true;
        if (o1 === null || o2 === null)
          return false;
        if (o1 !== o1 && o2 !== o2)
          return true;
        var t1 = typeof o1,
            t2 = typeof o2,
            length,
            key,
            keySet;
        if (t1 == t2 && t1 == 'object') {
          if (isArray(o1)) {
            if (!isArray(o2))
              return false;
            if ((length = o1.length) == o2.length) {
              for (key = 0; key < length; key++) {
                if (!equals(o1[key], o2[key]))
                  return false;
              }
              return true;
            }
          } else if (isDate(o1)) {
            if (!isDate(o2))
              return false;
            return equals(o1.getTime(), o2.getTime());
          } else if (isRegExp(o1)) {
            if (!isRegExp(o2))
              return false;
            return o1.toString() == o2.toString();
          } else {
            if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) || isArray(o2) || isDate(o2) || isRegExp(o2))
              return false;
            keySet = createMap();
            for (key in o1) {
              if (key.charAt(0) === '$' || isFunction(o1[key]))
                continue;
              if (!equals(o1[key], o2[key]))
                return false;
              keySet[key] = true;
            }
            for (key in o2) {
              if (!(key in keySet) && key.charAt(0) !== '$' && isDefined(o2[key]) && !isFunction(o2[key]))
                return false;
            }
            return true;
          }
        }
        return false;
      }
      var csp = function() {
        if (!isDefined(csp.rules)) {
          var ngCspElement = (window.document.querySelector('[ng-csp]') || window.document.querySelector('[data-ng-csp]'));
          if (ngCspElement) {
            var ngCspAttribute = ngCspElement.getAttribute('ng-csp') || ngCspElement.getAttribute('data-ng-csp');
            csp.rules = {
              noUnsafeEval: !ngCspAttribute || (ngCspAttribute.indexOf('no-unsafe-eval') !== -1),
              noInlineStyle: !ngCspAttribute || (ngCspAttribute.indexOf('no-inline-style') !== -1)
            };
          } else {
            csp.rules = {
              noUnsafeEval: noUnsafeEval(),
              noInlineStyle: false
            };
          }
        }
        return csp.rules;
        function noUnsafeEval() {
          try {
            new Function('');
            return false;
          } catch (e) {
            return true;
          }
        }
      };
      var jq = function() {
        if (isDefined(jq.name_))
          return jq.name_;
        var el;
        var i,
            ii = ngAttrPrefixes.length,
            prefix,
            name;
        for (i = 0; i < ii; ++i) {
          prefix = ngAttrPrefixes[i];
          if (el = window.document.querySelector('[' + prefix.replace(':', '\\:') + 'jq]')) {
            name = el.getAttribute(prefix + 'jq');
            break;
          }
        }
        return (jq.name_ = name);
      };
      function concat(array1, array2, index) {
        return array1.concat(slice.call(array2, index));
      }
      function sliceArgs(args, startIndex) {
        return slice.call(args, startIndex || 0);
      }
      function bind(self, fn) {
        var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
        if (isFunction(fn) && !(fn instanceof RegExp)) {
          return curryArgs.length ? function() {
            return arguments.length ? fn.apply(self, concat(curryArgs, arguments, 0)) : fn.apply(self, curryArgs);
          } : function() {
            return arguments.length ? fn.apply(self, arguments) : fn.call(self);
          };
        } else {
          return fn;
        }
      }
      function toJsonReplacer(key, value) {
        var val = value;
        if (typeof key === 'string' && key.charAt(0) === '$' && key.charAt(1) === '$') {
          val = undefined;
        } else if (isWindow(value)) {
          val = '$WINDOW';
        } else if (value && window.document === value) {
          val = '$DOCUMENT';
        } else if (isScope(value)) {
          val = '$SCOPE';
        }
        return val;
      }
      function toJson(obj, pretty) {
        if (isUndefined(obj))
          return undefined;
        if (!isNumber(pretty)) {
          pretty = pretty ? 2 : null;
        }
        return JSON.stringify(obj, toJsonReplacer, pretty);
      }
      function fromJson(json) {
        return isString(json) ? JSON.parse(json) : json;
      }
      var ALL_COLONS = /:/g;
      function timezoneToOffset(timezone, fallback) {
        timezone = timezone.replace(ALL_COLONS, '');
        var requestedTimezoneOffset = Date.parse('Jan 01, 1970 00:00:00 ' + timezone) / 60000;
        return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
      }
      function addDateMinutes(date, minutes) {
        date = new Date(date.getTime());
        date.setMinutes(date.getMinutes() + minutes);
        return date;
      }
      function convertTimezoneToLocal(date, timezone, reverse) {
        reverse = reverse ? -1 : 1;
        var dateTimezoneOffset = date.getTimezoneOffset();
        var timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
        return addDateMinutes(date, reverse * (timezoneOffset - dateTimezoneOffset));
      }
      function startingTag(element) {
        element = jqLite(element).clone();
        try {
          element.empty();
        } catch (e) {}
        var elemHtml = jqLite('<div>').append(element).html();
        try {
          return element[0].nodeType === NODE_TYPE_TEXT ? lowercase(elemHtml) : elemHtml.match(/^(<[^>]+>)/)[1].replace(/^<([\w\-]+)/, function(match, nodeName) {
            return '<' + lowercase(nodeName);
          });
        } catch (e) {
          return lowercase(elemHtml);
        }
      }
      function tryDecodeURIComponent(value) {
        try {
          return decodeURIComponent(value);
        } catch (e) {}
      }
      function parseKeyValue(keyValue) {
        var obj = {};
        forEach((keyValue || "").split('&'), function(keyValue) {
          var splitPoint,
              key,
              val;
          if (keyValue) {
            key = keyValue = keyValue.replace(/\+/g, '%20');
            splitPoint = keyValue.indexOf('=');
            if (splitPoint !== -1) {
              key = keyValue.substring(0, splitPoint);
              val = keyValue.substring(splitPoint + 1);
            }
            key = tryDecodeURIComponent(key);
            if (isDefined(key)) {
              val = isDefined(val) ? tryDecodeURIComponent(val) : true;
              if (!hasOwnProperty.call(obj, key)) {
                obj[key] = val;
              } else if (isArray(obj[key])) {
                obj[key].push(val);
              } else {
                obj[key] = [obj[key], val];
              }
            }
          }
        });
        return obj;
      }
      function toKeyValue(obj) {
        var parts = [];
        forEach(obj, function(value, key) {
          if (isArray(value)) {
            forEach(value, function(arrayValue) {
              parts.push(encodeUriQuery(key, true) + (arrayValue === true ? '' : '=' + encodeUriQuery(arrayValue, true)));
            });
          } else {
            parts.push(encodeUriQuery(key, true) + (value === true ? '' : '=' + encodeUriQuery(value, true)));
          }
        });
        return parts.length ? parts.join('&') : '';
      }
      function encodeUriSegment(val) {
        return encodeUriQuery(val, true).replace(/%26/gi, '&').replace(/%3D/gi, '=').replace(/%2B/gi, '+');
      }
      function encodeUriQuery(val, pctEncodeSpaces) {
        return encodeURIComponent(val).replace(/%40/gi, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%3B/gi, ';').replace(/%20/g, (pctEncodeSpaces ? '%20' : '+'));
      }
      var ngAttrPrefixes = ['ng-', 'data-ng-', 'ng:', 'x-ng-'];
      function getNgAttribute(element, ngAttr) {
        var attr,
            i,
            ii = ngAttrPrefixes.length;
        for (i = 0; i < ii; ++i) {
          attr = ngAttrPrefixes[i] + ngAttr;
          if (isString(attr = element.getAttribute(attr))) {
            return attr;
          }
        }
        return null;
      }
      function angularInit(element, bootstrap) {
        var appElement,
            module,
            config = {};
        forEach(ngAttrPrefixes, function(prefix) {
          var name = prefix + 'app';
          if (!appElement && element.hasAttribute && element.hasAttribute(name)) {
            appElement = element;
            module = element.getAttribute(name);
          }
        });
        forEach(ngAttrPrefixes, function(prefix) {
          var name = prefix + 'app';
          var candidate;
          if (!appElement && (candidate = element.querySelector('[' + name.replace(':', '\\:') + ']'))) {
            appElement = candidate;
            module = candidate.getAttribute(name);
          }
        });
        if (appElement) {
          config.strictDi = getNgAttribute(appElement, "strict-di") !== null;
          bootstrap(appElement, module ? [module] : [], config);
        }
      }
      function bootstrap(element, modules, config) {
        if (!isObject(config))
          config = {};
        var defaultConfig = {strictDi: false};
        config = extend(defaultConfig, config);
        var doBootstrap = function() {
          element = jqLite(element);
          if (element.injector()) {
            var tag = (element[0] === window.document) ? 'document' : startingTag(element);
            throw ngMinErr('btstrpd', "App already bootstrapped with this element '{0}'", tag.replace(/</, '&lt;').replace(/>/, '&gt;'));
          }
          modules = modules || [];
          modules.unshift(['$provide', function($provide) {
            $provide.value('$rootElement', element);
          }]);
          if (config.debugInfoEnabled) {
            modules.push(['$compileProvider', function($compileProvider) {
              $compileProvider.debugInfoEnabled(true);
            }]);
          }
          modules.unshift('ng');
          var injector = createInjector(modules, config.strictDi);
          injector.invoke(['$rootScope', '$rootElement', '$compile', '$injector', function bootstrapApply(scope, element, compile, injector) {
            scope.$apply(function() {
              element.data('$injector', injector);
              compile(element)(scope);
            });
          }]);
          return injector;
        };
        var NG_ENABLE_DEBUG_INFO = /^NG_ENABLE_DEBUG_INFO!/;
        var NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;
        if (window && NG_ENABLE_DEBUG_INFO.test(window.name)) {
          config.debugInfoEnabled = true;
          window.name = window.name.replace(NG_ENABLE_DEBUG_INFO, '');
        }
        if (window && !NG_DEFER_BOOTSTRAP.test(window.name)) {
          return doBootstrap();
        }
        window.name = window.name.replace(NG_DEFER_BOOTSTRAP, '');
        angular.resumeBootstrap = function(extraModules) {
          forEach(extraModules, function(module) {
            modules.push(module);
          });
          return doBootstrap();
        };
        if (isFunction(angular.resumeDeferredBootstrap)) {
          angular.resumeDeferredBootstrap();
        }
      }
      function reloadWithDebugInfo() {
        window.name = 'NG_ENABLE_DEBUG_INFO!' + window.name;
        window.location.reload();
      }
      function getTestability(rootElement) {
        var injector = angular.element(rootElement).injector();
        if (!injector) {
          throw ngMinErr('test', 'no injector found for element argument to getTestability');
        }
        return injector.get('$$testability');
      }
      var SNAKE_CASE_REGEXP = /[A-Z]/g;
      function snake_case(name, separator) {
        separator = separator || '_';
        return name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {
          return (pos ? separator : '') + letter.toLowerCase();
        });
      }
      var bindJQueryFired = false;
      function bindJQuery() {
        var originalCleanData;
        if (bindJQueryFired) {
          return;
        }
        var jqName = jq();
        jQuery = isUndefined(jqName) ? window.jQuery : !jqName ? undefined : window[jqName];
        if (jQuery && jQuery.fn.on) {
          jqLite = jQuery;
          extend(jQuery.fn, {
            scope: JQLitePrototype.scope,
            isolateScope: JQLitePrototype.isolateScope,
            controller: JQLitePrototype.controller,
            injector: JQLitePrototype.injector,
            inheritedData: JQLitePrototype.inheritedData
          });
          originalCleanData = jQuery.cleanData;
          jQuery.cleanData = function(elems) {
            var events;
            for (var i = 0,
                elem; (elem = elems[i]) != null; i++) {
              events = jQuery._data(elem, "events");
              if (events && events.$destroy) {
                jQuery(elem).triggerHandler('$destroy');
              }
            }
            originalCleanData(elems);
          };
        } else {
          jqLite = JQLite;
        }
        angular.element = jqLite;
        bindJQueryFired = true;
      }
      function assertArg(arg, name, reason) {
        if (!arg) {
          throw ngMinErr('areq', "Argument '{0}' is {1}", (name || '?'), (reason || "required"));
        }
        return arg;
      }
      function assertArgFn(arg, name, acceptArrayAnnotation) {
        if (acceptArrayAnnotation && isArray(arg)) {
          arg = arg[arg.length - 1];
        }
        assertArg(isFunction(arg), name, 'not a function, got ' + (arg && typeof arg === 'object' ? arg.constructor.name || 'Object' : typeof arg));
        return arg;
      }
      function assertNotHasOwnProperty(name, context) {
        if (name === 'hasOwnProperty') {
          throw ngMinErr('badname', "hasOwnProperty is not a valid {0} name", context);
        }
      }
      function getter(obj, path, bindFnToScope) {
        if (!path)
          return obj;
        var keys = path.split('.');
        var key;
        var lastInstance = obj;
        var len = keys.length;
        for (var i = 0; i < len; i++) {
          key = keys[i];
          if (obj) {
            obj = (lastInstance = obj)[key];
          }
        }
        if (!bindFnToScope && isFunction(obj)) {
          return bind(lastInstance, obj);
        }
        return obj;
      }
      function getBlockNodes(nodes) {
        var node = nodes[0];
        var endNode = nodes[nodes.length - 1];
        var blockNodes;
        for (var i = 1; node !== endNode && (node = node.nextSibling); i++) {
          if (blockNodes || nodes[i] !== node) {
            if (!blockNodes) {
              blockNodes = jqLite(slice.call(nodes, 0, i));
            }
            blockNodes.push(node);
          }
        }
        return blockNodes || nodes;
      }
      function createMap() {
        return Object.create(null);
      }
      var NODE_TYPE_ELEMENT = 1;
      var NODE_TYPE_ATTRIBUTE = 2;
      var NODE_TYPE_TEXT = 3;
      var NODE_TYPE_COMMENT = 8;
      var NODE_TYPE_DOCUMENT = 9;
      var NODE_TYPE_DOCUMENT_FRAGMENT = 11;
      function setupModuleLoader(window) {
        var $injectorMinErr = minErr('$injector');
        var ngMinErr = minErr('ng');
        function ensure(obj, name, factory) {
          return obj[name] || (obj[name] = factory());
        }
        var angular = ensure(window, 'angular', Object);
        angular.$$minErr = angular.$$minErr || minErr;
        return ensure(angular, 'module', function() {
          var modules = {};
          return function module(name, requires, configFn) {
            var assertNotHasOwnProperty = function(name, context) {
              if (name === 'hasOwnProperty') {
                throw ngMinErr('badname', 'hasOwnProperty is not a valid {0} name', context);
              }
            };
            assertNotHasOwnProperty(name, 'module');
            if (requires && modules.hasOwnProperty(name)) {
              modules[name] = null;
            }
            return ensure(modules, name, function() {
              if (!requires) {
                throw $injectorMinErr('nomod', "Module '{0}' is not available! You either misspelled " + "the module name or forgot to load it. If registering a module ensure that you " + "specify the dependencies as the second argument.", name);
              }
              var invokeQueue = [];
              var configBlocks = [];
              var runBlocks = [];
              var config = invokeLater('$injector', 'invoke', 'push', configBlocks);
              var moduleInstance = {
                _invokeQueue: invokeQueue,
                _configBlocks: configBlocks,
                _runBlocks: runBlocks,
                requires: requires,
                name: name,
                provider: invokeLaterAndSetModuleName('$provide', 'provider'),
                factory: invokeLaterAndSetModuleName('$provide', 'factory'),
                service: invokeLaterAndSetModuleName('$provide', 'service'),
                value: invokeLater('$provide', 'value'),
                constant: invokeLater('$provide', 'constant', 'unshift'),
                decorator: invokeLaterAndSetModuleName('$provide', 'decorator'),
                animation: invokeLaterAndSetModuleName('$animateProvider', 'register'),
                filter: invokeLaterAndSetModuleName('$filterProvider', 'register'),
                controller: invokeLaterAndSetModuleName('$controllerProvider', 'register'),
                directive: invokeLaterAndSetModuleName('$compileProvider', 'directive'),
                component: invokeLaterAndSetModuleName('$compileProvider', 'component'),
                config: config,
                run: function(block) {
                  runBlocks.push(block);
                  return this;
                }
              };
              if (configFn) {
                config(configFn);
              }
              return moduleInstance;
              function invokeLater(provider, method, insertMethod, queue) {
                if (!queue)
                  queue = invokeQueue;
                return function() {
                  queue[insertMethod || 'push']([provider, method, arguments]);
                  return moduleInstance;
                };
              }
              function invokeLaterAndSetModuleName(provider, method) {
                return function(recipeName, factoryFunction) {
                  if (factoryFunction && isFunction(factoryFunction))
                    factoryFunction.$$moduleName = name;
                  invokeQueue.push([provider, method, arguments]);
                  return moduleInstance;
                };
              }
            });
          };
        });
      }
      function shallowCopy(src, dst) {
        if (isArray(src)) {
          dst = dst || [];
          for (var i = 0,
              ii = src.length; i < ii; i++) {
            dst[i] = src[i];
          }
        } else if (isObject(src)) {
          dst = dst || {};
          for (var key in src) {
            if (!(key.charAt(0) === '$' && key.charAt(1) === '$')) {
              dst[key] = src[key];
            }
          }
        }
        return dst || src;
      }
      function serializeObject(obj) {
        var seen = [];
        return JSON.stringify(obj, function(key, val) {
          val = toJsonReplacer(key, val);
          if (isObject(val)) {
            if (seen.indexOf(val) >= 0)
              return '...';
            seen.push(val);
          }
          return val;
        });
      }
      function toDebugString(obj) {
        if (typeof obj === 'function') {
          return obj.toString().replace(/ \{[\s\S]*$/, '');
        } else if (isUndefined(obj)) {
          return 'undefined';
        } else if (typeof obj !== 'string') {
          return serializeObject(obj);
        }
        return obj;
      }
      var version = {
        full: '1.5.7',
        major: 1,
        minor: 5,
        dot: 7,
        codeName: 'hexagonal-circumvolution'
      };
      function publishExternalAPI(angular) {
        extend(angular, {
          'bootstrap': bootstrap,
          'copy': copy,
          'extend': extend,
          'merge': merge,
          'equals': equals,
          'element': jqLite,
          'forEach': forEach,
          'injector': createInjector,
          'noop': noop,
          'bind': bind,
          'toJson': toJson,
          'fromJson': fromJson,
          'identity': identity,
          'isUndefined': isUndefined,
          'isDefined': isDefined,
          'isString': isString,
          'isFunction': isFunction,
          'isObject': isObject,
          'isNumber': isNumber,
          'isElement': isElement,
          'isArray': isArray,
          'version': version,
          'isDate': isDate,
          'lowercase': lowercase,
          'uppercase': uppercase,
          'callbacks': {counter: 0},
          'getTestability': getTestability,
          '$$minErr': minErr,
          '$$csp': csp,
          'reloadWithDebugInfo': reloadWithDebugInfo
        });
        angularModule = setupModuleLoader(window);
        angularModule('ng', ['ngLocale'], ['$provide', function ngModule($provide) {
          $provide.provider({$$sanitizeUri: $$SanitizeUriProvider});
          $provide.provider('$compile', $CompileProvider).directive({
            a: htmlAnchorDirective,
            input: inputDirective,
            textarea: inputDirective,
            form: formDirective,
            script: scriptDirective,
            select: selectDirective,
            style: styleDirective,
            option: optionDirective,
            ngBind: ngBindDirective,
            ngBindHtml: ngBindHtmlDirective,
            ngBindTemplate: ngBindTemplateDirective,
            ngClass: ngClassDirective,
            ngClassEven: ngClassEvenDirective,
            ngClassOdd: ngClassOddDirective,
            ngCloak: ngCloakDirective,
            ngController: ngControllerDirective,
            ngForm: ngFormDirective,
            ngHide: ngHideDirective,
            ngIf: ngIfDirective,
            ngInclude: ngIncludeDirective,
            ngInit: ngInitDirective,
            ngNonBindable: ngNonBindableDirective,
            ngPluralize: ngPluralizeDirective,
            ngRepeat: ngRepeatDirective,
            ngShow: ngShowDirective,
            ngStyle: ngStyleDirective,
            ngSwitch: ngSwitchDirective,
            ngSwitchWhen: ngSwitchWhenDirective,
            ngSwitchDefault: ngSwitchDefaultDirective,
            ngOptions: ngOptionsDirective,
            ngTransclude: ngTranscludeDirective,
            ngModel: ngModelDirective,
            ngList: ngListDirective,
            ngChange: ngChangeDirective,
            pattern: patternDirective,
            ngPattern: patternDirective,
            required: requiredDirective,
            ngRequired: requiredDirective,
            minlength: minlengthDirective,
            ngMinlength: minlengthDirective,
            maxlength: maxlengthDirective,
            ngMaxlength: maxlengthDirective,
            ngValue: ngValueDirective,
            ngModelOptions: ngModelOptionsDirective
          }).directive({ngInclude: ngIncludeFillContentDirective}).directive(ngAttributeAliasDirectives).directive(ngEventDirectives);
          $provide.provider({
            $anchorScroll: $AnchorScrollProvider,
            $animate: $AnimateProvider,
            $animateCss: $CoreAnimateCssProvider,
            $$animateJs: $$CoreAnimateJsProvider,
            $$animateQueue: $$CoreAnimateQueueProvider,
            $$AnimateRunner: $$AnimateRunnerFactoryProvider,
            $$animateAsyncRun: $$AnimateAsyncRunFactoryProvider,
            $browser: $BrowserProvider,
            $cacheFactory: $CacheFactoryProvider,
            $controller: $ControllerProvider,
            $document: $DocumentProvider,
            $exceptionHandler: $ExceptionHandlerProvider,
            $filter: $FilterProvider,
            $$forceReflow: $$ForceReflowProvider,
            $interpolate: $InterpolateProvider,
            $interval: $IntervalProvider,
            $http: $HttpProvider,
            $httpParamSerializer: $HttpParamSerializerProvider,
            $httpParamSerializerJQLike: $HttpParamSerializerJQLikeProvider,
            $httpBackend: $HttpBackendProvider,
            $xhrFactory: $xhrFactoryProvider,
            $location: $LocationProvider,
            $log: $LogProvider,
            $parse: $ParseProvider,
            $rootScope: $RootScopeProvider,
            $q: $QProvider,
            $$q: $$QProvider,
            $sce: $SceProvider,
            $sceDelegate: $SceDelegateProvider,
            $sniffer: $SnifferProvider,
            $templateCache: $TemplateCacheProvider,
            $templateRequest: $TemplateRequestProvider,
            $$testability: $$TestabilityProvider,
            $timeout: $TimeoutProvider,
            $window: $WindowProvider,
            $$rAF: $$RAFProvider,
            $$jqLite: $$jqLiteProvider,
            $$HashMap: $$HashMapProvider,
            $$cookieReader: $$CookieReaderProvider
          });
        }]);
      }
      JQLite.expando = 'ng339';
      var jqCache = JQLite.cache = {},
          jqId = 1,
          addEventListenerFn = function(element, type, fn) {
            element.addEventListener(type, fn, false);
          },
          removeEventListenerFn = function(element, type, fn) {
            element.removeEventListener(type, fn, false);
          };
      JQLite._data = function(node) {
        return this.cache[node[this.expando]] || {};
      };
      function jqNextId() {
        return ++jqId;
      }
      var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
      var MOZ_HACK_REGEXP = /^moz([A-Z])/;
      var MOUSE_EVENT_MAP = {
        mouseleave: "mouseout",
        mouseenter: "mouseover"
      };
      var jqLiteMinErr = minErr('jqLite');
      function camelCase(name) {
        return name.replace(SPECIAL_CHARS_REGEXP, function(_, separator, letter, offset) {
          return offset ? letter.toUpperCase() : letter;
        }).replace(MOZ_HACK_REGEXP, 'Moz$1');
      }
      var SINGLE_TAG_REGEXP = /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/;
      var HTML_REGEXP = /<|&#?\w+;/;
      var TAG_NAME_REGEXP = /<([\w:-]+)/;
      var XHTML_TAG_REGEXP = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi;
      var wrapMap = {
        'option': [1, '<select multiple="multiple">', '</select>'],
        'thead': [1, '<table>', '</table>'],
        'col': [2, '<table><colgroup>', '</colgroup></table>'],
        'tr': [2, '<table><tbody>', '</tbody></table>'],
        'td': [3, '<table><tbody><tr>', '</tr></tbody></table>'],
        '_default': [0, "", ""]
      };
      wrapMap.optgroup = wrapMap.option;
      wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
      wrapMap.th = wrapMap.td;
      function jqLiteIsTextNode(html) {
        return !HTML_REGEXP.test(html);
      }
      function jqLiteAcceptsData(node) {
        var nodeType = node.nodeType;
        return nodeType === NODE_TYPE_ELEMENT || !nodeType || nodeType === NODE_TYPE_DOCUMENT;
      }
      function jqLiteHasData(node) {
        for (var key in jqCache[node.ng339]) {
          return true;
        }
        return false;
      }
      function jqLiteCleanData(nodes) {
        for (var i = 0,
            ii = nodes.length; i < ii; i++) {
          jqLiteRemoveData(nodes[i]);
        }
      }
      function jqLiteBuildFragment(html, context) {
        var tmp,
            tag,
            wrap,
            fragment = context.createDocumentFragment(),
            nodes = [],
            i;
        if (jqLiteIsTextNode(html)) {
          nodes.push(context.createTextNode(html));
        } else {
          tmp = tmp || fragment.appendChild(context.createElement("div"));
          tag = (TAG_NAME_REGEXP.exec(html) || ["", ""])[1].toLowerCase();
          wrap = wrapMap[tag] || wrapMap._default;
          tmp.innerHTML = wrap[1] + html.replace(XHTML_TAG_REGEXP, "<$1></$2>") + wrap[2];
          i = wrap[0];
          while (i--) {
            tmp = tmp.lastChild;
          }
          nodes = concat(nodes, tmp.childNodes);
          tmp = fragment.firstChild;
          tmp.textContent = "";
        }
        fragment.textContent = "";
        fragment.innerHTML = "";
        forEach(nodes, function(node) {
          fragment.appendChild(node);
        });
        return fragment;
      }
      function jqLiteParseHTML(html, context) {
        context = context || window.document;
        var parsed;
        if ((parsed = SINGLE_TAG_REGEXP.exec(html))) {
          return [context.createElement(parsed[1])];
        }
        if ((parsed = jqLiteBuildFragment(html, context))) {
          return parsed.childNodes;
        }
        return [];
      }
      function jqLiteWrapNode(node, wrapper) {
        var parent = node.parentNode;
        if (parent) {
          parent.replaceChild(wrapper, node);
        }
        wrapper.appendChild(node);
      }
      var jqLiteContains = window.Node.prototype.contains || function(arg) {
        return !!(this.compareDocumentPosition(arg) & 16);
      };
      function JQLite(element) {
        if (element instanceof JQLite) {
          return element;
        }
        var argIsString;
        if (isString(element)) {
          element = trim(element);
          argIsString = true;
        }
        if (!(this instanceof JQLite)) {
          if (argIsString && element.charAt(0) != '<') {
            throw jqLiteMinErr('nosel', 'Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element');
          }
          return new JQLite(element);
        }
        if (argIsString) {
          jqLiteAddNodes(this, jqLiteParseHTML(element));
        } else {
          jqLiteAddNodes(this, element);
        }
      }
      function jqLiteClone(element) {
        return element.cloneNode(true);
      }
      function jqLiteDealoc(element, onlyDescendants) {
        if (!onlyDescendants)
          jqLiteRemoveData(element);
        if (element.querySelectorAll) {
          var descendants = element.querySelectorAll('*');
          for (var i = 0,
              l = descendants.length; i < l; i++) {
            jqLiteRemoveData(descendants[i]);
          }
        }
      }
      function jqLiteOff(element, type, fn, unsupported) {
        if (isDefined(unsupported))
          throw jqLiteMinErr('offargs', 'jqLite#off() does not support the `selector` argument');
        var expandoStore = jqLiteExpandoStore(element);
        var events = expandoStore && expandoStore.events;
        var handle = expandoStore && expandoStore.handle;
        if (!handle)
          return;
        if (!type) {
          for (type in events) {
            if (type !== '$destroy') {
              removeEventListenerFn(element, type, handle);
            }
            delete events[type];
          }
        } else {
          var removeHandler = function(type) {
            var listenerFns = events[type];
            if (isDefined(fn)) {
              arrayRemove(listenerFns || [], fn);
            }
            if (!(isDefined(fn) && listenerFns && listenerFns.length > 0)) {
              removeEventListenerFn(element, type, handle);
              delete events[type];
            }
          };
          forEach(type.split(' '), function(type) {
            removeHandler(type);
            if (MOUSE_EVENT_MAP[type]) {
              removeHandler(MOUSE_EVENT_MAP[type]);
            }
          });
        }
      }
      function jqLiteRemoveData(element, name) {
        var expandoId = element.ng339;
        var expandoStore = expandoId && jqCache[expandoId];
        if (expandoStore) {
          if (name) {
            delete expandoStore.data[name];
            return;
          }
          if (expandoStore.handle) {
            if (expandoStore.events.$destroy) {
              expandoStore.handle({}, '$destroy');
            }
            jqLiteOff(element);
          }
          delete jqCache[expandoId];
          element.ng339 = undefined;
        }
      }
      function jqLiteExpandoStore(element, createIfNecessary) {
        var expandoId = element.ng339,
            expandoStore = expandoId && jqCache[expandoId];
        if (createIfNecessary && !expandoStore) {
          element.ng339 = expandoId = jqNextId();
          expandoStore = jqCache[expandoId] = {
            events: {},
            data: {},
            handle: undefined
          };
        }
        return expandoStore;
      }
      function jqLiteData(element, key, value) {
        if (jqLiteAcceptsData(element)) {
          var isSimpleSetter = isDefined(value);
          var isSimpleGetter = !isSimpleSetter && key && !isObject(key);
          var massGetter = !key;
          var expandoStore = jqLiteExpandoStore(element, !isSimpleGetter);
          var data = expandoStore && expandoStore.data;
          if (isSimpleSetter) {
            data[key] = value;
          } else {
            if (massGetter) {
              return data;
            } else {
              if (isSimpleGetter) {
                return data && data[key];
              } else {
                extend(data, key);
              }
            }
          }
        }
      }
      function jqLiteHasClass(element, selector) {
        if (!element.getAttribute)
          return false;
        return ((" " + (element.getAttribute('class') || '') + " ").replace(/[\n\t]/g, " ").indexOf(" " + selector + " ") > -1);
      }
      function jqLiteRemoveClass(element, cssClasses) {
        if (cssClasses && element.setAttribute) {
          forEach(cssClasses.split(' '), function(cssClass) {
            element.setAttribute('class', trim((" " + (element.getAttribute('class') || '') + " ").replace(/[\n\t]/g, " ").replace(" " + trim(cssClass) + " ", " ")));
          });
        }
      }
      function jqLiteAddClass(element, cssClasses) {
        if (cssClasses && element.setAttribute) {
          var existingClasses = (' ' + (element.getAttribute('class') || '') + ' ').replace(/[\n\t]/g, " ");
          forEach(cssClasses.split(' '), function(cssClass) {
            cssClass = trim(cssClass);
            if (existingClasses.indexOf(' ' + cssClass + ' ') === -1) {
              existingClasses += cssClass + ' ';
            }
          });
          element.setAttribute('class', trim(existingClasses));
        }
      }
      function jqLiteAddNodes(root, elements) {
        if (elements) {
          if (elements.nodeType) {
            root[root.length++] = elements;
          } else {
            var length = elements.length;
            if (typeof length === 'number' && elements.window !== elements) {
              if (length) {
                for (var i = 0; i < length; i++) {
                  root[root.length++] = elements[i];
                }
              }
            } else {
              root[root.length++] = elements;
            }
          }
        }
      }
      function jqLiteController(element, name) {
        return jqLiteInheritedData(element, '$' + (name || 'ngController') + 'Controller');
      }
      function jqLiteInheritedData(element, name, value) {
        if (element.nodeType == NODE_TYPE_DOCUMENT) {
          element = element.documentElement;
        }
        var names = isArray(name) ? name : [name];
        while (element) {
          for (var i = 0,
              ii = names.length; i < ii; i++) {
            if (isDefined(value = jqLite.data(element, names[i])))
              return value;
          }
          element = element.parentNode || (element.nodeType === NODE_TYPE_DOCUMENT_FRAGMENT && element.host);
        }
      }
      function jqLiteEmpty(element) {
        jqLiteDealoc(element, true);
        while (element.firstChild) {
          element.removeChild(element.firstChild);
        }
      }
      function jqLiteRemove(element, keepData) {
        if (!keepData)
          jqLiteDealoc(element);
        var parent = element.parentNode;
        if (parent)
          parent.removeChild(element);
      }
      function jqLiteDocumentLoaded(action, win) {
        win = win || window;
        if (win.document.readyState === 'complete') {
          win.setTimeout(action);
        } else {
          jqLite(win).on('load', action);
        }
      }
      var JQLitePrototype = JQLite.prototype = {
        ready: function(fn) {
          var fired = false;
          function trigger() {
            if (fired)
              return;
            fired = true;
            fn();
          }
          if (window.document.readyState === 'complete') {
            window.setTimeout(trigger);
          } else {
            this.on('DOMContentLoaded', trigger);
            JQLite(window).on('load', trigger);
          }
        },
        toString: function() {
          var value = [];
          forEach(this, function(e) {
            value.push('' + e);
          });
          return '[' + value.join(', ') + ']';
        },
        eq: function(index) {
          return (index >= 0) ? jqLite(this[index]) : jqLite(this[this.length + index]);
        },
        length: 0,
        push: push,
        sort: [].sort,
        splice: [].splice
      };
      var BOOLEAN_ATTR = {};
      forEach('multiple,selected,checked,disabled,readOnly,required,open'.split(','), function(value) {
        BOOLEAN_ATTR[lowercase(value)] = value;
      });
      var BOOLEAN_ELEMENTS = {};
      forEach('input,select,option,textarea,button,form,details'.split(','), function(value) {
        BOOLEAN_ELEMENTS[value] = true;
      });
      var ALIASED_ATTR = {
        'ngMinlength': 'minlength',
        'ngMaxlength': 'maxlength',
        'ngMin': 'min',
        'ngMax': 'max',
        'ngPattern': 'pattern'
      };
      function getBooleanAttrName(element, name) {
        var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];
        return booleanAttr && BOOLEAN_ELEMENTS[nodeName_(element)] && booleanAttr;
      }
      function getAliasedAttrName(name) {
        return ALIASED_ATTR[name];
      }
      forEach({
        data: jqLiteData,
        removeData: jqLiteRemoveData,
        hasData: jqLiteHasData,
        cleanData: jqLiteCleanData
      }, function(fn, name) {
        JQLite[name] = fn;
      });
      forEach({
        data: jqLiteData,
        inheritedData: jqLiteInheritedData,
        scope: function(element) {
          return jqLite.data(element, '$scope') || jqLiteInheritedData(element.parentNode || element, ['$isolateScope', '$scope']);
        },
        isolateScope: function(element) {
          return jqLite.data(element, '$isolateScope') || jqLite.data(element, '$isolateScopeNoTemplate');
        },
        controller: jqLiteController,
        injector: function(element) {
          return jqLiteInheritedData(element, '$injector');
        },
        removeAttr: function(element, name) {
          element.removeAttribute(name);
        },
        hasClass: jqLiteHasClass,
        css: function(element, name, value) {
          name = camelCase(name);
          if (isDefined(value)) {
            element.style[name] = value;
          } else {
            return element.style[name];
          }
        },
        attr: function(element, name, value) {
          var nodeType = element.nodeType;
          if (nodeType === NODE_TYPE_TEXT || nodeType === NODE_TYPE_ATTRIBUTE || nodeType === NODE_TYPE_COMMENT) {
            return;
          }
          var lowercasedName = lowercase(name);
          if (BOOLEAN_ATTR[lowercasedName]) {
            if (isDefined(value)) {
              if (!!value) {
                element[name] = true;
                element.setAttribute(name, lowercasedName);
              } else {
                element[name] = false;
                element.removeAttribute(lowercasedName);
              }
            } else {
              return (element[name] || (element.attributes.getNamedItem(name) || noop).specified) ? lowercasedName : undefined;
            }
          } else if (isDefined(value)) {
            element.setAttribute(name, value);
          } else if (element.getAttribute) {
            var ret = element.getAttribute(name, 2);
            return ret === null ? undefined : ret;
          }
        },
        prop: function(element, name, value) {
          if (isDefined(value)) {
            element[name] = value;
          } else {
            return element[name];
          }
        },
        text: (function() {
          getText.$dv = '';
          return getText;
          function getText(element, value) {
            if (isUndefined(value)) {
              var nodeType = element.nodeType;
              return (nodeType === NODE_TYPE_ELEMENT || nodeType === NODE_TYPE_TEXT) ? element.textContent : '';
            }
            element.textContent = value;
          }
        })(),
        val: function(element, value) {
          if (isUndefined(value)) {
            if (element.multiple && nodeName_(element) === 'select') {
              var result = [];
              forEach(element.options, function(option) {
                if (option.selected) {
                  result.push(option.value || option.text);
                }
              });
              return result.length === 0 ? null : result;
            }
            return element.value;
          }
          element.value = value;
        },
        html: function(element, value) {
          if (isUndefined(value)) {
            return element.innerHTML;
          }
          jqLiteDealoc(element, true);
          element.innerHTML = value;
        },
        empty: jqLiteEmpty
      }, function(fn, name) {
        JQLite.prototype[name] = function(arg1, arg2) {
          var i,
              key;
          var nodeCount = this.length;
          if (fn !== jqLiteEmpty && (isUndefined((fn.length == 2 && (fn !== jqLiteHasClass && fn !== jqLiteController)) ? arg1 : arg2))) {
            if (isObject(arg1)) {
              for (i = 0; i < nodeCount; i++) {
                if (fn === jqLiteData) {
                  fn(this[i], arg1);
                } else {
                  for (key in arg1) {
                    fn(this[i], key, arg1[key]);
                  }
                }
              }
              return this;
            } else {
              var value = fn.$dv;
              var jj = (isUndefined(value)) ? Math.min(nodeCount, 1) : nodeCount;
              for (var j = 0; j < jj; j++) {
                var nodeValue = fn(this[j], arg1, arg2);
                value = value ? value + nodeValue : nodeValue;
              }
              return value;
            }
          } else {
            for (i = 0; i < nodeCount; i++) {
              fn(this[i], arg1, arg2);
            }
            return this;
          }
        };
      });
      function createEventHandler(element, events) {
        var eventHandler = function(event, type) {
          event.isDefaultPrevented = function() {
            return event.defaultPrevented;
          };
          var eventFns = events[type || event.type];
          var eventFnsLength = eventFns ? eventFns.length : 0;
          if (!eventFnsLength)
            return;
          if (isUndefined(event.immediatePropagationStopped)) {
            var originalStopImmediatePropagation = event.stopImmediatePropagation;
            event.stopImmediatePropagation = function() {
              event.immediatePropagationStopped = true;
              if (event.stopPropagation) {
                event.stopPropagation();
              }
              if (originalStopImmediatePropagation) {
                originalStopImmediatePropagation.call(event);
              }
            };
          }
          event.isImmediatePropagationStopped = function() {
            return event.immediatePropagationStopped === true;
          };
          var handlerWrapper = eventFns.specialHandlerWrapper || defaultHandlerWrapper;
          if ((eventFnsLength > 1)) {
            eventFns = shallowCopy(eventFns);
          }
          for (var i = 0; i < eventFnsLength; i++) {
            if (!event.isImmediatePropagationStopped()) {
              handlerWrapper(element, event, eventFns[i]);
            }
          }
        };
        eventHandler.elem = element;
        return eventHandler;
      }
      function defaultHandlerWrapper(element, event, handler) {
        handler.call(element, event);
      }
      function specialMouseHandlerWrapper(target, event, handler) {
        var related = event.relatedTarget;
        if (!related || (related !== target && !jqLiteContains.call(target, related))) {
          handler.call(target, event);
        }
      }
      forEach({
        removeData: jqLiteRemoveData,
        on: function jqLiteOn(element, type, fn, unsupported) {
          if (isDefined(unsupported))
            throw jqLiteMinErr('onargs', 'jqLite#on() does not support the `selector` or `eventData` parameters');
          if (!jqLiteAcceptsData(element)) {
            return;
          }
          var expandoStore = jqLiteExpandoStore(element, true);
          var events = expandoStore.events;
          var handle = expandoStore.handle;
          if (!handle) {
            handle = expandoStore.handle = createEventHandler(element, events);
          }
          var types = type.indexOf(' ') >= 0 ? type.split(' ') : [type];
          var i = types.length;
          var addHandler = function(type, specialHandlerWrapper, noEventListener) {
            var eventFns = events[type];
            if (!eventFns) {
              eventFns = events[type] = [];
              eventFns.specialHandlerWrapper = specialHandlerWrapper;
              if (type !== '$destroy' && !noEventListener) {
                addEventListenerFn(element, type, handle);
              }
            }
            eventFns.push(fn);
          };
          while (i--) {
            type = types[i];
            if (MOUSE_EVENT_MAP[type]) {
              addHandler(MOUSE_EVENT_MAP[type], specialMouseHandlerWrapper);
              addHandler(type, undefined, true);
            } else {
              addHandler(type);
            }
          }
        },
        off: jqLiteOff,
        one: function(element, type, fn) {
          element = jqLite(element);
          element.on(type, function onFn() {
            element.off(type, fn);
            element.off(type, onFn);
          });
          element.on(type, fn);
        },
        replaceWith: function(element, replaceNode) {
          var index,
              parent = element.parentNode;
          jqLiteDealoc(element);
          forEach(new JQLite(replaceNode), function(node) {
            if (index) {
              parent.insertBefore(node, index.nextSibling);
            } else {
              parent.replaceChild(node, element);
            }
            index = node;
          });
        },
        children: function(element) {
          var children = [];
          forEach(element.childNodes, function(element) {
            if (element.nodeType === NODE_TYPE_ELEMENT) {
              children.push(element);
            }
          });
          return children;
        },
        contents: function(element) {
          return element.contentDocument || element.childNodes || [];
        },
        append: function(element, node) {
          var nodeType = element.nodeType;
          if (nodeType !== NODE_TYPE_ELEMENT && nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT)
            return;
          node = new JQLite(node);
          for (var i = 0,
              ii = node.length; i < ii; i++) {
            var child = node[i];
            element.appendChild(child);
          }
        },
        prepend: function(element, node) {
          if (element.nodeType === NODE_TYPE_ELEMENT) {
            var index = element.firstChild;
            forEach(new JQLite(node), function(child) {
              element.insertBefore(child, index);
            });
          }
        },
        wrap: function(element, wrapNode) {
          jqLiteWrapNode(element, jqLite(wrapNode).eq(0).clone()[0]);
        },
        remove: jqLiteRemove,
        detach: function(element) {
          jqLiteRemove(element, true);
        },
        after: function(element, newElement) {
          var index = element,
              parent = element.parentNode;
          newElement = new JQLite(newElement);
          for (var i = 0,
              ii = newElement.length; i < ii; i++) {
            var node = newElement[i];
            parent.insertBefore(node, index.nextSibling);
            index = node;
          }
        },
        addClass: jqLiteAddClass,
        removeClass: jqLiteRemoveClass,
        toggleClass: function(element, selector, condition) {
          if (selector) {
            forEach(selector.split(' '), function(className) {
              var classCondition = condition;
              if (isUndefined(classCondition)) {
                classCondition = !jqLiteHasClass(element, className);
              }
              (classCondition ? jqLiteAddClass : jqLiteRemoveClass)(element, className);
            });
          }
        },
        parent: function(element) {
          var parent = element.parentNode;
          return parent && parent.nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT ? parent : null;
        },
        next: function(element) {
          return element.nextElementSibling;
        },
        find: function(element, selector) {
          if (element.getElementsByTagName) {
            return element.getElementsByTagName(selector);
          } else {
            return [];
          }
        },
        clone: jqLiteClone,
        triggerHandler: function(element, event, extraParameters) {
          var dummyEvent,
              eventFnsCopy,
              handlerArgs;
          var eventName = event.type || event;
          var expandoStore = jqLiteExpandoStore(element);
          var events = expandoStore && expandoStore.events;
          var eventFns = events && events[eventName];
          if (eventFns) {
            dummyEvent = {
              preventDefault: function() {
                this.defaultPrevented = true;
              },
              isDefaultPrevented: function() {
                return this.defaultPrevented === true;
              },
              stopImmediatePropagation: function() {
                this.immediatePropagationStopped = true;
              },
              isImmediatePropagationStopped: function() {
                return this.immediatePropagationStopped === true;
              },
              stopPropagation: noop,
              type: eventName,
              target: element
            };
            if (event.type) {
              dummyEvent = extend(dummyEvent, event);
            }
            eventFnsCopy = shallowCopy(eventFns);
            handlerArgs = extraParameters ? [dummyEvent].concat(extraParameters) : [dummyEvent];
            forEach(eventFnsCopy, function(fn) {
              if (!dummyEvent.isImmediatePropagationStopped()) {
                fn.apply(element, handlerArgs);
              }
            });
          }
        }
      }, function(fn, name) {
        JQLite.prototype[name] = function(arg1, arg2, arg3) {
          var value;
          for (var i = 0,
              ii = this.length; i < ii; i++) {
            if (isUndefined(value)) {
              value = fn(this[i], arg1, arg2, arg3);
              if (isDefined(value)) {
                value = jqLite(value);
              }
            } else {
              jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
            }
          }
          return isDefined(value) ? value : this;
        };
        JQLite.prototype.bind = JQLite.prototype.on;
        JQLite.prototype.unbind = JQLite.prototype.off;
      });
      function $$jqLiteProvider() {
        this.$get = function $$jqLite() {
          return extend(JQLite, {
            hasClass: function(node, classes) {
              if (node.attr)
                node = node[0];
              return jqLiteHasClass(node, classes);
            },
            addClass: function(node, classes) {
              if (node.attr)
                node = node[0];
              return jqLiteAddClass(node, classes);
            },
            removeClass: function(node, classes) {
              if (node.attr)
                node = node[0];
              return jqLiteRemoveClass(node, classes);
            }
          });
        };
      }
      function hashKey(obj, nextUidFn) {
        var key = obj && obj.$$hashKey;
        if (key) {
          if (typeof key === 'function') {
            key = obj.$$hashKey();
          }
          return key;
        }
        var objType = typeof obj;
        if (objType == 'function' || (objType == 'object' && obj !== null)) {
          key = obj.$$hashKey = objType + ':' + (nextUidFn || nextUid)();
        } else {
          key = objType + ':' + obj;
        }
        return key;
      }
      function HashMap(array, isolatedUid) {
        if (isolatedUid) {
          var uid = 0;
          this.nextUid = function() {
            return ++uid;
          };
        }
        forEach(array, this.put, this);
      }
      HashMap.prototype = {
        put: function(key, value) {
          this[hashKey(key, this.nextUid)] = value;
        },
        get: function(key) {
          return this[hashKey(key, this.nextUid)];
        },
        remove: function(key) {
          var value = this[key = hashKey(key, this.nextUid)];
          delete this[key];
          return value;
        }
      };
      var $$HashMapProvider = [function() {
        this.$get = [function() {
          return HashMap;
        }];
      }];
      var ARROW_ARG = /^([^\(]+?)=>/;
      var FN_ARGS = /^[^\(]*\(\s*([^\)]*)\)/m;
      var FN_ARG_SPLIT = /,/;
      var FN_ARG = /^\s*(_?)(\S+?)\1\s*$/;
      var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
      var $injectorMinErr = minErr('$injector');
      function stringifyFn(fn) {
        return Function.prototype.toString.call(fn) + ' ';
      }
      function extractArgs(fn) {
        var fnText = stringifyFn(fn).replace(STRIP_COMMENTS, ''),
            args = fnText.match(ARROW_ARG) || fnText.match(FN_ARGS);
        return args;
      }
      function anonFn(fn) {
        var args = extractArgs(fn);
        if (args) {
          return 'function(' + (args[1] || '').replace(/[\s\r\n]+/, ' ') + ')';
        }
        return 'fn';
      }
      function annotate(fn, strictDi, name) {
        var $inject,
            argDecl,
            last;
        if (typeof fn === 'function') {
          if (!($inject = fn.$inject)) {
            $inject = [];
            if (fn.length) {
              if (strictDi) {
                if (!isString(name) || !name) {
                  name = fn.name || anonFn(fn);
                }
                throw $injectorMinErr('strictdi', '{0} is not using explicit annotation and cannot be invoked in strict mode', name);
              }
              argDecl = extractArgs(fn);
              forEach(argDecl[1].split(FN_ARG_SPLIT), function(arg) {
                arg.replace(FN_ARG, function(all, underscore, name) {
                  $inject.push(name);
                });
              });
            }
            fn.$inject = $inject;
          }
        } else if (isArray(fn)) {
          last = fn.length - 1;
          assertArgFn(fn[last], 'fn');
          $inject = fn.slice(0, last);
        } else {
          assertArgFn(fn, 'fn', true);
        }
        return $inject;
      }
      function createInjector(modulesToLoad, strictDi) {
        strictDi = (strictDi === true);
        var INSTANTIATING = {},
            providerSuffix = 'Provider',
            path = [],
            loadedModules = new HashMap([], true),
            providerCache = {$provide: {
                provider: supportObject(provider),
                factory: supportObject(factory),
                service: supportObject(service),
                value: supportObject(value),
                constant: supportObject(constant),
                decorator: decorator
              }},
            providerInjector = (providerCache.$injector = createInternalInjector(providerCache, function(serviceName, caller) {
              if (angular.isString(caller)) {
                path.push(caller);
              }
              throw $injectorMinErr('unpr', "Unknown provider: {0}", path.join(' <- '));
            })),
            instanceCache = {},
            protoInstanceInjector = createInternalInjector(instanceCache, function(serviceName, caller) {
              var provider = providerInjector.get(serviceName + providerSuffix, caller);
              return instanceInjector.invoke(provider.$get, provider, undefined, serviceName);
            }),
            instanceInjector = protoInstanceInjector;
        providerCache['$injector' + providerSuffix] = {$get: valueFn(protoInstanceInjector)};
        var runBlocks = loadModules(modulesToLoad);
        instanceInjector = protoInstanceInjector.get('$injector');
        instanceInjector.strictDi = strictDi;
        forEach(runBlocks, function(fn) {
          if (fn)
            instanceInjector.invoke(fn);
        });
        return instanceInjector;
        function supportObject(delegate) {
          return function(key, value) {
            if (isObject(key)) {
              forEach(key, reverseParams(delegate));
            } else {
              return delegate(key, value);
            }
          };
        }
        function provider(name, provider_) {
          assertNotHasOwnProperty(name, 'service');
          if (isFunction(provider_) || isArray(provider_)) {
            provider_ = providerInjector.instantiate(provider_);
          }
          if (!provider_.$get) {
            throw $injectorMinErr('pget', "Provider '{0}' must define $get factory method.", name);
          }
          return providerCache[name + providerSuffix] = provider_;
        }
        function enforceReturnValue(name, factory) {
          return function enforcedReturnValue() {
            var result = instanceInjector.invoke(factory, this);
            if (isUndefined(result)) {
              throw $injectorMinErr('undef', "Provider '{0}' must return a value from $get factory method.", name);
            }
            return result;
          };
        }
        function factory(name, factoryFn, enforce) {
          return provider(name, {$get: enforce !== false ? enforceReturnValue(name, factoryFn) : factoryFn});
        }
        function service(name, constructor) {
          return factory(name, ['$injector', function($injector) {
            return $injector.instantiate(constructor);
          }]);
        }
        function value(name, val) {
          return factory(name, valueFn(val), false);
        }
        function constant(name, value) {
          assertNotHasOwnProperty(name, 'constant');
          providerCache[name] = value;
          instanceCache[name] = value;
        }
        function decorator(serviceName, decorFn) {
          var origProvider = providerInjector.get(serviceName + providerSuffix),
              orig$get = origProvider.$get;
          origProvider.$get = function() {
            var origInstance = instanceInjector.invoke(orig$get, origProvider);
            return instanceInjector.invoke(decorFn, null, {$delegate: origInstance});
          };
        }
        function loadModules(modulesToLoad) {
          assertArg(isUndefined(modulesToLoad) || isArray(modulesToLoad), 'modulesToLoad', 'not an array');
          var runBlocks = [],
              moduleFn;
          forEach(modulesToLoad, function(module) {
            if (loadedModules.get(module))
              return;
            loadedModules.put(module, true);
            function runInvokeQueue(queue) {
              var i,
                  ii;
              for (i = 0, ii = queue.length; i < ii; i++) {
                var invokeArgs = queue[i],
                    provider = providerInjector.get(invokeArgs[0]);
                provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
              }
            }
            try {
              if (isString(module)) {
                moduleFn = angularModule(module);
                runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks);
                runInvokeQueue(moduleFn._invokeQueue);
                runInvokeQueue(moduleFn._configBlocks);
              } else if (isFunction(module)) {
                runBlocks.push(providerInjector.invoke(module));
              } else if (isArray(module)) {
                runBlocks.push(providerInjector.invoke(module));
              } else {
                assertArgFn(module, 'module');
              }
            } catch (e) {
              if (isArray(module)) {
                module = module[module.length - 1];
              }
              if (e.message && e.stack && e.stack.indexOf(e.message) == -1) {
                e = e.message + '\n' + e.stack;
              }
              throw $injectorMinErr('modulerr', "Failed to instantiate module {0} due to:\n{1}", module, e.stack || e.message || e);
            }
          });
          return runBlocks;
        }
        function createInternalInjector(cache, factory) {
          function getService(serviceName, caller) {
            if (cache.hasOwnProperty(serviceName)) {
              if (cache[serviceName] === INSTANTIATING) {
                throw $injectorMinErr('cdep', 'Circular dependency found: {0}', serviceName + ' <- ' + path.join(' <- '));
              }
              return cache[serviceName];
            } else {
              try {
                path.unshift(serviceName);
                cache[serviceName] = INSTANTIATING;
                return cache[serviceName] = factory(serviceName, caller);
              } catch (err) {
                if (cache[serviceName] === INSTANTIATING) {
                  delete cache[serviceName];
                }
                throw err;
              } finally {
                path.shift();
              }
            }
          }
          function injectionArgs(fn, locals, serviceName) {
            var args = [],
                $inject = createInjector.$$annotate(fn, strictDi, serviceName);
            for (var i = 0,
                length = $inject.length; i < length; i++) {
              var key = $inject[i];
              if (typeof key !== 'string') {
                throw $injectorMinErr('itkn', 'Incorrect injection token! Expected service name as string, got {0}', key);
              }
              args.push(locals && locals.hasOwnProperty(key) ? locals[key] : getService(key, serviceName));
            }
            return args;
          }
          function isClass(func) {
            if (msie <= 11) {
              return false;
            }
            return typeof func === 'function' && /^(?:class\s|constructor\()/.test(stringifyFn(func));
          }
          function invoke(fn, self, locals, serviceName) {
            if (typeof locals === 'string') {
              serviceName = locals;
              locals = null;
            }
            var args = injectionArgs(fn, locals, serviceName);
            if (isArray(fn)) {
              fn = fn[fn.length - 1];
            }
            if (!isClass(fn)) {
              return fn.apply(self, args);
            } else {
              args.unshift(null);
              return new (Function.prototype.bind.apply(fn, args))();
            }
          }
          function instantiate(Type, locals, serviceName) {
            var ctor = (isArray(Type) ? Type[Type.length - 1] : Type);
            var args = injectionArgs(Type, locals, serviceName);
            args.unshift(null);
            return new (Function.prototype.bind.apply(ctor, args))();
          }
          return {
            invoke: invoke,
            instantiate: instantiate,
            get: getService,
            annotate: createInjector.$$annotate,
            has: function(name) {
              return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name);
            }
          };
        }
      }
      createInjector.$$annotate = annotate;
      function $AnchorScrollProvider() {
        var autoScrollingEnabled = true;
        this.disableAutoScrolling = function() {
          autoScrollingEnabled = false;
        };
        this.$get = ['$window', '$location', '$rootScope', function($window, $location, $rootScope) {
          var document = $window.document;
          function getFirstAnchor(list) {
            var result = null;
            Array.prototype.some.call(list, function(element) {
              if (nodeName_(element) === 'a') {
                result = element;
                return true;
              }
            });
            return result;
          }
          function getYOffset() {
            var offset = scroll.yOffset;
            if (isFunction(offset)) {
              offset = offset();
            } else if (isElement(offset)) {
              var elem = offset[0];
              var style = $window.getComputedStyle(elem);
              if (style.position !== 'fixed') {
                offset = 0;
              } else {
                offset = elem.getBoundingClientRect().bottom;
              }
            } else if (!isNumber(offset)) {
              offset = 0;
            }
            return offset;
          }
          function scrollTo(elem) {
            if (elem) {
              elem.scrollIntoView();
              var offset = getYOffset();
              if (offset) {
                var elemTop = elem.getBoundingClientRect().top;
                $window.scrollBy(0, elemTop - offset);
              }
            } else {
              $window.scrollTo(0, 0);
            }
          }
          function scroll(hash) {
            hash = isString(hash) ? hash : $location.hash();
            var elm;
            if (!hash)
              scrollTo(null);
            else if ((elm = document.getElementById(hash)))
              scrollTo(elm);
            else if ((elm = getFirstAnchor(document.getElementsByName(hash))))
              scrollTo(elm);
            else if (hash === 'top')
              scrollTo(null);
          }
          if (autoScrollingEnabled) {
            $rootScope.$watch(function autoScrollWatch() {
              return $location.hash();
            }, function autoScrollWatchAction(newVal, oldVal) {
              if (newVal === oldVal && newVal === '')
                return;
              jqLiteDocumentLoaded(function() {
                $rootScope.$evalAsync(scroll);
              });
            });
          }
          return scroll;
        }];
      }
      var $animateMinErr = minErr('$animate');
      var ELEMENT_NODE = 1;
      var NG_ANIMATE_CLASSNAME = 'ng-animate';
      function mergeClasses(a, b) {
        if (!a && !b)
          return '';
        if (!a)
          return b;
        if (!b)
          return a;
        if (isArray(a))
          a = a.join(' ');
        if (isArray(b))
          b = b.join(' ');
        return a + ' ' + b;
      }
      function extractElementNode(element) {
        for (var i = 0; i < element.length; i++) {
          var elm = element[i];
          if (elm.nodeType === ELEMENT_NODE) {
            return elm;
          }
        }
      }
      function splitClasses(classes) {
        if (isString(classes)) {
          classes = classes.split(' ');
        }
        var obj = createMap();
        forEach(classes, function(klass) {
          if (klass.length) {
            obj[klass] = true;
          }
        });
        return obj;
      }
      function prepareAnimateOptions(options) {
        return isObject(options) ? options : {};
      }
      var $$CoreAnimateJsProvider = function() {
        this.$get = noop;
      };
      var $$CoreAnimateQueueProvider = function() {
        var postDigestQueue = new HashMap();
        var postDigestElements = [];
        this.$get = ['$$AnimateRunner', '$rootScope', function($$AnimateRunner, $rootScope) {
          return {
            enabled: noop,
            on: noop,
            off: noop,
            pin: noop,
            push: function(element, event, options, domOperation) {
              domOperation && domOperation();
              options = options || {};
              options.from && element.css(options.from);
              options.to && element.css(options.to);
              if (options.addClass || options.removeClass) {
                addRemoveClassesPostDigest(element, options.addClass, options.removeClass);
              }
              var runner = new $$AnimateRunner();
              runner.complete();
              return runner;
            }
          };
          function updateData(data, classes, value) {
            var changed = false;
            if (classes) {
              classes = isString(classes) ? classes.split(' ') : isArray(classes) ? classes : [];
              forEach(classes, function(className) {
                if (className) {
                  changed = true;
                  data[className] = value;
                }
              });
            }
            return changed;
          }
          function handleCSSClassChanges() {
            forEach(postDigestElements, function(element) {
              var data = postDigestQueue.get(element);
              if (data) {
                var existing = splitClasses(element.attr('class'));
                var toAdd = '';
                var toRemove = '';
                forEach(data, function(status, className) {
                  var hasClass = !!existing[className];
                  if (status !== hasClass) {
                    if (status) {
                      toAdd += (toAdd.length ? ' ' : '') + className;
                    } else {
                      toRemove += (toRemove.length ? ' ' : '') + className;
                    }
                  }
                });
                forEach(element, function(elm) {
                  toAdd && jqLiteAddClass(elm, toAdd);
                  toRemove && jqLiteRemoveClass(elm, toRemove);
                });
                postDigestQueue.remove(element);
              }
            });
            postDigestElements.length = 0;
          }
          function addRemoveClassesPostDigest(element, add, remove) {
            var data = postDigestQueue.get(element) || {};
            var classesAdded = updateData(data, add, true);
            var classesRemoved = updateData(data, remove, false);
            if (classesAdded || classesRemoved) {
              postDigestQueue.put(element, data);
              postDigestElements.push(element);
              if (postDigestElements.length === 1) {
                $rootScope.$$postDigest(handleCSSClassChanges);
              }
            }
          }
        }];
      };
      var $AnimateProvider = ['$provide', function($provide) {
        var provider = this;
        this.$$registeredAnimations = Object.create(null);
        this.register = function(name, factory) {
          if (name && name.charAt(0) !== '.') {
            throw $animateMinErr('notcsel', "Expecting class selector starting with '.' got '{0}'.", name);
          }
          var key = name + '-animation';
          provider.$$registeredAnimations[name.substr(1)] = key;
          $provide.factory(key, factory);
        };
        this.classNameFilter = function(expression) {
          if (arguments.length === 1) {
            this.$$classNameFilter = (expression instanceof RegExp) ? expression : null;
            if (this.$$classNameFilter) {
              var reservedRegex = new RegExp("(\\s+|\\/)" + NG_ANIMATE_CLASSNAME + "(\\s+|\\/)");
              if (reservedRegex.test(this.$$classNameFilter.toString())) {
                throw $animateMinErr('nongcls', '$animateProvider.classNameFilter(regex) prohibits accepting a regex value which matches/contains the "{0}" CSS class.', NG_ANIMATE_CLASSNAME);
              }
            }
          }
          return this.$$classNameFilter;
        };
        this.$get = ['$$animateQueue', function($$animateQueue) {
          function domInsert(element, parentElement, afterElement) {
            if (afterElement) {
              var afterNode = extractElementNode(afterElement);
              if (afterNode && !afterNode.parentNode && !afterNode.previousElementSibling) {
                afterElement = null;
              }
            }
            afterElement ? afterElement.after(element) : parentElement.prepend(element);
          }
          return {
            on: $$animateQueue.on,
            off: $$animateQueue.off,
            pin: $$animateQueue.pin,
            enabled: $$animateQueue.enabled,
            cancel: function(runner) {
              runner.end && runner.end();
            },
            enter: function(element, parent, after, options) {
              parent = parent && jqLite(parent);
              after = after && jqLite(after);
              parent = parent || after.parent();
              domInsert(element, parent, after);
              return $$animateQueue.push(element, 'enter', prepareAnimateOptions(options));
            },
            move: function(element, parent, after, options) {
              parent = parent && jqLite(parent);
              after = after && jqLite(after);
              parent = parent || after.parent();
              domInsert(element, parent, after);
              return $$animateQueue.push(element, 'move', prepareAnimateOptions(options));
            },
            leave: function(element, options) {
              return $$animateQueue.push(element, 'leave', prepareAnimateOptions(options), function() {
                element.remove();
              });
            },
            addClass: function(element, className, options) {
              options = prepareAnimateOptions(options);
              options.addClass = mergeClasses(options.addclass, className);
              return $$animateQueue.push(element, 'addClass', options);
            },
            removeClass: function(element, className, options) {
              options = prepareAnimateOptions(options);
              options.removeClass = mergeClasses(options.removeClass, className);
              return $$animateQueue.push(element, 'removeClass', options);
            },
            setClass: function(element, add, remove, options) {
              options = prepareAnimateOptions(options);
              options.addClass = mergeClasses(options.addClass, add);
              options.removeClass = mergeClasses(options.removeClass, remove);
              return $$animateQueue.push(element, 'setClass', options);
            },
            animate: function(element, from, to, className, options) {
              options = prepareAnimateOptions(options);
              options.from = options.from ? extend(options.from, from) : from;
              options.to = options.to ? extend(options.to, to) : to;
              className = className || 'ng-inline-animate';
              options.tempClasses = mergeClasses(options.tempClasses, className);
              return $$animateQueue.push(element, 'animate', options);
            }
          };
        }];
      }];
      var $$AnimateAsyncRunFactoryProvider = function() {
        this.$get = ['$$rAF', function($$rAF) {
          var waitQueue = [];
          function waitForTick(fn) {
            waitQueue.push(fn);
            if (waitQueue.length > 1)
              return;
            $$rAF(function() {
              for (var i = 0; i < waitQueue.length; i++) {
                waitQueue[i]();
              }
              waitQueue = [];
            });
          }
          return function() {
            var passed = false;
            waitForTick(function() {
              passed = true;
            });
            return function(callback) {
              passed ? callback() : waitForTick(callback);
            };
          };
        }];
      };
      var $$AnimateRunnerFactoryProvider = function() {
        this.$get = ['$q', '$sniffer', '$$animateAsyncRun', '$document', '$timeout', function($q, $sniffer, $$animateAsyncRun, $document, $timeout) {
          var INITIAL_STATE = 0;
          var DONE_PENDING_STATE = 1;
          var DONE_COMPLETE_STATE = 2;
          AnimateRunner.chain = function(chain, callback) {
            var index = 0;
            next();
            function next() {
              if (index === chain.length) {
                callback(true);
                return;
              }
              chain[index](function(response) {
                if (response === false) {
                  callback(false);
                  return;
                }
                index++;
                next();
              });
            }
          };
          AnimateRunner.all = function(runners, callback) {
            var count = 0;
            var status = true;
            forEach(runners, function(runner) {
              runner.done(onProgress);
            });
            function onProgress(response) {
              status = status && response;
              if (++count === runners.length) {
                callback(status);
              }
            }
          };
          function AnimateRunner(host) {
            this.setHost(host);
            var rafTick = $$animateAsyncRun();
            var timeoutTick = function(fn) {
              $timeout(fn, 0, false);
            };
            this._doneCallbacks = [];
            this._tick = function(fn) {
              var doc = $document[0];
              if (doc && doc.hidden) {
                timeoutTick(fn);
              } else {
                rafTick(fn);
              }
            };
            this._state = 0;
          }
          AnimateRunner.prototype = {
            setHost: function(host) {
              this.host = host || {};
            },
            done: function(fn) {
              if (this._state === DONE_COMPLETE_STATE) {
                fn();
              } else {
                this._doneCallbacks.push(fn);
              }
            },
            progress: noop,
            getPromise: function() {
              if (!this.promise) {
                var self = this;
                this.promise = $q(function(resolve, reject) {
                  self.done(function(status) {
                    status === false ? reject() : resolve();
                  });
                });
              }
              return this.promise;
            },
            then: function(resolveHandler, rejectHandler) {
              return this.getPromise().then(resolveHandler, rejectHandler);
            },
            'catch': function(handler) {
              return this.getPromise()['catch'](handler);
            },
            'finally': function(handler) {
              return this.getPromise()['finally'](handler);
            },
            pause: function() {
              if (this.host.pause) {
                this.host.pause();
              }
            },
            resume: function() {
              if (this.host.resume) {
                this.host.resume();
              }
            },
            end: function() {
              if (this.host.end) {
                this.host.end();
              }
              this._resolve(true);
            },
            cancel: function() {
              if (this.host.cancel) {
                this.host.cancel();
              }
              this._resolve(false);
            },
            complete: function(response) {
              var self = this;
              if (self._state === INITIAL_STATE) {
                self._state = DONE_PENDING_STATE;
                self._tick(function() {
                  self._resolve(response);
                });
              }
            },
            _resolve: function(response) {
              if (this._state !== DONE_COMPLETE_STATE) {
                forEach(this._doneCallbacks, function(fn) {
                  fn(response);
                });
                this._doneCallbacks.length = 0;
                this._state = DONE_COMPLETE_STATE;
              }
            }
          };
          return AnimateRunner;
        }];
      };
      var $CoreAnimateCssProvider = function() {
        this.$get = ['$$rAF', '$q', '$$AnimateRunner', function($$rAF, $q, $$AnimateRunner) {
          return function(element, initialOptions) {
            var options = initialOptions || {};
            if (!options.$$prepared) {
              options = copy(options);
            }
            if (options.cleanupStyles) {
              options.from = options.to = null;
            }
            if (options.from) {
              element.css(options.from);
              options.from = null;
            }
            var closed,
                runner = new $$AnimateRunner();
            return {
              start: run,
              end: run
            };
            function run() {
              $$rAF(function() {
                applyAnimationContents();
                if (!closed) {
                  runner.complete();
                }
                closed = true;
              });
              return runner;
            }
            function applyAnimationContents() {
              if (options.addClass) {
                element.addClass(options.addClass);
                options.addClass = null;
              }
              if (options.removeClass) {
                element.removeClass(options.removeClass);
                options.removeClass = null;
              }
              if (options.to) {
                element.css(options.to);
                options.to = null;
              }
            }
          };
        }];
      };
      function Browser(window, document, $log, $sniffer) {
        var self = this,
            location = window.location,
            history = window.history,
            setTimeout = window.setTimeout,
            clearTimeout = window.clearTimeout,
            pendingDeferIds = {};
        self.isMock = false;
        var outstandingRequestCount = 0;
        var outstandingRequestCallbacks = [];
        self.$$completeOutstandingRequest = completeOutstandingRequest;
        self.$$incOutstandingRequestCount = function() {
          outstandingRequestCount++;
        };
        function completeOutstandingRequest(fn) {
          try {
            fn.apply(null, sliceArgs(arguments, 1));
          } finally {
            outstandingRequestCount--;
            if (outstandingRequestCount === 0) {
              while (outstandingRequestCallbacks.length) {
                try {
                  outstandingRequestCallbacks.pop()();
                } catch (e) {
                  $log.error(e);
                }
              }
            }
          }
        }
        function getHash(url) {
          var index = url.indexOf('#');
          return index === -1 ? '' : url.substr(index);
        }
        self.notifyWhenNoOutstandingRequests = function(callback) {
          if (outstandingRequestCount === 0) {
            callback();
          } else {
            outstandingRequestCallbacks.push(callback);
          }
        };
        var cachedState,
            lastHistoryState,
            lastBrowserUrl = location.href,
            baseElement = document.find('base'),
            pendingLocation = null,
            getCurrentState = !$sniffer.history ? noop : function getCurrentState() {
              try {
                return history.state;
              } catch (e) {}
            };
        cacheState();
        lastHistoryState = cachedState;
        self.url = function(url, replace, state) {
          if (isUndefined(state)) {
            state = null;
          }
          if (location !== window.location)
            location = window.location;
          if (history !== window.history)
            history = window.history;
          if (url) {
            var sameState = lastHistoryState === state;
            if (lastBrowserUrl === url && (!$sniffer.history || sameState)) {
              return self;
            }
            var sameBase = lastBrowserUrl && stripHash(lastBrowserUrl) === stripHash(url);
            lastBrowserUrl = url;
            lastHistoryState = state;
            if ($sniffer.history && (!sameBase || !sameState)) {
              history[replace ? 'replaceState' : 'pushState'](state, '', url);
              cacheState();
              lastHistoryState = cachedState;
            } else {
              if (!sameBase) {
                pendingLocation = url;
              }
              if (replace) {
                location.replace(url);
              } else if (!sameBase) {
                location.href = url;
              } else {
                location.hash = getHash(url);
              }
              if (location.href !== url) {
                pendingLocation = url;
              }
            }
            if (pendingLocation) {
              pendingLocation = url;
            }
            return self;
          } else {
            return pendingLocation || location.href.replace(/%27/g, "'");
          }
        };
        self.state = function() {
          return cachedState;
        };
        var urlChangeListeners = [],
            urlChangeInit = false;
        function cacheStateAndFireUrlChange() {
          pendingLocation = null;
          cacheState();
          fireUrlChange();
        }
        var lastCachedState = null;
        function cacheState() {
          cachedState = getCurrentState();
          cachedState = isUndefined(cachedState) ? null : cachedState;
          if (equals(cachedState, lastCachedState)) {
            cachedState = lastCachedState;
          }
          lastCachedState = cachedState;
        }
        function fireUrlChange() {
          if (lastBrowserUrl === self.url() && lastHistoryState === cachedState) {
            return;
          }
          lastBrowserUrl = self.url();
          lastHistoryState = cachedState;
          forEach(urlChangeListeners, function(listener) {
            listener(self.url(), cachedState);
          });
        }
        self.onUrlChange = function(callback) {
          if (!urlChangeInit) {
            if ($sniffer.history)
              jqLite(window).on('popstate', cacheStateAndFireUrlChange);
            jqLite(window).on('hashchange', cacheStateAndFireUrlChange);
            urlChangeInit = true;
          }
          urlChangeListeners.push(callback);
          return callback;
        };
        self.$$applicationDestroyed = function() {
          jqLite(window).off('hashchange popstate', cacheStateAndFireUrlChange);
        };
        self.$$checkUrlChange = fireUrlChange;
        self.baseHref = function() {
          var href = baseElement.attr('href');
          return href ? href.replace(/^(https?\:)?\/\/[^\/]*/, '') : '';
        };
        self.defer = function(fn, delay) {
          var timeoutId;
          outstandingRequestCount++;
          timeoutId = setTimeout(function() {
            delete pendingDeferIds[timeoutId];
            completeOutstandingRequest(fn);
          }, delay || 0);
          pendingDeferIds[timeoutId] = true;
          return timeoutId;
        };
        self.defer.cancel = function(deferId) {
          if (pendingDeferIds[deferId]) {
            delete pendingDeferIds[deferId];
            clearTimeout(deferId);
            completeOutstandingRequest(noop);
            return true;
          }
          return false;
        };
      }
      function $BrowserProvider() {
        this.$get = ['$window', '$log', '$sniffer', '$document', function($window, $log, $sniffer, $document) {
          return new Browser($window, $document, $log, $sniffer);
        }];
      }
      function $CacheFactoryProvider() {
        this.$get = function() {
          var caches = {};
          function cacheFactory(cacheId, options) {
            if (cacheId in caches) {
              throw minErr('$cacheFactory')('iid', "CacheId '{0}' is already taken!", cacheId);
            }
            var size = 0,
                stats = extend({}, options, {id: cacheId}),
                data = createMap(),
                capacity = (options && options.capacity) || Number.MAX_VALUE,
                lruHash = createMap(),
                freshEnd = null,
                staleEnd = null;
            return caches[cacheId] = {
              put: function(key, value) {
                if (isUndefined(value))
                  return;
                if (capacity < Number.MAX_VALUE) {
                  var lruEntry = lruHash[key] || (lruHash[key] = {key: key});
                  refresh(lruEntry);
                }
                if (!(key in data))
                  size++;
                data[key] = value;
                if (size > capacity) {
                  this.remove(staleEnd.key);
                }
                return value;
              },
              get: function(key) {
                if (capacity < Number.MAX_VALUE) {
                  var lruEntry = lruHash[key];
                  if (!lruEntry)
                    return;
                  refresh(lruEntry);
                }
                return data[key];
              },
              remove: function(key) {
                if (capacity < Number.MAX_VALUE) {
                  var lruEntry = lruHash[key];
                  if (!lruEntry)
                    return;
                  if (lruEntry == freshEnd)
                    freshEnd = lruEntry.p;
                  if (lruEntry == staleEnd)
                    staleEnd = lruEntry.n;
                  link(lruEntry.n, lruEntry.p);
                  delete lruHash[key];
                }
                if (!(key in data))
                  return;
                delete data[key];
                size--;
              },
              removeAll: function() {
                data = createMap();
                size = 0;
                lruHash = createMap();
                freshEnd = staleEnd = null;
              },
              destroy: function() {
                data = null;
                stats = null;
                lruHash = null;
                delete caches[cacheId];
              },
              info: function() {
                return extend({}, stats, {size: size});
              }
            };
            function refresh(entry) {
              if (entry != freshEnd) {
                if (!staleEnd) {
                  staleEnd = entry;
                } else if (staleEnd == entry) {
                  staleEnd = entry.n;
                }
                link(entry.n, entry.p);
                link(entry, freshEnd);
                freshEnd = entry;
                freshEnd.n = null;
              }
            }
            function link(nextEntry, prevEntry) {
              if (nextEntry != prevEntry) {
                if (nextEntry)
                  nextEntry.p = prevEntry;
                if (prevEntry)
                  prevEntry.n = nextEntry;
              }
            }
          }
          cacheFactory.info = function() {
            var info = {};
            forEach(caches, function(cache, cacheId) {
              info[cacheId] = cache.info();
            });
            return info;
          };
          cacheFactory.get = function(cacheId) {
            return caches[cacheId];
          };
          return cacheFactory;
        };
      }
      function $TemplateCacheProvider() {
        this.$get = ['$cacheFactory', function($cacheFactory) {
          return $cacheFactory('templates');
        }];
      }
      var $compileMinErr = minErr('$compile');
      function UNINITIALIZED_VALUE() {}
      var _UNINITIALIZED_VALUE = new UNINITIALIZED_VALUE();
      $CompileProvider.$inject = ['$provide', '$$sanitizeUriProvider'];
      function $CompileProvider($provide, $$sanitizeUriProvider) {
        var hasDirectives = {},
            Suffix = 'Directive',
            COMMENT_DIRECTIVE_REGEXP = /^\s*directive\:\s*([\w\-]+)\s+(.*)$/,
            CLASS_DIRECTIVE_REGEXP = /(([\w\-]+)(?:\:([^;]+))?;?)/,
            ALL_OR_NOTHING_ATTRS = makeMap('ngSrc,ngSrcset,src,srcset'),
            REQUIRE_PREFIX_REGEXP = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/;
        var EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/;
        var bindingCache = createMap();
        function parseIsolateBindings(scope, directiveName, isController) {
          var LOCAL_REGEXP = /^\s*([@&<]|=(\*?))(\??)\s*(\w*)\s*$/;
          var bindings = createMap();
          forEach(scope, function(definition, scopeName) {
            if (definition in bindingCache) {
              bindings[scopeName] = bindingCache[definition];
              return;
            }
            var match = definition.match(LOCAL_REGEXP);
            if (!match) {
              throw $compileMinErr('iscp', "Invalid {3} for directive '{0}'." + " Definition: {... {1}: '{2}' ...}", directiveName, scopeName, definition, (isController ? "controller bindings definition" : "isolate scope definition"));
            }
            bindings[scopeName] = {
              mode: match[1][0],
              collection: match[2] === '*',
              optional: match[3] === '?',
              attrName: match[4] || scopeName
            };
            if (match[4]) {
              bindingCache[definition] = bindings[scopeName];
            }
          });
          return bindings;
        }
        function parseDirectiveBindings(directive, directiveName) {
          var bindings = {
            isolateScope: null,
            bindToController: null
          };
          if (isObject(directive.scope)) {
            if (directive.bindToController === true) {
              bindings.bindToController = parseIsolateBindings(directive.scope, directiveName, true);
              bindings.isolateScope = {};
            } else {
              bindings.isolateScope = parseIsolateBindings(directive.scope, directiveName, false);
            }
          }
          if (isObject(directive.bindToController)) {
            bindings.bindToController = parseIsolateBindings(directive.bindToController, directiveName, true);
          }
          if (isObject(bindings.bindToController)) {
            var controller = directive.controller;
            var controllerAs = directive.controllerAs;
            if (!controller) {
              throw $compileMinErr('noctrl', "Cannot bind to controller without directive '{0}'s controller.", directiveName);
            } else if (!identifierForController(controller, controllerAs)) {
              throw $compileMinErr('noident', "Cannot bind to controller without identifier for directive '{0}'.", directiveName);
            }
          }
          return bindings;
        }
        function assertValidDirectiveName(name) {
          var letter = name.charAt(0);
          if (!letter || letter !== lowercase(letter)) {
            throw $compileMinErr('baddir', "Directive/Component name '{0}' is invalid. The first character must be a lowercase letter", name);
          }
          if (name !== name.trim()) {
            throw $compileMinErr('baddir', "Directive/Component name '{0}' is invalid. The name should not contain leading or trailing whitespaces", name);
          }
        }
        function getDirectiveRequire(directive) {
          var require = directive.require || (directive.controller && directive.name);
          if (!isArray(require) && isObject(require)) {
            forEach(require, function(value, key) {
              var match = value.match(REQUIRE_PREFIX_REGEXP);
              var name = value.substring(match[0].length);
              if (!name)
                require[key] = match[0] + key;
            });
          }
          return require;
        }
        this.directive = function registerDirective(name, directiveFactory) {
          assertNotHasOwnProperty(name, 'directive');
          if (isString(name)) {
            assertValidDirectiveName(name);
            assertArg(directiveFactory, 'directiveFactory');
            if (!hasDirectives.hasOwnProperty(name)) {
              hasDirectives[name] = [];
              $provide.factory(name + Suffix, ['$injector', '$exceptionHandler', function($injector, $exceptionHandler) {
                var directives = [];
                forEach(hasDirectives[name], function(directiveFactory, index) {
                  try {
                    var directive = $injector.invoke(directiveFactory);
                    if (isFunction(directive)) {
                      directive = {compile: valueFn(directive)};
                    } else if (!directive.compile && directive.link) {
                      directive.compile = valueFn(directive.link);
                    }
                    directive.priority = directive.priority || 0;
                    directive.index = index;
                    directive.name = directive.name || name;
                    directive.require = getDirectiveRequire(directive);
                    directive.restrict = directive.restrict || 'EA';
                    directive.$$moduleName = directiveFactory.$$moduleName;
                    directives.push(directive);
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                });
                return directives;
              }]);
            }
            hasDirectives[name].push(directiveFactory);
          } else {
            forEach(name, reverseParams(registerDirective));
          }
          return this;
        };
        this.component = function registerComponent(name, options) {
          var controller = options.controller || function() {};
          function factory($injector) {
            function makeInjectable(fn) {
              if (isFunction(fn) || isArray(fn)) {
                return function(tElement, tAttrs) {
                  return $injector.invoke(fn, this, {
                    $element: tElement,
                    $attrs: tAttrs
                  });
                };
              } else {
                return fn;
              }
            }
            var template = (!options.template && !options.templateUrl ? '' : options.template);
            var ddo = {
              controller: controller,
              controllerAs: identifierForController(options.controller) || options.controllerAs || '$ctrl',
              template: makeInjectable(template),
              templateUrl: makeInjectable(options.templateUrl),
              transclude: options.transclude,
              scope: {},
              bindToController: options.bindings || {},
              restrict: 'E',
              require: options.require
            };
            forEach(options, function(val, key) {
              if (key.charAt(0) === '$')
                ddo[key] = val;
            });
            return ddo;
          }
          forEach(options, function(val, key) {
            if (key.charAt(0) === '$') {
              factory[key] = val;
              if (isFunction(controller))
                controller[key] = val;
            }
          });
          factory.$inject = ['$injector'];
          return this.directive(name, factory);
        };
        this.aHrefSanitizationWhitelist = function(regexp) {
          if (isDefined(regexp)) {
            $$sanitizeUriProvider.aHrefSanitizationWhitelist(regexp);
            return this;
          } else {
            return $$sanitizeUriProvider.aHrefSanitizationWhitelist();
          }
        };
        this.imgSrcSanitizationWhitelist = function(regexp) {
          if (isDefined(regexp)) {
            $$sanitizeUriProvider.imgSrcSanitizationWhitelist(regexp);
            return this;
          } else {
            return $$sanitizeUriProvider.imgSrcSanitizationWhitelist();
          }
        };
        var debugInfoEnabled = true;
        this.debugInfoEnabled = function(enabled) {
          if (isDefined(enabled)) {
            debugInfoEnabled = enabled;
            return this;
          }
          return debugInfoEnabled;
        };
        var TTL = 10;
        this.onChangesTtl = function(value) {
          if (arguments.length) {
            TTL = value;
            return this;
          }
          return TTL;
        };
        this.$get = ['$injector', '$interpolate', '$exceptionHandler', '$templateRequest', '$parse', '$controller', '$rootScope', '$sce', '$animate', '$$sanitizeUri', function($injector, $interpolate, $exceptionHandler, $templateRequest, $parse, $controller, $rootScope, $sce, $animate, $$sanitizeUri) {
          var SIMPLE_ATTR_NAME = /^\w/;
          var specialAttrHolder = window.document.createElement('div');
          var onChangesTtl = TTL;
          var onChangesQueue;
          function flushOnChangesQueue() {
            try {
              if (!(--onChangesTtl)) {
                onChangesQueue = undefined;
                throw $compileMinErr('infchng', '{0} $onChanges() iterations reached. Aborting!\n', TTL);
              }
              $rootScope.$apply(function() {
                var errors = [];
                for (var i = 0,
                    ii = onChangesQueue.length; i < ii; ++i) {
                  try {
                    onChangesQueue[i]();
                  } catch (e) {
                    errors.push(e);
                  }
                }
                onChangesQueue = undefined;
                if (errors.length) {
                  throw errors;
                }
              });
            } finally {
              onChangesTtl++;
            }
          }
          function Attributes(element, attributesToCopy) {
            if (attributesToCopy) {
              var keys = Object.keys(attributesToCopy);
              var i,
                  l,
                  key;
              for (i = 0, l = keys.length; i < l; i++) {
                key = keys[i];
                this[key] = attributesToCopy[key];
              }
            } else {
              this.$attr = {};
            }
            this.$$element = element;
          }
          Attributes.prototype = {
            $normalize: directiveNormalize,
            $addClass: function(classVal) {
              if (classVal && classVal.length > 0) {
                $animate.addClass(this.$$element, classVal);
              }
            },
            $removeClass: function(classVal) {
              if (classVal && classVal.length > 0) {
                $animate.removeClass(this.$$element, classVal);
              }
            },
            $updateClass: function(newClasses, oldClasses) {
              var toAdd = tokenDifference(newClasses, oldClasses);
              if (toAdd && toAdd.length) {
                $animate.addClass(this.$$element, toAdd);
              }
              var toRemove = tokenDifference(oldClasses, newClasses);
              if (toRemove && toRemove.length) {
                $animate.removeClass(this.$$element, toRemove);
              }
            },
            $set: function(key, value, writeAttr, attrName) {
              var node = this.$$element[0],
                  booleanKey = getBooleanAttrName(node, key),
                  aliasedKey = getAliasedAttrName(key),
                  observer = key,
                  nodeName;
              if (booleanKey) {
                this.$$element.prop(key, value);
                attrName = booleanKey;
              } else if (aliasedKey) {
                this[aliasedKey] = value;
                observer = aliasedKey;
              }
              this[key] = value;
              if (attrName) {
                this.$attr[key] = attrName;
              } else {
                attrName = this.$attr[key];
                if (!attrName) {
                  this.$attr[key] = attrName = snake_case(key, '-');
                }
              }
              nodeName = nodeName_(this.$$element);
              if ((nodeName === 'a' && (key === 'href' || key === 'xlinkHref')) || (nodeName === 'img' && key === 'src')) {
                this[key] = value = $$sanitizeUri(value, key === 'src');
              } else if (nodeName === 'img' && key === 'srcset' && isDefined(value)) {
                var result = "";
                var trimmedSrcset = trim(value);
                var srcPattern = /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/;
                var pattern = /\s/.test(trimmedSrcset) ? srcPattern : /(,)/;
                var rawUris = trimmedSrcset.split(pattern);
                var nbrUrisWith2parts = Math.floor(rawUris.length / 2);
                for (var i = 0; i < nbrUrisWith2parts; i++) {
                  var innerIdx = i * 2;
                  result += $$sanitizeUri(trim(rawUris[innerIdx]), true);
                  result += (" " + trim(rawUris[innerIdx + 1]));
                }
                var lastTuple = trim(rawUris[i * 2]).split(/\s/);
                result += $$sanitizeUri(trim(lastTuple[0]), true);
                if (lastTuple.length === 2) {
                  result += (" " + trim(lastTuple[1]));
                }
                this[key] = value = result;
              }
              if (writeAttr !== false) {
                if (value === null || isUndefined(value)) {
                  this.$$element.removeAttr(attrName);
                } else {
                  if (SIMPLE_ATTR_NAME.test(attrName)) {
                    this.$$element.attr(attrName, value);
                  } else {
                    setSpecialAttr(this.$$element[0], attrName, value);
                  }
                }
              }
              var $$observers = this.$$observers;
              $$observers && forEach($$observers[observer], function(fn) {
                try {
                  fn(value);
                } catch (e) {
                  $exceptionHandler(e);
                }
              });
            },
            $observe: function(key, fn) {
              var attrs = this,
                  $$observers = (attrs.$$observers || (attrs.$$observers = createMap())),
                  listeners = ($$observers[key] || ($$observers[key] = []));
              listeners.push(fn);
              $rootScope.$evalAsync(function() {
                if (!listeners.$$inter && attrs.hasOwnProperty(key) && !isUndefined(attrs[key])) {
                  fn(attrs[key]);
                }
              });
              return function() {
                arrayRemove(listeners, fn);
              };
            }
          };
          function setSpecialAttr(element, attrName, value) {
            specialAttrHolder.innerHTML = "<span " + attrName + ">";
            var attributes = specialAttrHolder.firstChild.attributes;
            var attribute = attributes[0];
            attributes.removeNamedItem(attribute.name);
            attribute.value = value;
            element.attributes.setNamedItem(attribute);
          }
          function safeAddClass($element, className) {
            try {
              $element.addClass(className);
            } catch (e) {}
          }
          var startSymbol = $interpolate.startSymbol(),
              endSymbol = $interpolate.endSymbol(),
              denormalizeTemplate = (startSymbol == '{{' && endSymbol == '}}') ? identity : function denormalizeTemplate(template) {
                return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
              },
              NG_ATTR_BINDING = /^ngAttr[A-Z]/;
          var MULTI_ELEMENT_DIR_RE = /^(.+)Start$/;
          compile.$$addBindingInfo = debugInfoEnabled ? function $$addBindingInfo($element, binding) {
            var bindings = $element.data('$binding') || [];
            if (isArray(binding)) {
              bindings = bindings.concat(binding);
            } else {
              bindings.push(binding);
            }
            $element.data('$binding', bindings);
          } : noop;
          compile.$$addBindingClass = debugInfoEnabled ? function $$addBindingClass($element) {
            safeAddClass($element, 'ng-binding');
          } : noop;
          compile.$$addScopeInfo = debugInfoEnabled ? function $$addScopeInfo($element, scope, isolated, noTemplate) {
            var dataName = isolated ? (noTemplate ? '$isolateScopeNoTemplate' : '$isolateScope') : '$scope';
            $element.data(dataName, scope);
          } : noop;
          compile.$$addScopeClass = debugInfoEnabled ? function $$addScopeClass($element, isolated) {
            safeAddClass($element, isolated ? 'ng-isolate-scope' : 'ng-scope');
          } : noop;
          compile.$$createComment = function(directiveName, comment) {
            var content = '';
            if (debugInfoEnabled) {
              content = ' ' + (directiveName || '') + ': ';
              if (comment)
                content += comment + ' ';
            }
            return window.document.createComment(content);
          };
          return compile;
          function compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
            if (!($compileNodes instanceof jqLite)) {
              $compileNodes = jqLite($compileNodes);
            }
            var NOT_EMPTY = /\S+/;
            for (var i = 0,
                len = $compileNodes.length; i < len; i++) {
              var domNode = $compileNodes[i];
              if (domNode.nodeType === NODE_TYPE_TEXT && domNode.nodeValue.match(NOT_EMPTY)) {
                jqLiteWrapNode(domNode, $compileNodes[i] = window.document.createElement('span'));
              }
            }
            var compositeLinkFn = compileNodes($compileNodes, transcludeFn, $compileNodes, maxPriority, ignoreDirective, previousCompileContext);
            compile.$$addScopeClass($compileNodes);
            var namespace = null;
            return function publicLinkFn(scope, cloneConnectFn, options) {
              assertArg(scope, 'scope');
              if (previousCompileContext && previousCompileContext.needsNewScope) {
                scope = scope.$parent.$new();
              }
              options = options || {};
              var parentBoundTranscludeFn = options.parentBoundTranscludeFn,
                  transcludeControllers = options.transcludeControllers,
                  futureParentElement = options.futureParentElement;
              if (parentBoundTranscludeFn && parentBoundTranscludeFn.$$boundTransclude) {
                parentBoundTranscludeFn = parentBoundTranscludeFn.$$boundTransclude;
              }
              if (!namespace) {
                namespace = detectNamespaceForChildElements(futureParentElement);
              }
              var $linkNode;
              if (namespace !== 'html') {
                $linkNode = jqLite(wrapTemplate(namespace, jqLite('<div>').append($compileNodes).html()));
              } else if (cloneConnectFn) {
                $linkNode = JQLitePrototype.clone.call($compileNodes);
              } else {
                $linkNode = $compileNodes;
              }
              if (transcludeControllers) {
                for (var controllerName in transcludeControllers) {
                  $linkNode.data('$' + controllerName + 'Controller', transcludeControllers[controllerName].instance);
                }
              }
              compile.$$addScopeInfo($linkNode, scope);
              if (cloneConnectFn)
                cloneConnectFn($linkNode, scope);
              if (compositeLinkFn)
                compositeLinkFn(scope, $linkNode, $linkNode, parentBoundTranscludeFn);
              return $linkNode;
            };
          }
          function detectNamespaceForChildElements(parentElement) {
            var node = parentElement && parentElement[0];
            if (!node) {
              return 'html';
            } else {
              return nodeName_(node) !== 'foreignobject' && toString.call(node).match(/SVG/) ? 'svg' : 'html';
            }
          }
          function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective, previousCompileContext) {
            var linkFns = [],
                attrs,
                directives,
                nodeLinkFn,
                childNodes,
                childLinkFn,
                linkFnFound,
                nodeLinkFnFound;
            for (var i = 0; i < nodeList.length; i++) {
              attrs = new Attributes();
              directives = collectDirectives(nodeList[i], [], attrs, i === 0 ? maxPriority : undefined, ignoreDirective);
              nodeLinkFn = (directives.length) ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement, null, [], [], previousCompileContext) : null;
              if (nodeLinkFn && nodeLinkFn.scope) {
                compile.$$addScopeClass(attrs.$$element);
              }
              childLinkFn = (nodeLinkFn && nodeLinkFn.terminal || !(childNodes = nodeList[i].childNodes) || !childNodes.length) ? null : compileNodes(childNodes, nodeLinkFn ? ((nodeLinkFn.transcludeOnThisElement || !nodeLinkFn.templateOnThisElement) && nodeLinkFn.transclude) : transcludeFn);
              if (nodeLinkFn || childLinkFn) {
                linkFns.push(i, nodeLinkFn, childLinkFn);
                linkFnFound = true;
                nodeLinkFnFound = nodeLinkFnFound || nodeLinkFn;
              }
              previousCompileContext = null;
            }
            return linkFnFound ? compositeLinkFn : null;
            function compositeLinkFn(scope, nodeList, $rootElement, parentBoundTranscludeFn) {
              var nodeLinkFn,
                  childLinkFn,
                  node,
                  childScope,
                  i,
                  ii,
                  idx,
                  childBoundTranscludeFn;
              var stableNodeList;
              if (nodeLinkFnFound) {
                var nodeListLength = nodeList.length;
                stableNodeList = new Array(nodeListLength);
                for (i = 0; i < linkFns.length; i += 3) {
                  idx = linkFns[i];
                  stableNodeList[idx] = nodeList[idx];
                }
              } else {
                stableNodeList = nodeList;
              }
              for (i = 0, ii = linkFns.length; i < ii; ) {
                node = stableNodeList[linkFns[i++]];
                nodeLinkFn = linkFns[i++];
                childLinkFn = linkFns[i++];
                if (nodeLinkFn) {
                  if (nodeLinkFn.scope) {
                    childScope = scope.$new();
                    compile.$$addScopeInfo(jqLite(node), childScope);
                  } else {
                    childScope = scope;
                  }
                  if (nodeLinkFn.transcludeOnThisElement) {
                    childBoundTranscludeFn = createBoundTranscludeFn(scope, nodeLinkFn.transclude, parentBoundTranscludeFn);
                  } else if (!nodeLinkFn.templateOnThisElement && parentBoundTranscludeFn) {
                    childBoundTranscludeFn = parentBoundTranscludeFn;
                  } else if (!parentBoundTranscludeFn && transcludeFn) {
                    childBoundTranscludeFn = createBoundTranscludeFn(scope, transcludeFn);
                  } else {
                    childBoundTranscludeFn = null;
                  }
                  nodeLinkFn(childLinkFn, childScope, node, $rootElement, childBoundTranscludeFn);
                } else if (childLinkFn) {
                  childLinkFn(scope, node.childNodes, undefined, parentBoundTranscludeFn);
                }
              }
            }
          }
          function createBoundTranscludeFn(scope, transcludeFn, previousBoundTranscludeFn) {
            function boundTranscludeFn(transcludedScope, cloneFn, controllers, futureParentElement, containingScope) {
              if (!transcludedScope) {
                transcludedScope = scope.$new(false, containingScope);
                transcludedScope.$$transcluded = true;
              }
              return transcludeFn(transcludedScope, cloneFn, {
                parentBoundTranscludeFn: previousBoundTranscludeFn,
                transcludeControllers: controllers,
                futureParentElement: futureParentElement
              });
            }
            var boundSlots = boundTranscludeFn.$$slots = createMap();
            for (var slotName in transcludeFn.$$slots) {
              if (transcludeFn.$$slots[slotName]) {
                boundSlots[slotName] = createBoundTranscludeFn(scope, transcludeFn.$$slots[slotName], previousBoundTranscludeFn);
              } else {
                boundSlots[slotName] = null;
              }
            }
            return boundTranscludeFn;
          }
          function collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
            var nodeType = node.nodeType,
                attrsMap = attrs.$attr,
                match,
                className;
            switch (nodeType) {
              case NODE_TYPE_ELEMENT:
                addDirective(directives, directiveNormalize(nodeName_(node)), 'E', maxPriority, ignoreDirective);
                for (var attr,
                    name,
                    nName,
                    ngAttrName,
                    value,
                    isNgAttr,
                    nAttrs = node.attributes,
                    j = 0,
                    jj = nAttrs && nAttrs.length; j < jj; j++) {
                  var attrStartName = false;
                  var attrEndName = false;
                  attr = nAttrs[j];
                  name = attr.name;
                  value = trim(attr.value);
                  ngAttrName = directiveNormalize(name);
                  if (isNgAttr = NG_ATTR_BINDING.test(ngAttrName)) {
                    name = name.replace(PREFIX_REGEXP, '').substr(8).replace(/_(.)/g, function(match, letter) {
                      return letter.toUpperCase();
                    });
                  }
                  var multiElementMatch = ngAttrName.match(MULTI_ELEMENT_DIR_RE);
                  if (multiElementMatch && directiveIsMultiElement(multiElementMatch[1])) {
                    attrStartName = name;
                    attrEndName = name.substr(0, name.length - 5) + 'end';
                    name = name.substr(0, name.length - 6);
                  }
                  nName = directiveNormalize(name.toLowerCase());
                  attrsMap[nName] = name;
                  if (isNgAttr || !attrs.hasOwnProperty(nName)) {
                    attrs[nName] = value;
                    if (getBooleanAttrName(node, nName)) {
                      attrs[nName] = true;
                    }
                  }
                  addAttrInterpolateDirective(node, directives, value, nName, isNgAttr);
                  addDirective(directives, nName, 'A', maxPriority, ignoreDirective, attrStartName, attrEndName);
                }
                className = node.className;
                if (isObject(className)) {
                  className = className.animVal;
                }
                if (isString(className) && className !== '') {
                  while (match = CLASS_DIRECTIVE_REGEXP.exec(className)) {
                    nName = directiveNormalize(match[2]);
                    if (addDirective(directives, nName, 'C', maxPriority, ignoreDirective)) {
                      attrs[nName] = trim(match[3]);
                    }
                    className = className.substr(match.index + match[0].length);
                  }
                }
                break;
              case NODE_TYPE_TEXT:
                if (msie === 11) {
                  while (node.parentNode && node.nextSibling && node.nextSibling.nodeType === NODE_TYPE_TEXT) {
                    node.nodeValue = node.nodeValue + node.nextSibling.nodeValue;
                    node.parentNode.removeChild(node.nextSibling);
                  }
                }
                addTextInterpolateDirective(directives, node.nodeValue);
                break;
              case NODE_TYPE_COMMENT:
                try {
                  match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);
                  if (match) {
                    nName = directiveNormalize(match[1]);
                    if (addDirective(directives, nName, 'M', maxPriority, ignoreDirective)) {
                      attrs[nName] = trim(match[2]);
                    }
                  }
                } catch (e) {}
                break;
            }
            directives.sort(byPriority);
            return directives;
          }
          function groupScan(node, attrStart, attrEnd) {
            var nodes = [];
            var depth = 0;
            if (attrStart && node.hasAttribute && node.hasAttribute(attrStart)) {
              do {
                if (!node) {
                  throw $compileMinErr('uterdir', "Unterminated attribute, found '{0}' but no matching '{1}' found.", attrStart, attrEnd);
                }
                if (node.nodeType == NODE_TYPE_ELEMENT) {
                  if (node.hasAttribute(attrStart))
                    depth++;
                  if (node.hasAttribute(attrEnd))
                    depth--;
                }
                nodes.push(node);
                node = node.nextSibling;
              } while (depth > 0);
            } else {
              nodes.push(node);
            }
            return jqLite(nodes);
          }
          function groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {
            return function groupedElementsLink(scope, element, attrs, controllers, transcludeFn) {
              element = groupScan(element[0], attrStart, attrEnd);
              return linkFn(scope, element, attrs, controllers, transcludeFn);
            };
          }
          function compilationGenerator(eager, $compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
            var compiled;
            if (eager) {
              return compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext);
            }
            return function lazyCompilation() {
              if (!compiled) {
                compiled = compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext);
                $compileNodes = transcludeFn = previousCompileContext = null;
              }
              return compiled.apply(this, arguments);
            };
          }
          function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn, jqCollection, originalReplaceDirective, preLinkFns, postLinkFns, previousCompileContext) {
            previousCompileContext = previousCompileContext || {};
            var terminalPriority = -Number.MAX_VALUE,
                newScopeDirective = previousCompileContext.newScopeDirective,
                controllerDirectives = previousCompileContext.controllerDirectives,
                newIsolateScopeDirective = previousCompileContext.newIsolateScopeDirective,
                templateDirective = previousCompileContext.templateDirective,
                nonTlbTranscludeDirective = previousCompileContext.nonTlbTranscludeDirective,
                hasTranscludeDirective = false,
                hasTemplate = false,
                hasElementTranscludeDirective = previousCompileContext.hasElementTranscludeDirective,
                $compileNode = templateAttrs.$$element = jqLite(compileNode),
                directive,
                directiveName,
                $template,
                replaceDirective = originalReplaceDirective,
                childTranscludeFn = transcludeFn,
                linkFn,
                didScanForMultipleTransclusion = false,
                mightHaveMultipleTransclusionError = false,
                directiveValue;
            for (var i = 0,
                ii = directives.length; i < ii; i++) {
              directive = directives[i];
              var attrStart = directive.$$start;
              var attrEnd = directive.$$end;
              if (attrStart) {
                $compileNode = groupScan(compileNode, attrStart, attrEnd);
              }
              $template = undefined;
              if (terminalPriority > directive.priority) {
                break;
              }
              if (directiveValue = directive.scope) {
                if (!directive.templateUrl) {
                  if (isObject(directiveValue)) {
                    assertNoDuplicate('new/isolated scope', newIsolateScopeDirective || newScopeDirective, directive, $compileNode);
                    newIsolateScopeDirective = directive;
                  } else {
                    assertNoDuplicate('new/isolated scope', newIsolateScopeDirective, directive, $compileNode);
                  }
                }
                newScopeDirective = newScopeDirective || directive;
              }
              directiveName = directive.name;
              if (!didScanForMultipleTransclusion && ((directive.replace && (directive.templateUrl || directive.template)) || (directive.transclude && !directive.$$tlb))) {
                var candidateDirective;
                for (var scanningIndex = i + 1; candidateDirective = directives[scanningIndex++]; ) {
                  if ((candidateDirective.transclude && !candidateDirective.$$tlb) || (candidateDirective.replace && (candidateDirective.templateUrl || candidateDirective.template))) {
                    mightHaveMultipleTransclusionError = true;
                    break;
                  }
                }
                didScanForMultipleTransclusion = true;
              }
              if (!directive.templateUrl && directive.controller) {
                directiveValue = directive.controller;
                controllerDirectives = controllerDirectives || createMap();
                assertNoDuplicate("'" + directiveName + "' controller", controllerDirectives[directiveName], directive, $compileNode);
                controllerDirectives[directiveName] = directive;
              }
              if (directiveValue = directive.transclude) {
                hasTranscludeDirective = true;
                if (!directive.$$tlb) {
                  assertNoDuplicate('transclusion', nonTlbTranscludeDirective, directive, $compileNode);
                  nonTlbTranscludeDirective = directive;
                }
                if (directiveValue == 'element') {
                  hasElementTranscludeDirective = true;
                  terminalPriority = directive.priority;
                  $template = $compileNode;
                  $compileNode = templateAttrs.$$element = jqLite(compile.$$createComment(directiveName, templateAttrs[directiveName]));
                  compileNode = $compileNode[0];
                  replaceWith(jqCollection, sliceArgs($template), compileNode);
                  $template[0].$$parentNode = $template[0].parentNode;
                  childTranscludeFn = compilationGenerator(mightHaveMultipleTransclusionError, $template, transcludeFn, terminalPriority, replaceDirective && replaceDirective.name, {nonTlbTranscludeDirective: nonTlbTranscludeDirective});
                } else {
                  var slots = createMap();
                  $template = jqLite(jqLiteClone(compileNode)).contents();
                  if (isObject(directiveValue)) {
                    $template = [];
                    var slotMap = createMap();
                    var filledSlots = createMap();
                    forEach(directiveValue, function(elementSelector, slotName) {
                      var optional = (elementSelector.charAt(0) === '?');
                      elementSelector = optional ? elementSelector.substring(1) : elementSelector;
                      slotMap[elementSelector] = slotName;
                      slots[slotName] = null;
                      filledSlots[slotName] = optional;
                    });
                    forEach($compileNode.contents(), function(node) {
                      var slotName = slotMap[directiveNormalize(nodeName_(node))];
                      if (slotName) {
                        filledSlots[slotName] = true;
                        slots[slotName] = slots[slotName] || [];
                        slots[slotName].push(node);
                      } else {
                        $template.push(node);
                      }
                    });
                    forEach(filledSlots, function(filled, slotName) {
                      if (!filled) {
                        throw $compileMinErr('reqslot', 'Required transclusion slot `{0}` was not filled.', slotName);
                      }
                    });
                    for (var slotName in slots) {
                      if (slots[slotName]) {
                        slots[slotName] = compilationGenerator(mightHaveMultipleTransclusionError, slots[slotName], transcludeFn);
                      }
                    }
                  }
                  $compileNode.empty();
                  childTranscludeFn = compilationGenerator(mightHaveMultipleTransclusionError, $template, transcludeFn, undefined, undefined, {needsNewScope: directive.$$isolateScope || directive.$$newScope});
                  childTranscludeFn.$$slots = slots;
                }
              }
              if (directive.template) {
                hasTemplate = true;
                assertNoDuplicate('template', templateDirective, directive, $compileNode);
                templateDirective = directive;
                directiveValue = (isFunction(directive.template)) ? directive.template($compileNode, templateAttrs) : directive.template;
                directiveValue = denormalizeTemplate(directiveValue);
                if (directive.replace) {
                  replaceDirective = directive;
                  if (jqLiteIsTextNode(directiveValue)) {
                    $template = [];
                  } else {
                    $template = removeComments(wrapTemplate(directive.templateNamespace, trim(directiveValue)));
                  }
                  compileNode = $template[0];
                  if ($template.length != 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
                    throw $compileMinErr('tplrt', "Template for directive '{0}' must have exactly one root element. {1}", directiveName, '');
                  }
                  replaceWith(jqCollection, $compileNode, compileNode);
                  var newTemplateAttrs = {$attr: {}};
                  var templateDirectives = collectDirectives(compileNode, [], newTemplateAttrs);
                  var unprocessedDirectives = directives.splice(i + 1, directives.length - (i + 1));
                  if (newIsolateScopeDirective || newScopeDirective) {
                    markDirectiveScope(templateDirectives, newIsolateScopeDirective, newScopeDirective);
                  }
                  directives = directives.concat(templateDirectives).concat(unprocessedDirectives);
                  mergeTemplateAttributes(templateAttrs, newTemplateAttrs);
                  ii = directives.length;
                } else {
                  $compileNode.html(directiveValue);
                }
              }
              if (directive.templateUrl) {
                hasTemplate = true;
                assertNoDuplicate('template', templateDirective, directive, $compileNode);
                templateDirective = directive;
                if (directive.replace) {
                  replaceDirective = directive;
                }
                nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i), $compileNode, templateAttrs, jqCollection, hasTranscludeDirective && childTranscludeFn, preLinkFns, postLinkFns, {
                  controllerDirectives: controllerDirectives,
                  newScopeDirective: (newScopeDirective !== directive) && newScopeDirective,
                  newIsolateScopeDirective: newIsolateScopeDirective,
                  templateDirective: templateDirective,
                  nonTlbTranscludeDirective: nonTlbTranscludeDirective
                });
                ii = directives.length;
              } else if (directive.compile) {
                try {
                  linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn);
                  var context = directive.$$originalDirective || directive;
                  if (isFunction(linkFn)) {
                    addLinkFns(null, bind(context, linkFn), attrStart, attrEnd);
                  } else if (linkFn) {
                    addLinkFns(bind(context, linkFn.pre), bind(context, linkFn.post), attrStart, attrEnd);
                  }
                } catch (e) {
                  $exceptionHandler(e, startingTag($compileNode));
                }
              }
              if (directive.terminal) {
                nodeLinkFn.terminal = true;
                terminalPriority = Math.max(terminalPriority, directive.priority);
              }
            }
            nodeLinkFn.scope = newScopeDirective && newScopeDirective.scope === true;
            nodeLinkFn.transcludeOnThisElement = hasTranscludeDirective;
            nodeLinkFn.templateOnThisElement = hasTemplate;
            nodeLinkFn.transclude = childTranscludeFn;
            previousCompileContext.hasElementTranscludeDirective = hasElementTranscludeDirective;
            return nodeLinkFn;
            function addLinkFns(pre, post, attrStart, attrEnd) {
              if (pre) {
                if (attrStart)
                  pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd);
                pre.require = directive.require;
                pre.directiveName = directiveName;
                if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                  pre = cloneAndAnnotateFn(pre, {isolateScope: true});
                }
                preLinkFns.push(pre);
              }
              if (post) {
                if (attrStart)
                  post = groupElementsLinkFnWrapper(post, attrStart, attrEnd);
                post.require = directive.require;
                post.directiveName = directiveName;
                if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                  post = cloneAndAnnotateFn(post, {isolateScope: true});
                }
                postLinkFns.push(post);
              }
            }
            function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn) {
              var i,
                  ii,
                  linkFn,
                  isolateScope,
                  controllerScope,
                  elementControllers,
                  transcludeFn,
                  $element,
                  attrs,
                  scopeBindingInfo;
              if (compileNode === linkNode) {
                attrs = templateAttrs;
                $element = templateAttrs.$$element;
              } else {
                $element = jqLite(linkNode);
                attrs = new Attributes($element, templateAttrs);
              }
              controllerScope = scope;
              if (newIsolateScopeDirective) {
                isolateScope = scope.$new(true);
              } else if (newScopeDirective) {
                controllerScope = scope.$parent;
              }
              if (boundTranscludeFn) {
                transcludeFn = controllersBoundTransclude;
                transcludeFn.$$boundTransclude = boundTranscludeFn;
                transcludeFn.isSlotFilled = function(slotName) {
                  return !!boundTranscludeFn.$$slots[slotName];
                };
              }
              if (controllerDirectives) {
                elementControllers = setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope, newIsolateScopeDirective);
              }
              if (newIsolateScopeDirective) {
                compile.$$addScopeInfo($element, isolateScope, true, !(templateDirective && (templateDirective === newIsolateScopeDirective || templateDirective === newIsolateScopeDirective.$$originalDirective)));
                compile.$$addScopeClass($element, true);
                isolateScope.$$isolateBindings = newIsolateScopeDirective.$$isolateBindings;
                scopeBindingInfo = initializeDirectiveBindings(scope, attrs, isolateScope, isolateScope.$$isolateBindings, newIsolateScopeDirective);
                if (scopeBindingInfo.removeWatches) {
                  isolateScope.$on('$destroy', scopeBindingInfo.removeWatches);
                }
              }
              for (var name in elementControllers) {
                var controllerDirective = controllerDirectives[name];
                var controller = elementControllers[name];
                var bindings = controllerDirective.$$bindings.bindToController;
                if (controller.identifier && bindings) {
                  controller.bindingInfo = initializeDirectiveBindings(controllerScope, attrs, controller.instance, bindings, controllerDirective);
                } else {
                  controller.bindingInfo = {};
                }
                var controllerResult = controller();
                if (controllerResult !== controller.instance) {
                  controller.instance = controllerResult;
                  $element.data('$' + controllerDirective.name + 'Controller', controllerResult);
                  controller.bindingInfo.removeWatches && controller.bindingInfo.removeWatches();
                  controller.bindingInfo = initializeDirectiveBindings(controllerScope, attrs, controller.instance, bindings, controllerDirective);
                }
              }
              forEach(controllerDirectives, function(controllerDirective, name) {
                var require = controllerDirective.require;
                if (controllerDirective.bindToController && !isArray(require) && isObject(require)) {
                  extend(elementControllers[name].instance, getControllers(name, require, $element, elementControllers));
                }
              });
              forEach(elementControllers, function(controller) {
                var controllerInstance = controller.instance;
                if (isFunction(controllerInstance.$onChanges)) {
                  try {
                    controllerInstance.$onChanges(controller.bindingInfo.initialChanges);
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                }
                if (isFunction(controllerInstance.$onInit)) {
                  try {
                    controllerInstance.$onInit();
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                }
                if (isFunction(controllerInstance.$onDestroy)) {
                  controllerScope.$on('$destroy', function callOnDestroyHook() {
                    controllerInstance.$onDestroy();
                  });
                }
              });
              for (i = 0, ii = preLinkFns.length; i < ii; i++) {
                linkFn = preLinkFns[i];
                invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
              }
              var scopeToChild = scope;
              if (newIsolateScopeDirective && (newIsolateScopeDirective.template || newIsolateScopeDirective.templateUrl === null)) {
                scopeToChild = isolateScope;
              }
              childLinkFn && childLinkFn(scopeToChild, linkNode.childNodes, undefined, boundTranscludeFn);
              for (i = postLinkFns.length - 1; i >= 0; i--) {
                linkFn = postLinkFns[i];
                invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
              }
              forEach(elementControllers, function(controller) {
                var controllerInstance = controller.instance;
                if (isFunction(controllerInstance.$postLink)) {
                  controllerInstance.$postLink();
                }
              });
              function controllersBoundTransclude(scope, cloneAttachFn, futureParentElement, slotName) {
                var transcludeControllers;
                if (!isScope(scope)) {
                  slotName = futureParentElement;
                  futureParentElement = cloneAttachFn;
                  cloneAttachFn = scope;
                  scope = undefined;
                }
                if (hasElementTranscludeDirective) {
                  transcludeControllers = elementControllers;
                }
                if (!futureParentElement) {
                  futureParentElement = hasElementTranscludeDirective ? $element.parent() : $element;
                }
                if (slotName) {
                  var slotTranscludeFn = boundTranscludeFn.$$slots[slotName];
                  if (slotTranscludeFn) {
                    return slotTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
                  } else if (isUndefined(slotTranscludeFn)) {
                    throw $compileMinErr('noslot', 'No parent directive that requires a transclusion with slot name "{0}". ' + 'Element: {1}', slotName, startingTag($element));
                  }
                } else {
                  return boundTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
                }
              }
            }
          }
          function getControllers(directiveName, require, $element, elementControllers) {
            var value;
            if (isString(require)) {
              var match = require.match(REQUIRE_PREFIX_REGEXP);
              var name = require.substring(match[0].length);
              var inheritType = match[1] || match[3];
              var optional = match[2] === '?';
              if (inheritType === '^^') {
                $element = $element.parent();
              } else {
                value = elementControllers && elementControllers[name];
                value = value && value.instance;
              }
              if (!value) {
                var dataName = '$' + name + 'Controller';
                value = inheritType ? $element.inheritedData(dataName) : $element.data(dataName);
              }
              if (!value && !optional) {
                throw $compileMinErr('ctreq', "Controller '{0}', required by directive '{1}', can't be found!", name, directiveName);
              }
            } else if (isArray(require)) {
              value = [];
              for (var i = 0,
                  ii = require.length; i < ii; i++) {
                value[i] = getControllers(directiveName, require[i], $element, elementControllers);
              }
            } else if (isObject(require)) {
              value = {};
              forEach(require, function(controller, property) {
                value[property] = getControllers(directiveName, controller, $element, elementControllers);
              });
            }
            return value || null;
          }
          function setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope, newIsolateScopeDirective) {
            var elementControllers = createMap();
            for (var controllerKey in controllerDirectives) {
              var directive = controllerDirectives[controllerKey];
              var locals = {
                $scope: directive === newIsolateScopeDirective || directive.$$isolateScope ? isolateScope : scope,
                $element: $element,
                $attrs: attrs,
                $transclude: transcludeFn
              };
              var controller = directive.controller;
              if (controller == '@') {
                controller = attrs[directive.name];
              }
              var controllerInstance = $controller(controller, locals, true, directive.controllerAs);
              elementControllers[directive.name] = controllerInstance;
              $element.data('$' + directive.name + 'Controller', controllerInstance.instance);
            }
            return elementControllers;
          }
          function markDirectiveScope(directives, isolateScope, newScope) {
            for (var j = 0,
                jj = directives.length; j < jj; j++) {
              directives[j] = inherit(directives[j], {
                $$isolateScope: isolateScope,
                $$newScope: newScope
              });
            }
          }
          function addDirective(tDirectives, name, location, maxPriority, ignoreDirective, startAttrName, endAttrName) {
            if (name === ignoreDirective)
              return null;
            var match = null;
            if (hasDirectives.hasOwnProperty(name)) {
              for (var directive,
                  directives = $injector.get(name + Suffix),
                  i = 0,
                  ii = directives.length; i < ii; i++) {
                try {
                  directive = directives[i];
                  if ((isUndefined(maxPriority) || maxPriority > directive.priority) && directive.restrict.indexOf(location) != -1) {
                    if (startAttrName) {
                      directive = inherit(directive, {
                        $$start: startAttrName,
                        $$end: endAttrName
                      });
                    }
                    if (!directive.$$bindings) {
                      var bindings = directive.$$bindings = parseDirectiveBindings(directive, directive.name);
                      if (isObject(bindings.isolateScope)) {
                        directive.$$isolateBindings = bindings.isolateScope;
                      }
                    }
                    tDirectives.push(directive);
                    match = directive;
                  }
                } catch (e) {
                  $exceptionHandler(e);
                }
              }
            }
            return match;
          }
          function directiveIsMultiElement(name) {
            if (hasDirectives.hasOwnProperty(name)) {
              for (var directive,
                  directives = $injector.get(name + Suffix),
                  i = 0,
                  ii = directives.length; i < ii; i++) {
                directive = directives[i];
                if (directive.multiElement) {
                  return true;
                }
              }
            }
            return false;
          }
          function mergeTemplateAttributes(dst, src) {
            var srcAttr = src.$attr,
                dstAttr = dst.$attr,
                $element = dst.$$element;
            forEach(dst, function(value, key) {
              if (key.charAt(0) != '$') {
                if (src[key] && src[key] !== value) {
                  value += (key === 'style' ? ';' : ' ') + src[key];
                }
                dst.$set(key, value, true, srcAttr[key]);
              }
            });
            forEach(src, function(value, key) {
              if (!dst.hasOwnProperty(key) && key.charAt(0) !== '$') {
                dst[key] = value;
                if (key !== 'class' && key !== 'style') {
                  dstAttr[key] = srcAttr[key];
                }
              }
            });
          }
          function compileTemplateUrl(directives, $compileNode, tAttrs, $rootElement, childTranscludeFn, preLinkFns, postLinkFns, previousCompileContext) {
            var linkQueue = [],
                afterTemplateNodeLinkFn,
                afterTemplateChildLinkFn,
                beforeTemplateCompileNode = $compileNode[0],
                origAsyncDirective = directives.shift(),
                derivedSyncDirective = inherit(origAsyncDirective, {
                  templateUrl: null,
                  transclude: null,
                  replace: null,
                  $$originalDirective: origAsyncDirective
                }),
                templateUrl = (isFunction(origAsyncDirective.templateUrl)) ? origAsyncDirective.templateUrl($compileNode, tAttrs) : origAsyncDirective.templateUrl,
                templateNamespace = origAsyncDirective.templateNamespace;
            $compileNode.empty();
            $templateRequest(templateUrl).then(function(content) {
              var compileNode,
                  tempTemplateAttrs,
                  $template,
                  childBoundTranscludeFn;
              content = denormalizeTemplate(content);
              if (origAsyncDirective.replace) {
                if (jqLiteIsTextNode(content)) {
                  $template = [];
                } else {
                  $template = removeComments(wrapTemplate(templateNamespace, trim(content)));
                }
                compileNode = $template[0];
                if ($template.length != 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
                  throw $compileMinErr('tplrt', "Template for directive '{0}' must have exactly one root element. {1}", origAsyncDirective.name, templateUrl);
                }
                tempTemplateAttrs = {$attr: {}};
                replaceWith($rootElement, $compileNode, compileNode);
                var templateDirectives = collectDirectives(compileNode, [], tempTemplateAttrs);
                if (isObject(origAsyncDirective.scope)) {
                  markDirectiveScope(templateDirectives, true);
                }
                directives = templateDirectives.concat(directives);
                mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
              } else {
                compileNode = beforeTemplateCompileNode;
                $compileNode.html(content);
              }
              directives.unshift(derivedSyncDirective);
              afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs, childTranscludeFn, $compileNode, origAsyncDirective, preLinkFns, postLinkFns, previousCompileContext);
              forEach($rootElement, function(node, i) {
                if (node == compileNode) {
                  $rootElement[i] = $compileNode[0];
                }
              });
              afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn);
              while (linkQueue.length) {
                var scope = linkQueue.shift(),
                    beforeTemplateLinkNode = linkQueue.shift(),
                    linkRootElement = linkQueue.shift(),
                    boundTranscludeFn = linkQueue.shift(),
                    linkNode = $compileNode[0];
                if (scope.$$destroyed)
                  continue;
                if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
                  var oldClasses = beforeTemplateLinkNode.className;
                  if (!(previousCompileContext.hasElementTranscludeDirective && origAsyncDirective.replace)) {
                    linkNode = jqLiteClone(compileNode);
                  }
                  replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode);
                  safeAddClass(jqLite(linkNode), oldClasses);
                }
                if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                  childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
                } else {
                  childBoundTranscludeFn = boundTranscludeFn;
                }
                afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement, childBoundTranscludeFn);
              }
              linkQueue = null;
            });
            return function delayedNodeLinkFn(ignoreChildLinkFn, scope, node, rootElement, boundTranscludeFn) {
              var childBoundTranscludeFn = boundTranscludeFn;
              if (scope.$$destroyed)
                return;
              if (linkQueue) {
                linkQueue.push(scope, node, rootElement, childBoundTranscludeFn);
              } else {
                if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                  childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
                }
                afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, childBoundTranscludeFn);
              }
            };
          }
          function byPriority(a, b) {
            var diff = b.priority - a.priority;
            if (diff !== 0)
              return diff;
            if (a.name !== b.name)
              return (a.name < b.name) ? -1 : 1;
            return a.index - b.index;
          }
          function assertNoDuplicate(what, previousDirective, directive, element) {
            function wrapModuleNameIfDefined(moduleName) {
              return moduleName ? (' (module: ' + moduleName + ')') : '';
            }
            if (previousDirective) {
              throw $compileMinErr('multidir', 'Multiple directives [{0}{1}, {2}{3}] asking for {4} on: {5}', previousDirective.name, wrapModuleNameIfDefined(previousDirective.$$moduleName), directive.name, wrapModuleNameIfDefined(directive.$$moduleName), what, startingTag(element));
            }
          }
          function addTextInterpolateDirective(directives, text) {
            var interpolateFn = $interpolate(text, true);
            if (interpolateFn) {
              directives.push({
                priority: 0,
                compile: function textInterpolateCompileFn(templateNode) {
                  var templateNodeParent = templateNode.parent(),
                      hasCompileParent = !!templateNodeParent.length;
                  if (hasCompileParent)
                    compile.$$addBindingClass(templateNodeParent);
                  return function textInterpolateLinkFn(scope, node) {
                    var parent = node.parent();
                    if (!hasCompileParent)
                      compile.$$addBindingClass(parent);
                    compile.$$addBindingInfo(parent, interpolateFn.expressions);
                    scope.$watch(interpolateFn, function interpolateFnWatchAction(value) {
                      node[0].nodeValue = value;
                    });
                  };
                }
              });
            }
          }
          function wrapTemplate(type, template) {
            type = lowercase(type || 'html');
            switch (type) {
              case 'svg':
              case 'math':
                var wrapper = window.document.createElement('div');
                wrapper.innerHTML = '<' + type + '>' + template + '</' + type + '>';
                return wrapper.childNodes[0].childNodes;
              default:
                return template;
            }
          }
          function getTrustedContext(node, attrNormalizedName) {
            if (attrNormalizedName == "srcdoc") {
              return $sce.HTML;
            }
            var tag = nodeName_(node);
            if (attrNormalizedName == "xlinkHref" || (tag == "form" && attrNormalizedName == "action") || (tag != "img" && (attrNormalizedName == "src" || attrNormalizedName == "ngSrc"))) {
              return $sce.RESOURCE_URL;
            }
          }
          function addAttrInterpolateDirective(node, directives, value, name, allOrNothing) {
            var trustedContext = getTrustedContext(node, name);
            allOrNothing = ALL_OR_NOTHING_ATTRS[name] || allOrNothing;
            var interpolateFn = $interpolate(value, true, trustedContext, allOrNothing);
            if (!interpolateFn)
              return;
            if (name === "multiple" && nodeName_(node) === "select") {
              throw $compileMinErr("selmulti", "Binding to the 'multiple' attribute is not supported. Element: {0}", startingTag(node));
            }
            directives.push({
              priority: 100,
              compile: function() {
                return {pre: function attrInterpolatePreLinkFn(scope, element, attr) {
                    var $$observers = (attr.$$observers || (attr.$$observers = createMap()));
                    if (EVENT_HANDLER_ATTR_REGEXP.test(name)) {
                      throw $compileMinErr('nodomevents', "Interpolations for HTML DOM event attributes are disallowed.  Please use the " + "ng- versions (such as ng-click instead of onclick) instead.");
                    }
                    var newValue = attr[name];
                    if (newValue !== value) {
                      interpolateFn = newValue && $interpolate(newValue, true, trustedContext, allOrNothing);
                      value = newValue;
                    }
                    if (!interpolateFn)
                      return;
                    attr[name] = interpolateFn(scope);
                    ($$observers[name] || ($$observers[name] = [])).$$inter = true;
                    (attr.$$observers && attr.$$observers[name].$$scope || scope).$watch(interpolateFn, function interpolateFnWatchAction(newValue, oldValue) {
                      if (name === 'class' && newValue != oldValue) {
                        attr.$updateClass(newValue, oldValue);
                      } else {
                        attr.$set(name, newValue);
                      }
                    });
                  }};
              }
            });
          }
          function replaceWith($rootElement, elementsToRemove, newNode) {
            var firstElementToRemove = elementsToRemove[0],
                removeCount = elementsToRemove.length,
                parent = firstElementToRemove.parentNode,
                i,
                ii;
            if ($rootElement) {
              for (i = 0, ii = $rootElement.length; i < ii; i++) {
                if ($rootElement[i] == firstElementToRemove) {
                  $rootElement[i++] = newNode;
                  for (var j = i,
                      j2 = j + removeCount - 1,
                      jj = $rootElement.length; j < jj; j++, j2++) {
                    if (j2 < jj) {
                      $rootElement[j] = $rootElement[j2];
                    } else {
                      delete $rootElement[j];
                    }
                  }
                  $rootElement.length -= removeCount - 1;
                  if ($rootElement.context === firstElementToRemove) {
                    $rootElement.context = newNode;
                  }
                  break;
                }
              }
            }
            if (parent) {
              parent.replaceChild(newNode, firstElementToRemove);
            }
            var fragment = window.document.createDocumentFragment();
            for (i = 0; i < removeCount; i++) {
              fragment.appendChild(elementsToRemove[i]);
            }
            if (jqLite.hasData(firstElementToRemove)) {
              jqLite.data(newNode, jqLite.data(firstElementToRemove));
              jqLite(firstElementToRemove).off('$destroy');
            }
            jqLite.cleanData(fragment.querySelectorAll('*'));
            for (i = 1; i < removeCount; i++) {
              delete elementsToRemove[i];
            }
            elementsToRemove[0] = newNode;
            elementsToRemove.length = 1;
          }
          function cloneAndAnnotateFn(fn, annotation) {
            return extend(function() {
              return fn.apply(null, arguments);
            }, fn, annotation);
          }
          function invokeLinkFn(linkFn, scope, $element, attrs, controllers, transcludeFn) {
            try {
              linkFn(scope, $element, attrs, controllers, transcludeFn);
            } catch (e) {
              $exceptionHandler(e, startingTag($element));
            }
          }
          function initializeDirectiveBindings(scope, attrs, destination, bindings, directive) {
            var removeWatchCollection = [];
            var initialChanges = {};
            var changes;
            forEach(bindings, function initializeBinding(definition, scopeName) {
              var attrName = definition.attrName,
                  optional = definition.optional,
                  mode = definition.mode,
                  lastValue,
                  parentGet,
                  parentSet,
                  compare,
                  removeWatch;
              switch (mode) {
                case '@':
                  if (!optional && !hasOwnProperty.call(attrs, attrName)) {
                    destination[scopeName] = attrs[attrName] = void 0;
                  }
                  attrs.$observe(attrName, function(value) {
                    if (isString(value) || isBoolean(value)) {
                      var oldValue = destination[scopeName];
                      recordChanges(scopeName, value, oldValue);
                      destination[scopeName] = value;
                    }
                  });
                  attrs.$$observers[attrName].$$scope = scope;
                  lastValue = attrs[attrName];
                  if (isString(lastValue)) {
                    destination[scopeName] = $interpolate(lastValue)(scope);
                  } else if (isBoolean(lastValue)) {
                    destination[scopeName] = lastValue;
                  }
                  initialChanges[scopeName] = new SimpleChange(_UNINITIALIZED_VALUE, destination[scopeName]);
                  break;
                case '=':
                  if (!hasOwnProperty.call(attrs, attrName)) {
                    if (optional)
                      break;
                    attrs[attrName] = void 0;
                  }
                  if (optional && !attrs[attrName])
                    break;
                  parentGet = $parse(attrs[attrName]);
                  if (parentGet.literal) {
                    compare = equals;
                  } else {
                    compare = function simpleCompare(a, b) {
                      return a === b || (a !== a && b !== b);
                    };
                  }
                  parentSet = parentGet.assign || function() {
                    lastValue = destination[scopeName] = parentGet(scope);
                    throw $compileMinErr('nonassign', "Expression '{0}' in attribute '{1}' used with directive '{2}' is non-assignable!", attrs[attrName], attrName, directive.name);
                  };
                  lastValue = destination[scopeName] = parentGet(scope);
                  var parentValueWatch = function parentValueWatch(parentValue) {
                    if (!compare(parentValue, destination[scopeName])) {
                      if (!compare(parentValue, lastValue)) {
                        destination[scopeName] = parentValue;
                      } else {
                        parentSet(scope, parentValue = destination[scopeName]);
                      }
                    }
                    return lastValue = parentValue;
                  };
                  parentValueWatch.$stateful = true;
                  if (definition.collection) {
                    removeWatch = scope.$watchCollection(attrs[attrName], parentValueWatch);
                  } else {
                    removeWatch = scope.$watch($parse(attrs[attrName], parentValueWatch), null, parentGet.literal);
                  }
                  removeWatchCollection.push(removeWatch);
                  break;
                case '<':
                  if (!hasOwnProperty.call(attrs, attrName)) {
                    if (optional)
                      break;
                    attrs[attrName] = void 0;
                  }
                  if (optional && !attrs[attrName])
                    break;
                  parentGet = $parse(attrs[attrName]);
                  var initialValue = destination[scopeName] = parentGet(scope);
                  initialChanges[scopeName] = new SimpleChange(_UNINITIALIZED_VALUE, destination[scopeName]);
                  removeWatch = scope.$watch(parentGet, function parentValueWatchAction(newValue, oldValue) {
                    if (oldValue === newValue) {
                      if (oldValue === initialValue)
                        return;
                      oldValue = initialValue;
                    }
                    recordChanges(scopeName, newValue, oldValue);
                    destination[scopeName] = newValue;
                  }, parentGet.literal);
                  removeWatchCollection.push(removeWatch);
                  break;
                case '&':
                  parentGet = attrs.hasOwnProperty(attrName) ? $parse(attrs[attrName]) : noop;
                  if (parentGet === noop && optional)
                    break;
                  destination[scopeName] = function(locals) {
                    return parentGet(scope, locals);
                  };
                  break;
              }
            });
            function recordChanges(key, currentValue, previousValue) {
              if (isFunction(destination.$onChanges) && currentValue !== previousValue) {
                if (!onChangesQueue) {
                  scope.$$postDigest(flushOnChangesQueue);
                  onChangesQueue = [];
                }
                if (!changes) {
                  changes = {};
                  onChangesQueue.push(triggerOnChangesHook);
                }
                if (changes[key]) {
                  previousValue = changes[key].previousValue;
                }
                changes[key] = new SimpleChange(previousValue, currentValue);
              }
            }
            function triggerOnChangesHook() {
              destination.$onChanges(changes);
              changes = undefined;
            }
            return {
              initialChanges: initialChanges,
              removeWatches: removeWatchCollection.length && function removeWatches() {
                for (var i = 0,
                    ii = removeWatchCollection.length; i < ii; ++i) {
                  removeWatchCollection[i]();
                }
              }
            };
          }
        }];
      }
      function SimpleChange(previous, current) {
        this.previousValue = previous;
        this.currentValue = current;
      }
      SimpleChange.prototype.isFirstChange = function() {
        return this.previousValue === _UNINITIALIZED_VALUE;
      };
      var PREFIX_REGEXP = /^((?:x|data)[\:\-_])/i;
      function directiveNormalize(name) {
        return camelCase(name.replace(PREFIX_REGEXP, ''));
      }
      function nodesetLinkingFn(scope, nodeList, rootElement, boundTranscludeFn) {}
      function directiveLinkingFn(nodesetLinkingFn, scope, node, rootElement, boundTranscludeFn) {}
      function tokenDifference(str1, str2) {
        var values = '',
            tokens1 = str1.split(/\s+/),
            tokens2 = str2.split(/\s+/);
        outer: for (var i = 0; i < tokens1.length; i++) {
          var token = tokens1[i];
          for (var j = 0; j < tokens2.length; j++) {
            if (token == tokens2[j])
              continue outer;
          }
          values += (values.length > 0 ? ' ' : '') + token;
        }
        return values;
      }
      function removeComments(jqNodes) {
        jqNodes = jqLite(jqNodes);
        var i = jqNodes.length;
        if (i <= 1) {
          return jqNodes;
        }
        while (i--) {
          var node = jqNodes[i];
          if (node.nodeType === NODE_TYPE_COMMENT) {
            splice.call(jqNodes, i, 1);
          }
        }
        return jqNodes;
      }
      var $controllerMinErr = minErr('$controller');
      var CNTRL_REG = /^(\S+)(\s+as\s+([\w$]+))?$/;
      function identifierForController(controller, ident) {
        if (ident && isString(ident))
          return ident;
        if (isString(controller)) {
          var match = CNTRL_REG.exec(controller);
          if (match)
            return match[3];
        }
      }
      function $ControllerProvider() {
        var controllers = {},
            globals = false;
        this.has = function(name) {
          return controllers.hasOwnProperty(name);
        };
        this.register = function(name, constructor) {
          assertNotHasOwnProperty(name, 'controller');
          if (isObject(name)) {
            extend(controllers, name);
          } else {
            controllers[name] = constructor;
          }
        };
        this.allowGlobals = function() {
          globals = true;
        };
        this.$get = ['$injector', '$window', function($injector, $window) {
          return function $controller(expression, locals, later, ident) {
            var instance,
                match,
                constructor,
                identifier;
            later = later === true;
            if (ident && isString(ident)) {
              identifier = ident;
            }
            if (isString(expression)) {
              match = expression.match(CNTRL_REG);
              if (!match) {
                throw $controllerMinErr('ctrlfmt', "Badly formed controller string '{0}'. " + "Must match `__name__ as __id__` or `__name__`.", expression);
              }
              constructor = match[1], identifier = identifier || match[3];
              expression = controllers.hasOwnProperty(constructor) ? controllers[constructor] : getter(locals.$scope, constructor, true) || (globals ? getter($window, constructor, true) : undefined);
              assertArgFn(expression, constructor, true);
            }
            if (later) {
              var controllerPrototype = (isArray(expression) ? expression[expression.length - 1] : expression).prototype;
              instance = Object.create(controllerPrototype || null);
              if (identifier) {
                addIdentifier(locals, identifier, instance, constructor || expression.name);
              }
              var instantiate;
              return instantiate = extend(function $controllerInit() {
                var result = $injector.invoke(expression, instance, locals, constructor);
                if (result !== instance && (isObject(result) || isFunction(result))) {
                  instance = result;
                  if (identifier) {
                    addIdentifier(locals, identifier, instance, constructor || expression.name);
                  }
                }
                return instance;
              }, {
                instance: instance,
                identifier: identifier
              });
            }
            instance = $injector.instantiate(expression, locals, constructor);
            if (identifier) {
              addIdentifier(locals, identifier, instance, constructor || expression.name);
            }
            return instance;
          };
          function addIdentifier(locals, identifier, instance, name) {
            if (!(locals && isObject(locals.$scope))) {
              throw minErr('$controller')('noscp', "Cannot export controller '{0}' as '{1}'! No $scope object provided via `locals`.", name, identifier);
            }
            locals.$scope[identifier] = instance;
          }
        }];
      }
      function $DocumentProvider() {
        this.$get = ['$window', function(window) {
          return jqLite(window.document);
        }];
      }
      function $ExceptionHandlerProvider() {
        this.$get = ['$log', function($log) {
          return function(exception, cause) {
            $log.error.apply($log, arguments);
          };
        }];
      }
      var $$ForceReflowProvider = function() {
        this.$get = ['$document', function($document) {
          return function(domNode) {
            if (domNode) {
              if (!domNode.nodeType && domNode instanceof jqLite) {
                domNode = domNode[0];
              }
            } else {
              domNode = $document[0].body;
            }
            return domNode.offsetWidth + 1;
          };
        }];
      };
      var APPLICATION_JSON = 'application/json';
      var CONTENT_TYPE_APPLICATION_JSON = {'Content-Type': APPLICATION_JSON + ';charset=utf-8'};
      var JSON_START = /^\[|^\{(?!\{)/;
      var JSON_ENDS = {
        '[': /]$/,
        '{': /}$/
      };
      var JSON_PROTECTION_PREFIX = /^\)\]\}',?\n/;
      var $httpMinErr = minErr('$http');
      var $httpMinErrLegacyFn = function(method) {
        return function() {
          throw $httpMinErr('legacy', 'The method `{0}` on the promise returned from `$http` has been disabled.', method);
        };
      };
      function serializeValue(v) {
        if (isObject(v)) {
          return isDate(v) ? v.toISOString() : toJson(v);
        }
        return v;
      }
      function $HttpParamSerializerProvider() {
        this.$get = function() {
          return function ngParamSerializer(params) {
            if (!params)
              return '';
            var parts = [];
            forEachSorted(params, function(value, key) {
              if (value === null || isUndefined(value))
                return;
              if (isArray(value)) {
                forEach(value, function(v) {
                  parts.push(encodeUriQuery(key) + '=' + encodeUriQuery(serializeValue(v)));
                });
              } else {
                parts.push(encodeUriQuery(key) + '=' + encodeUriQuery(serializeValue(value)));
              }
            });
            return parts.join('&');
          };
        };
      }
      function $HttpParamSerializerJQLikeProvider() {
        this.$get = function() {
          return function jQueryLikeParamSerializer(params) {
            if (!params)
              return '';
            var parts = [];
            serialize(params, '', true);
            return parts.join('&');
            function serialize(toSerialize, prefix, topLevel) {
              if (toSerialize === null || isUndefined(toSerialize))
                return;
              if (isArray(toSerialize)) {
                forEach(toSerialize, function(value, index) {
                  serialize(value, prefix + '[' + (isObject(value) ? index : '') + ']');
                });
              } else if (isObject(toSerialize) && !isDate(toSerialize)) {
                forEachSorted(toSerialize, function(value, key) {
                  serialize(value, prefix + (topLevel ? '' : '[') + key + (topLevel ? '' : ']'));
                });
              } else {
                parts.push(encodeUriQuery(prefix) + '=' + encodeUriQuery(serializeValue(toSerialize)));
              }
            }
          };
        };
      }
      function defaultHttpResponseTransform(data, headers) {
        if (isString(data)) {
          var tempData = data.replace(JSON_PROTECTION_PREFIX, '').trim();
          if (tempData) {
            var contentType = headers('Content-Type');
            if ((contentType && (contentType.indexOf(APPLICATION_JSON) === 0)) || isJsonLike(tempData)) {
              data = fromJson(tempData);
            }
          }
        }
        return data;
      }
      function isJsonLike(str) {
        var jsonStart = str.match(JSON_START);
        return jsonStart && JSON_ENDS[jsonStart[0]].test(str);
      }
      function parseHeaders(headers) {
        var parsed = createMap(),
            i;
        function fillInParsed(key, val) {
          if (key) {
            parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
          }
        }
        if (isString(headers)) {
          forEach(headers.split('\n'), function(line) {
            i = line.indexOf(':');
            fillInParsed(lowercase(trim(line.substr(0, i))), trim(line.substr(i + 1)));
          });
        } else if (isObject(headers)) {
          forEach(headers, function(headerVal, headerKey) {
            fillInParsed(lowercase(headerKey), trim(headerVal));
          });
        }
        return parsed;
      }
      function headersGetter(headers) {
        var headersObj;
        return function(name) {
          if (!headersObj)
            headersObj = parseHeaders(headers);
          if (name) {
            var value = headersObj[lowercase(name)];
            if (value === void 0) {
              value = null;
            }
            return value;
          }
          return headersObj;
        };
      }
      function transformData(data, headers, status, fns) {
        if (isFunction(fns)) {
          return fns(data, headers, status);
        }
        forEach(fns, function(fn) {
          data = fn(data, headers, status);
        });
        return data;
      }
      function isSuccess(status) {
        return 200 <= status && status < 300;
      }
      function $HttpProvider() {
        var defaults = this.defaults = {
          transformResponse: [defaultHttpResponseTransform],
          transformRequest: [function(d) {
            return isObject(d) && !isFile(d) && !isBlob(d) && !isFormData(d) ? toJson(d) : d;
          }],
          headers: {
            common: {'Accept': 'application/json, text/plain, */*'},
            post: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
            put: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
            patch: shallowCopy(CONTENT_TYPE_APPLICATION_JSON)
          },
          xsrfCookieName: 'XSRF-TOKEN',
          xsrfHeaderName: 'X-XSRF-TOKEN',
          paramSerializer: '$httpParamSerializer'
        };
        var useApplyAsync = false;
        this.useApplyAsync = function(value) {
          if (isDefined(value)) {
            useApplyAsync = !!value;
            return this;
          }
          return useApplyAsync;
        };
        var useLegacyPromise = true;
        this.useLegacyPromiseExtensions = function(value) {
          if (isDefined(value)) {
            useLegacyPromise = !!value;
            return this;
          }
          return useLegacyPromise;
        };
        var interceptorFactories = this.interceptors = [];
        this.$get = ['$httpBackend', '$$cookieReader', '$cacheFactory', '$rootScope', '$q', '$injector', function($httpBackend, $$cookieReader, $cacheFactory, $rootScope, $q, $injector) {
          var defaultCache = $cacheFactory('$http');
          defaults.paramSerializer = isString(defaults.paramSerializer) ? $injector.get(defaults.paramSerializer) : defaults.paramSerializer;
          var reversedInterceptors = [];
          forEach(interceptorFactories, function(interceptorFactory) {
            reversedInterceptors.unshift(isString(interceptorFactory) ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory));
          });
          function $http(requestConfig) {
            if (!isObject(requestConfig)) {
              throw minErr('$http')('badreq', 'Http request configuration must be an object.  Received: {0}', requestConfig);
            }
            if (!isString(requestConfig.url)) {
              throw minErr('$http')('badreq', 'Http request configuration url must be a string.  Received: {0}', requestConfig.url);
            }
            var config = extend({
              method: 'get',
              transformRequest: defaults.transformRequest,
              transformResponse: defaults.transformResponse,
              paramSerializer: defaults.paramSerializer
            }, requestConfig);
            config.headers = mergeHeaders(requestConfig);
            config.method = uppercase(config.method);
            config.paramSerializer = isString(config.paramSerializer) ? $injector.get(config.paramSerializer) : config.paramSerializer;
            var serverRequest = function(config) {
              var headers = config.headers;
              var reqData = transformData(config.data, headersGetter(headers), undefined, config.transformRequest);
              if (isUndefined(reqData)) {
                forEach(headers, function(value, header) {
                  if (lowercase(header) === 'content-type') {
                    delete headers[header];
                  }
                });
              }
              if (isUndefined(config.withCredentials) && !isUndefined(defaults.withCredentials)) {
                config.withCredentials = defaults.withCredentials;
              }
              return sendReq(config, reqData).then(transformResponse, transformResponse);
            };
            var chain = [serverRequest, undefined];
            var promise = $q.when(config);
            forEach(reversedInterceptors, function(interceptor) {
              if (interceptor.request || interceptor.requestError) {
                chain.unshift(interceptor.request, interceptor.requestError);
              }
              if (interceptor.response || interceptor.responseError) {
                chain.push(interceptor.response, interceptor.responseError);
              }
            });
            while (chain.length) {
              var thenFn = chain.shift();
              var rejectFn = chain.shift();
              promise = promise.then(thenFn, rejectFn);
            }
            if (useLegacyPromise) {
              promise.success = function(fn) {
                assertArgFn(fn, 'fn');
                promise.then(function(response) {
                  fn(response.data, response.status, response.headers, config);
                });
                return promise;
              };
              promise.error = function(fn) {
                assertArgFn(fn, 'fn');
                promise.then(null, function(response) {
                  fn(response.data, response.status, response.headers, config);
                });
                return promise;
              };
            } else {
              promise.success = $httpMinErrLegacyFn('success');
              promise.error = $httpMinErrLegacyFn('error');
            }
            return promise;
            function transformResponse(response) {
              var resp = extend({}, response);
              resp.data = transformData(response.data, response.headers, response.status, config.transformResponse);
              return (isSuccess(response.status)) ? resp : $q.reject(resp);
            }
            function executeHeaderFns(headers, config) {
              var headerContent,
                  processedHeaders = {};
              forEach(headers, function(headerFn, header) {
                if (isFunction(headerFn)) {
                  headerContent = headerFn(config);
                  if (headerContent != null) {
                    processedHeaders[header] = headerContent;
                  }
                } else {
                  processedHeaders[header] = headerFn;
                }
              });
              return processedHeaders;
            }
            function mergeHeaders(config) {
              var defHeaders = defaults.headers,
                  reqHeaders = extend({}, config.headers),
                  defHeaderName,
                  lowercaseDefHeaderName,
                  reqHeaderName;
              defHeaders = extend({}, defHeaders.common, defHeaders[lowercase(config.method)]);
              defaultHeadersIteration: for (defHeaderName in defHeaders) {
                lowercaseDefHeaderName = lowercase(defHeaderName);
                for (reqHeaderName in reqHeaders) {
                  if (lowercase(reqHeaderName) === lowercaseDefHeaderName) {
                    continue defaultHeadersIteration;
                  }
                }
                reqHeaders[defHeaderName] = defHeaders[defHeaderName];
              }
              return executeHeaderFns(reqHeaders, shallowCopy(config));
            }
          }
          $http.pendingRequests = [];
          createShortMethods('get', 'delete', 'head', 'jsonp');
          createShortMethodsWithData('post', 'put', 'patch');
          $http.defaults = defaults;
          return $http;
          function createShortMethods(names) {
            forEach(arguments, function(name) {
              $http[name] = function(url, config) {
                return $http(extend({}, config || {}, {
                  method: name,
                  url: url
                }));
              };
            });
          }
          function createShortMethodsWithData(name) {
            forEach(arguments, function(name) {
              $http[name] = function(url, data, config) {
                return $http(extend({}, config || {}, {
                  method: name,
                  url: url,
                  data: data
                }));
              };
            });
          }
          function sendReq(config, reqData) {
            var deferred = $q.defer(),
                promise = deferred.promise,
                cache,
                cachedResp,
                reqHeaders = config.headers,
                url = buildUrl(config.url, config.paramSerializer(config.params));
            $http.pendingRequests.push(config);
            promise.then(removePendingReq, removePendingReq);
            if ((config.cache || defaults.cache) && config.cache !== false && (config.method === 'GET' || config.method === 'JSONP')) {
              cache = isObject(config.cache) ? config.cache : isObject(defaults.cache) ? defaults.cache : defaultCache;
            }
            if (cache) {
              cachedResp = cache.get(url);
              if (isDefined(cachedResp)) {
                if (isPromiseLike(cachedResp)) {
                  cachedResp.then(resolvePromiseWithResult, resolvePromiseWithResult);
                } else {
                  if (isArray(cachedResp)) {
                    resolvePromise(cachedResp[1], cachedResp[0], shallowCopy(cachedResp[2]), cachedResp[3]);
                  } else {
                    resolvePromise(cachedResp, 200, {}, 'OK');
                  }
                }
              } else {
                cache.put(url, promise);
              }
            }
            if (isUndefined(cachedResp)) {
              var xsrfValue = urlIsSameOrigin(config.url) ? $$cookieReader()[config.xsrfCookieName || defaults.xsrfCookieName] : undefined;
              if (xsrfValue) {
                reqHeaders[(config.xsrfHeaderName || defaults.xsrfHeaderName)] = xsrfValue;
              }
              $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout, config.withCredentials, config.responseType, createApplyHandlers(config.eventHandlers), createApplyHandlers(config.uploadEventHandlers));
            }
            return promise;
            function createApplyHandlers(eventHandlers) {
              if (eventHandlers) {
                var applyHandlers = {};
                forEach(eventHandlers, function(eventHandler, key) {
                  applyHandlers[key] = function(event) {
                    if (useApplyAsync) {
                      $rootScope.$applyAsync(callEventHandler);
                    } else if ($rootScope.$$phase) {
                      callEventHandler();
                    } else {
                      $rootScope.$apply(callEventHandler);
                    }
                    function callEventHandler() {
                      eventHandler(event);
                    }
                  };
                });
                return applyHandlers;
              }
            }
            function done(status, response, headersString, statusText) {
              if (cache) {
                if (isSuccess(status)) {
                  cache.put(url, [status, response, parseHeaders(headersString), statusText]);
                } else {
                  cache.remove(url);
                }
              }
              function resolveHttpPromise() {
                resolvePromise(response, status, headersString, statusText);
              }
              if (useApplyAsync) {
                $rootScope.$applyAsync(resolveHttpPromise);
              } else {
                resolveHttpPromise();
                if (!$rootScope.$$phase)
                  $rootScope.$apply();
              }
            }
            function resolvePromise(response, status, headers, statusText) {
              status = status >= -1 ? status : 0;
              (isSuccess(status) ? deferred.resolve : deferred.reject)({
                data: response,
                status: status,
                headers: headersGetter(headers),
                config: config,
                statusText: statusText
              });
            }
            function resolvePromiseWithResult(result) {
              resolvePromise(result.data, result.status, shallowCopy(result.headers()), result.statusText);
            }
            function removePendingReq() {
              var idx = $http.pendingRequests.indexOf(config);
              if (idx !== -1)
                $http.pendingRequests.splice(idx, 1);
            }
          }
          function buildUrl(url, serializedParams) {
            if (serializedParams.length > 0) {
              url += ((url.indexOf('?') == -1) ? '?' : '&') + serializedParams;
            }
            return url;
          }
        }];
      }
      function $xhrFactoryProvider() {
        this.$get = function() {
          return function createXhr() {
            return new window.XMLHttpRequest();
          };
        };
      }
      function $HttpBackendProvider() {
        this.$get = ['$browser', '$window', '$document', '$xhrFactory', function($browser, $window, $document, $xhrFactory) {
          return createHttpBackend($browser, $xhrFactory, $browser.defer, $window.angular.callbacks, $document[0]);
        }];
      }
      function createHttpBackend($browser, createXhr, $browserDefer, callbacks, rawDocument) {
        return function(method, url, post, callback, headers, timeout, withCredentials, responseType, eventHandlers, uploadEventHandlers) {
          $browser.$$incOutstandingRequestCount();
          url = url || $browser.url();
          if (lowercase(method) == 'jsonp') {
            var callbackId = '_' + (callbacks.counter++).toString(36);
            callbacks[callbackId] = function(data) {
              callbacks[callbackId].data = data;
              callbacks[callbackId].called = true;
            };
            var jsonpDone = jsonpReq(url.replace('JSON_CALLBACK', 'angular.callbacks.' + callbackId), callbackId, function(status, text) {
              completeRequest(callback, status, callbacks[callbackId].data, "", text);
              callbacks[callbackId] = noop;
            });
          } else {
            var xhr = createXhr(method, url);
            xhr.open(method, url, true);
            forEach(headers, function(value, key) {
              if (isDefined(value)) {
                xhr.setRequestHeader(key, value);
              }
            });
            xhr.onload = function requestLoaded() {
              var statusText = xhr.statusText || '';
              var response = ('response' in xhr) ? xhr.response : xhr.responseText;
              var status = xhr.status === 1223 ? 204 : xhr.status;
              if (status === 0) {
                status = response ? 200 : urlResolve(url).protocol == 'file' ? 404 : 0;
              }
              completeRequest(callback, status, response, xhr.getAllResponseHeaders(), statusText);
            };
            var requestError = function() {
              completeRequest(callback, -1, null, null, '');
            };
            xhr.onerror = requestError;
            xhr.onabort = requestError;
            forEach(eventHandlers, function(value, key) {
              xhr.addEventListener(key, value);
            });
            forEach(uploadEventHandlers, function(value, key) {
              xhr.upload.addEventListener(key, value);
            });
            if (withCredentials) {
              xhr.withCredentials = true;
            }
            if (responseType) {
              try {
                xhr.responseType = responseType;
              } catch (e) {
                if (responseType !== 'json') {
                  throw e;
                }
              }
            }
            xhr.send(isUndefined(post) ? null : post);
          }
          if (timeout > 0) {
            var timeoutId = $browserDefer(timeoutRequest, timeout);
          } else if (isPromiseLike(timeout)) {
            timeout.then(timeoutRequest);
          }
          function timeoutRequest() {
            jsonpDone && jsonpDone();
            xhr && xhr.abort();
          }
          function completeRequest(callback, status, response, headersString, statusText) {
            if (isDefined(timeoutId)) {
              $browserDefer.cancel(timeoutId);
            }
            jsonpDone = xhr = null;
            callback(status, response, headersString, statusText);
            $browser.$$completeOutstandingRequest(noop);
          }
        };
        function jsonpReq(url, callbackId, done) {
          var script = rawDocument.createElement('script'),
              callback = null;
          script.type = "text/javascript";
          script.src = url;
          script.async = true;
          callback = function(event) {
            removeEventListenerFn(script, "load", callback);
            removeEventListenerFn(script, "error", callback);
            rawDocument.body.removeChild(script);
            script = null;
            var status = -1;
            var text = "unknown";
            if (event) {
              if (event.type === "load" && !callbacks[callbackId].called) {
                event = {type: "error"};
              }
              text = event.type;
              status = event.type === "error" ? 404 : 200;
            }
            if (done) {
              done(status, text);
            }
          };
          addEventListenerFn(script, "load", callback);
          addEventListenerFn(script, "error", callback);
          rawDocument.body.appendChild(script);
          return callback;
        }
      }
      var $interpolateMinErr = angular.$interpolateMinErr = minErr('$interpolate');
      $interpolateMinErr.throwNoconcat = function(text) {
        throw $interpolateMinErr('noconcat', "Error while interpolating: {0}\nStrict Contextual Escaping disallows " + "interpolations that concatenate multiple expressions when a trusted value is " + "required.  See http://docs.angularjs.org/api/ng.$sce", text);
      };
      $interpolateMinErr.interr = function(text, err) {
        return $interpolateMinErr('interr', "Can't interpolate: {0}\n{1}", text, err.toString());
      };
      function $InterpolateProvider() {
        var startSymbol = '{{';
        var endSymbol = '}}';
        this.startSymbol = function(value) {
          if (value) {
            startSymbol = value;
            return this;
          } else {
            return startSymbol;
          }
        };
        this.endSymbol = function(value) {
          if (value) {
            endSymbol = value;
            return this;
          } else {
            return endSymbol;
          }
        };
        this.$get = ['$parse', '$exceptionHandler', '$sce', function($parse, $exceptionHandler, $sce) {
          var startSymbolLength = startSymbol.length,
              endSymbolLength = endSymbol.length,
              escapedStartRegexp = new RegExp(startSymbol.replace(/./g, escape), 'g'),
              escapedEndRegexp = new RegExp(endSymbol.replace(/./g, escape), 'g');
          function escape(ch) {
            return '\\\\\\' + ch;
          }
          function unescapeText(text) {
            return text.replace(escapedStartRegexp, startSymbol).replace(escapedEndRegexp, endSymbol);
          }
          function stringify(value) {
            if (value == null) {
              return '';
            }
            switch (typeof value) {
              case 'string':
                break;
              case 'number':
                value = '' + value;
                break;
              default:
                value = toJson(value);
            }
            return value;
          }
          function constantWatchDelegate(scope, listener, objectEquality, constantInterp) {
            var unwatch;
            return unwatch = scope.$watch(function constantInterpolateWatch(scope) {
              unwatch();
              return constantInterp(scope);
            }, listener, objectEquality);
          }
          function $interpolate(text, mustHaveExpression, trustedContext, allOrNothing) {
            if (!text.length || text.indexOf(startSymbol) === -1) {
              var constantInterp;
              if (!mustHaveExpression) {
                var unescapedText = unescapeText(text);
                constantInterp = valueFn(unescapedText);
                constantInterp.exp = text;
                constantInterp.expressions = [];
                constantInterp.$$watchDelegate = constantWatchDelegate;
              }
              return constantInterp;
            }
            allOrNothing = !!allOrNothing;
            var startIndex,
                endIndex,
                index = 0,
                expressions = [],
                parseFns = [],
                textLength = text.length,
                exp,
                concat = [],
                expressionPositions = [];
            while (index < textLength) {
              if (((startIndex = text.indexOf(startSymbol, index)) != -1) && ((endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength)) != -1)) {
                if (index !== startIndex) {
                  concat.push(unescapeText(text.substring(index, startIndex)));
                }
                exp = text.substring(startIndex + startSymbolLength, endIndex);
                expressions.push(exp);
                parseFns.push($parse(exp, parseStringifyInterceptor));
                index = endIndex + endSymbolLength;
                expressionPositions.push(concat.length);
                concat.push('');
              } else {
                if (index !== textLength) {
                  concat.push(unescapeText(text.substring(index)));
                }
                break;
              }
            }
            if (trustedContext && concat.length > 1) {
              $interpolateMinErr.throwNoconcat(text);
            }
            if (!mustHaveExpression || expressions.length) {
              var compute = function(values) {
                for (var i = 0,
                    ii = expressions.length; i < ii; i++) {
                  if (allOrNothing && isUndefined(values[i]))
                    return;
                  concat[expressionPositions[i]] = values[i];
                }
                return concat.join('');
              };
              var getValue = function(value) {
                return trustedContext ? $sce.getTrusted(trustedContext, value) : $sce.valueOf(value);
              };
              return extend(function interpolationFn(context) {
                var i = 0;
                var ii = expressions.length;
                var values = new Array(ii);
                try {
                  for (; i < ii; i++) {
                    values[i] = parseFns[i](context);
                  }
                  return compute(values);
                } catch (err) {
                  $exceptionHandler($interpolateMinErr.interr(text, err));
                }
              }, {
                exp: text,
                expressions: expressions,
                $$watchDelegate: function(scope, listener) {
                  var lastValue;
                  return scope.$watchGroup(parseFns, function interpolateFnWatcher(values, oldValues) {
                    var currValue = compute(values);
                    if (isFunction(listener)) {
                      listener.call(this, currValue, values !== oldValues ? lastValue : currValue, scope);
                    }
                    lastValue = currValue;
                  });
                }
              });
            }
            function parseStringifyInterceptor(value) {
              try {
                value = getValue(value);
                return allOrNothing && !isDefined(value) ? value : stringify(value);
              } catch (err) {
                $exceptionHandler($interpolateMinErr.interr(text, err));
              }
            }
          }
          $interpolate.startSymbol = function() {
            return startSymbol;
          };
          $interpolate.endSymbol = function() {
            return endSymbol;
          };
          return $interpolate;
        }];
      }
      function $IntervalProvider() {
        this.$get = ['$rootScope', '$window', '$q', '$$q', '$browser', function($rootScope, $window, $q, $$q, $browser) {
          var intervals = {};
          function interval(fn, delay, count, invokeApply) {
            var hasParams = arguments.length > 4,
                args = hasParams ? sliceArgs(arguments, 4) : [],
                setInterval = $window.setInterval,
                clearInterval = $window.clearInterval,
                iteration = 0,
                skipApply = (isDefined(invokeApply) && !invokeApply),
                deferred = (skipApply ? $$q : $q).defer(),
                promise = deferred.promise;
            count = isDefined(count) ? count : 0;
            promise.$$intervalId = setInterval(function tick() {
              if (skipApply) {
                $browser.defer(callback);
              } else {
                $rootScope.$evalAsync(callback);
              }
              deferred.notify(iteration++);
              if (count > 0 && iteration >= count) {
                deferred.resolve(iteration);
                clearInterval(promise.$$intervalId);
                delete intervals[promise.$$intervalId];
              }
              if (!skipApply)
                $rootScope.$apply();
            }, delay);
            intervals[promise.$$intervalId] = deferred;
            return promise;
            function callback() {
              if (!hasParams) {
                fn(iteration);
              } else {
                fn.apply(null, args);
              }
            }
          }
          interval.cancel = function(promise) {
            if (promise && promise.$$intervalId in intervals) {
              intervals[promise.$$intervalId].reject('canceled');
              $window.clearInterval(promise.$$intervalId);
              delete intervals[promise.$$intervalId];
              return true;
            }
            return false;
          };
          return interval;
        }];
      }
      var PATH_MATCH = /^([^\?#]*)(\?([^#]*))?(#(.*))?$/,
          DEFAULT_PORTS = {
            'http': 80,
            'https': 443,
            'ftp': 21
          };
      var $locationMinErr = minErr('$location');
      function encodePath(path) {
        var segments = path.split('/'),
            i = segments.length;
        while (i--) {
          segments[i] = encodeUriSegment(segments[i]);
        }
        return segments.join('/');
      }
      function parseAbsoluteUrl(absoluteUrl, locationObj) {
        var parsedUrl = urlResolve(absoluteUrl);
        locationObj.$$protocol = parsedUrl.protocol;
        locationObj.$$host = parsedUrl.hostname;
        locationObj.$$port = toInt(parsedUrl.port) || DEFAULT_PORTS[parsedUrl.protocol] || null;
      }
      function parseAppUrl(relativeUrl, locationObj) {
        var prefixed = (relativeUrl.charAt(0) !== '/');
        if (prefixed) {
          relativeUrl = '/' + relativeUrl;
        }
        var match = urlResolve(relativeUrl);
        locationObj.$$path = decodeURIComponent(prefixed && match.pathname.charAt(0) === '/' ? match.pathname.substring(1) : match.pathname);
        locationObj.$$search = parseKeyValue(match.search);
        locationObj.$$hash = decodeURIComponent(match.hash);
        if (locationObj.$$path && locationObj.$$path.charAt(0) != '/') {
          locationObj.$$path = '/' + locationObj.$$path;
        }
      }
      function startsWith(haystack, needle) {
        return haystack.lastIndexOf(needle, 0) === 0;
      }
      function stripBaseUrl(base, url) {
        if (startsWith(url, base)) {
          return url.substr(base.length);
        }
      }
      function stripHash(url) {
        var index = url.indexOf('#');
        return index == -1 ? url : url.substr(0, index);
      }
      function trimEmptyHash(url) {
        return url.replace(/(#.+)|#$/, '$1');
      }
      function stripFile(url) {
        return url.substr(0, stripHash(url).lastIndexOf('/') + 1);
      }
      function serverBase(url) {
        return url.substring(0, url.indexOf('/', url.indexOf('//') + 2));
      }
      function LocationHtml5Url(appBase, appBaseNoFile, basePrefix) {
        this.$$html5 = true;
        basePrefix = basePrefix || '';
        parseAbsoluteUrl(appBase, this);
        this.$$parse = function(url) {
          var pathUrl = stripBaseUrl(appBaseNoFile, url);
          if (!isString(pathUrl)) {
            throw $locationMinErr('ipthprfx', 'Invalid url "{0}", missing path prefix "{1}".', url, appBaseNoFile);
          }
          parseAppUrl(pathUrl, this);
          if (!this.$$path) {
            this.$$path = '/';
          }
          this.$$compose();
        };
        this.$$compose = function() {
          var search = toKeyValue(this.$$search),
              hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
          this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
          this.$$absUrl = appBaseNoFile + this.$$url.substr(1);
        };
        this.$$parseLinkUrl = function(url, relHref) {
          if (relHref && relHref[0] === '#') {
            this.hash(relHref.slice(1));
            return true;
          }
          var appUrl,
              prevAppUrl;
          var rewrittenUrl;
          if (isDefined(appUrl = stripBaseUrl(appBase, url))) {
            prevAppUrl = appUrl;
            if (isDefined(appUrl = stripBaseUrl(basePrefix, appUrl))) {
              rewrittenUrl = appBaseNoFile + (stripBaseUrl('/', appUrl) || appUrl);
            } else {
              rewrittenUrl = appBase + prevAppUrl;
            }
          } else if (isDefined(appUrl = stripBaseUrl(appBaseNoFile, url))) {
            rewrittenUrl = appBaseNoFile + appUrl;
          } else if (appBaseNoFile == url + '/') {
            rewrittenUrl = appBaseNoFile;
          }
          if (rewrittenUrl) {
            this.$$parse(rewrittenUrl);
          }
          return !!rewrittenUrl;
        };
      }
      function LocationHashbangUrl(appBase, appBaseNoFile, hashPrefix) {
        parseAbsoluteUrl(appBase, this);
        this.$$parse = function(url) {
          var withoutBaseUrl = stripBaseUrl(appBase, url) || stripBaseUrl(appBaseNoFile, url);
          var withoutHashUrl;
          if (!isUndefined(withoutBaseUrl) && withoutBaseUrl.charAt(0) === '#') {
            withoutHashUrl = stripBaseUrl(hashPrefix, withoutBaseUrl);
            if (isUndefined(withoutHashUrl)) {
              withoutHashUrl = withoutBaseUrl;
            }
          } else {
            if (this.$$html5) {
              withoutHashUrl = withoutBaseUrl;
            } else {
              withoutHashUrl = '';
              if (isUndefined(withoutBaseUrl)) {
                appBase = url;
                this.replace();
              }
            }
          }
          parseAppUrl(withoutHashUrl, this);
          this.$$path = removeWindowsDriveName(this.$$path, withoutHashUrl, appBase);
          this.$$compose();
          function removeWindowsDriveName(path, url, base) {
            var windowsFilePathExp = /^\/[A-Z]:(\/.*)/;
            var firstPathSegmentMatch;
            if (startsWith(url, base)) {
              url = url.replace(base, '');
            }
            if (windowsFilePathExp.exec(url)) {
              return path;
            }
            firstPathSegmentMatch = windowsFilePathExp.exec(path);
            return firstPathSegmentMatch ? firstPathSegmentMatch[1] : path;
          }
        };
        this.$$compose = function() {
          var search = toKeyValue(this.$$search),
              hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
          this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
          this.$$absUrl = appBase + (this.$$url ? hashPrefix + this.$$url : '');
        };
        this.$$parseLinkUrl = function(url, relHref) {
          if (stripHash(appBase) == stripHash(url)) {
            this.$$parse(url);
            return true;
          }
          return false;
        };
      }
      function LocationHashbangInHtml5Url(appBase, appBaseNoFile, hashPrefix) {
        this.$$html5 = true;
        LocationHashbangUrl.apply(this, arguments);
        this.$$parseLinkUrl = function(url, relHref) {
          if (relHref && relHref[0] === '#') {
            this.hash(relHref.slice(1));
            return true;
          }
          var rewrittenUrl;
          var appUrl;
          if (appBase == stripHash(url)) {
            rewrittenUrl = url;
          } else if ((appUrl = stripBaseUrl(appBaseNoFile, url))) {
            rewrittenUrl = appBase + hashPrefix + appUrl;
          } else if (appBaseNoFile === url + '/') {
            rewrittenUrl = appBaseNoFile;
          }
          if (rewrittenUrl) {
            this.$$parse(rewrittenUrl);
          }
          return !!rewrittenUrl;
        };
        this.$$compose = function() {
          var search = toKeyValue(this.$$search),
              hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
          this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
          this.$$absUrl = appBase + hashPrefix + this.$$url;
        };
      }
      var locationPrototype = {
        $$absUrl: '',
        $$html5: false,
        $$replace: false,
        absUrl: locationGetter('$$absUrl'),
        url: function(url) {
          if (isUndefined(url)) {
            return this.$$url;
          }
          var match = PATH_MATCH.exec(url);
          if (match[1] || url === '')
            this.path(decodeURIComponent(match[1]));
          if (match[2] || match[1] || url === '')
            this.search(match[3] || '');
          this.hash(match[5] || '');
          return this;
        },
        protocol: locationGetter('$$protocol'),
        host: locationGetter('$$host'),
        port: locationGetter('$$port'),
        path: locationGetterSetter('$$path', function(path) {
          path = path !== null ? path.toString() : '';
          return path.charAt(0) == '/' ? path : '/' + path;
        }),
        search: function(search, paramValue) {
          switch (arguments.length) {
            case 0:
              return this.$$search;
            case 1:
              if (isString(search) || isNumber(search)) {
                search = search.toString();
                this.$$search = parseKeyValue(search);
              } else if (isObject(search)) {
                search = copy(search, {});
                forEach(search, function(value, key) {
                  if (value == null)
                    delete search[key];
                });
                this.$$search = search;
              } else {
                throw $locationMinErr('isrcharg', 'The first argument of the `$location#search()` call must be a string or an object.');
              }
              break;
            default:
              if (isUndefined(paramValue) || paramValue === null) {
                delete this.$$search[search];
              } else {
                this.$$search[search] = paramValue;
              }
          }
          this.$$compose();
          return this;
        },
        hash: locationGetterSetter('$$hash', function(hash) {
          return hash !== null ? hash.toString() : '';
        }),
        replace: function() {
          this.$$replace = true;
          return this;
        }
      };
      forEach([LocationHashbangInHtml5Url, LocationHashbangUrl, LocationHtml5Url], function(Location) {
        Location.prototype = Object.create(locationPrototype);
        Location.prototype.state = function(state) {
          if (!arguments.length) {
            return this.$$state;
          }
          if (Location !== LocationHtml5Url || !this.$$html5) {
            throw $locationMinErr('nostate', 'History API state support is available only ' + 'in HTML5 mode and only in browsers supporting HTML5 History API');
          }
          this.$$state = isUndefined(state) ? null : state;
          return this;
        };
      });
      function locationGetter(property) {
        return function() {
          return this[property];
        };
      }
      function locationGetterSetter(property, preprocess) {
        return function(value) {
          if (isUndefined(value)) {
            return this[property];
          }
          this[property] = preprocess(value);
          this.$$compose();
          return this;
        };
      }
      function $LocationProvider() {
        var hashPrefix = '',
            html5Mode = {
              enabled: false,
              requireBase: true,
              rewriteLinks: true
            };
        this.hashPrefix = function(prefix) {
          if (isDefined(prefix)) {
            hashPrefix = prefix;
            return this;
          } else {
            return hashPrefix;
          }
        };
        this.html5Mode = function(mode) {
          if (isBoolean(mode)) {
            html5Mode.enabled = mode;
            return this;
          } else if (isObject(mode)) {
            if (isBoolean(mode.enabled)) {
              html5Mode.enabled = mode.enabled;
            }
            if (isBoolean(mode.requireBase)) {
              html5Mode.requireBase = mode.requireBase;
            }
            if (isBoolean(mode.rewriteLinks)) {
              html5Mode.rewriteLinks = mode.rewriteLinks;
            }
            return this;
          } else {
            return html5Mode;
          }
        };
        this.$get = ['$rootScope', '$browser', '$sniffer', '$rootElement', '$window', function($rootScope, $browser, $sniffer, $rootElement, $window) {
          var $location,
              LocationMode,
              baseHref = $browser.baseHref(),
              initialUrl = $browser.url(),
              appBase;
          if (html5Mode.enabled) {
            if (!baseHref && html5Mode.requireBase) {
              throw $locationMinErr('nobase', "$location in HTML5 mode requires a <base> tag to be present!");
            }
            appBase = serverBase(initialUrl) + (baseHref || '/');
            LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url;
          } else {
            appBase = stripHash(initialUrl);
            LocationMode = LocationHashbangUrl;
          }
          var appBaseNoFile = stripFile(appBase);
          $location = new LocationMode(appBase, appBaseNoFile, '#' + hashPrefix);
          $location.$$parseLinkUrl(initialUrl, initialUrl);
          $location.$$state = $browser.state();
          var IGNORE_URI_REGEXP = /^\s*(javascript|mailto):/i;
          function setBrowserUrlWithFallback(url, replace, state) {
            var oldUrl = $location.url();
            var oldState = $location.$$state;
            try {
              $browser.url(url, replace, state);
              $location.$$state = $browser.state();
            } catch (e) {
              $location.url(oldUrl);
              $location.$$state = oldState;
              throw e;
            }
          }
          $rootElement.on('click', function(event) {
            if (!html5Mode.rewriteLinks || event.ctrlKey || event.metaKey || event.shiftKey || event.which == 2 || event.button == 2)
              return;
            var elm = jqLite(event.target);
            while (nodeName_(elm[0]) !== 'a') {
              if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0])
                return;
            }
            var absHref = elm.prop('href');
            var relHref = elm.attr('href') || elm.attr('xlink:href');
            if (isObject(absHref) && absHref.toString() === '[object SVGAnimatedString]') {
              absHref = urlResolve(absHref.animVal).href;
            }
            if (IGNORE_URI_REGEXP.test(absHref))
              return;
            if (absHref && !elm.attr('target') && !event.isDefaultPrevented()) {
              if ($location.$$parseLinkUrl(absHref, relHref)) {
                event.preventDefault();
                if ($location.absUrl() != $browser.url()) {
                  $rootScope.$apply();
                  $window.angular['ff-684208-preventDefault'] = true;
                }
              }
            }
          });
          if (trimEmptyHash($location.absUrl()) != trimEmptyHash(initialUrl)) {
            $browser.url($location.absUrl(), true);
          }
          var initializing = true;
          $browser.onUrlChange(function(newUrl, newState) {
            if (isUndefined(stripBaseUrl(appBaseNoFile, newUrl))) {
              $window.location.href = newUrl;
              return;
            }
            $rootScope.$evalAsync(function() {
              var oldUrl = $location.absUrl();
              var oldState = $location.$$state;
              var defaultPrevented;
              newUrl = trimEmptyHash(newUrl);
              $location.$$parse(newUrl);
              $location.$$state = newState;
              defaultPrevented = $rootScope.$broadcast('$locationChangeStart', newUrl, oldUrl, newState, oldState).defaultPrevented;
              if ($location.absUrl() !== newUrl)
                return;
              if (defaultPrevented) {
                $location.$$parse(oldUrl);
                $location.$$state = oldState;
                setBrowserUrlWithFallback(oldUrl, false, oldState);
              } else {
                initializing = false;
                afterLocationChange(oldUrl, oldState);
              }
            });
            if (!$rootScope.$$phase)
              $rootScope.$digest();
          });
          $rootScope.$watch(function $locationWatch() {
            var oldUrl = trimEmptyHash($browser.url());
            var newUrl = trimEmptyHash($location.absUrl());
            var oldState = $browser.state();
            var currentReplace = $location.$$replace;
            var urlOrStateChanged = oldUrl !== newUrl || ($location.$$html5 && $sniffer.history && oldState !== $location.$$state);
            if (initializing || urlOrStateChanged) {
              initializing = false;
              $rootScope.$evalAsync(function() {
                var newUrl = $location.absUrl();
                var defaultPrevented = $rootScope.$broadcast('$locationChangeStart', newUrl, oldUrl, $location.$$state, oldState).defaultPrevented;
                if ($location.absUrl() !== newUrl)
                  return;
                if (defaultPrevented) {
                  $location.$$parse(oldUrl);
                  $location.$$state = oldState;
                } else {
                  if (urlOrStateChanged) {
                    setBrowserUrlWithFallback(newUrl, currentReplace, oldState === $location.$$state ? null : $location.$$state);
                  }
                  afterLocationChange(oldUrl, oldState);
                }
              });
            }
            $location.$$replace = false;
          });
          return $location;
          function afterLocationChange(oldUrl, oldState) {
            $rootScope.$broadcast('$locationChangeSuccess', $location.absUrl(), oldUrl, $location.$$state, oldState);
          }
        }];
      }
      function $LogProvider() {
        var debug = true,
            self = this;
        this.debugEnabled = function(flag) {
          if (isDefined(flag)) {
            debug = flag;
            return this;
          } else {
            return debug;
          }
        };
        this.$get = ['$window', function($window) {
          return {
            log: consoleLog('log'),
            info: consoleLog('info'),
            warn: consoleLog('warn'),
            error: consoleLog('error'),
            debug: (function() {
              var fn = consoleLog('debug');
              return function() {
                if (debug) {
                  fn.apply(self, arguments);
                }
              };
            }())
          };
          function formatError(arg) {
            if (arg instanceof Error) {
              if (arg.stack) {
                arg = (arg.message && arg.stack.indexOf(arg.message) === -1) ? 'Error: ' + arg.message + '\n' + arg.stack : arg.stack;
              } else if (arg.sourceURL) {
                arg = arg.message + '\n' + arg.sourceURL + ':' + arg.line;
              }
            }
            return arg;
          }
          function consoleLog(type) {
            var console = $window.console || {},
                logFn = console[type] || console.log || noop,
                hasApply = false;
            try {
              hasApply = !!logFn.apply;
            } catch (e) {}
            if (hasApply) {
              return function() {
                var args = [];
                forEach(arguments, function(arg) {
                  args.push(formatError(arg));
                });
                return logFn.apply(console, args);
              };
            }
            return function(arg1, arg2) {
              logFn(arg1, arg2 == null ? '' : arg2);
            };
          }
        }];
      }
      var $parseMinErr = minErr('$parse');
      function ensureSafeMemberName(name, fullExpression) {
        if (name === "__defineGetter__" || name === "__defineSetter__" || name === "__lookupGetter__" || name === "__lookupSetter__" || name === "__proto__") {
          throw $parseMinErr('isecfld', 'Attempting to access a disallowed field in Angular expressions! ' + 'Expression: {0}', fullExpression);
        }
        return name;
      }
      function getStringValue(name) {
        return name + '';
      }
      function ensureSafeObject(obj, fullExpression) {
        if (obj) {
          if (obj.constructor === obj) {
            throw $parseMinErr('isecfn', 'Referencing Function in Angular expressions is disallowed! Expression: {0}', fullExpression);
          } else if (obj.window === obj) {
            throw $parseMinErr('isecwindow', 'Referencing the Window in Angular expressions is disallowed! Expression: {0}', fullExpression);
          } else if (obj.children && (obj.nodeName || (obj.prop && obj.attr && obj.find))) {
            throw $parseMinErr('isecdom', 'Referencing DOM nodes in Angular expressions is disallowed! Expression: {0}', fullExpression);
          } else if (obj === Object) {
            throw $parseMinErr('isecobj', 'Referencing Object in Angular expressions is disallowed! Expression: {0}', fullExpression);
          }
        }
        return obj;
      }
      var CALL = Function.prototype.call;
      var APPLY = Function.prototype.apply;
      var BIND = Function.prototype.bind;
      function ensureSafeFunction(obj, fullExpression) {
        if (obj) {
          if (obj.constructor === obj) {
            throw $parseMinErr('isecfn', 'Referencing Function in Angular expressions is disallowed! Expression: {0}', fullExpression);
          } else if (obj === CALL || obj === APPLY || obj === BIND) {
            throw $parseMinErr('isecff', 'Referencing call, apply or bind in Angular expressions is disallowed! Expression: {0}', fullExpression);
          }
        }
      }
      function ensureSafeAssignContext(obj, fullExpression) {
        if (obj) {
          if (obj === (0).constructor || obj === (false).constructor || obj === ''.constructor || obj === {}.constructor || obj === [].constructor || obj === Function.constructor) {
            throw $parseMinErr('isecaf', 'Assigning to a constructor is disallowed! Expression: {0}', fullExpression);
          }
        }
      }
      var OPERATORS = createMap();
      forEach('+ - * / % === !== == != < > <= >= && || ! = |'.split(' '), function(operator) {
        OPERATORS[operator] = true;
      });
      var ESCAPE = {
        "n": "\n",
        "f": "\f",
        "r": "\r",
        "t": "\t",
        "v": "\v",
        "'": "'",
        '"': '"'
      };
      var Lexer = function(options) {
        this.options = options;
      };
      Lexer.prototype = {
        constructor: Lexer,
        lex: function(text) {
          this.text = text;
          this.index = 0;
          this.tokens = [];
          while (this.index < this.text.length) {
            var ch = this.text.charAt(this.index);
            if (ch === '"' || ch === "'") {
              this.readString(ch);
            } else if (this.isNumber(ch) || ch === '.' && this.isNumber(this.peek())) {
              this.readNumber();
            } else if (this.isIdentifierStart(this.peekMultichar())) {
              this.readIdent();
            } else if (this.is(ch, '(){}[].,;:?')) {
              this.tokens.push({
                index: this.index,
                text: ch
              });
              this.index++;
            } else if (this.isWhitespace(ch)) {
              this.index++;
            } else {
              var ch2 = ch + this.peek();
              var ch3 = ch2 + this.peek(2);
              var op1 = OPERATORS[ch];
              var op2 = OPERATORS[ch2];
              var op3 = OPERATORS[ch3];
              if (op1 || op2 || op3) {
                var token = op3 ? ch3 : (op2 ? ch2 : ch);
                this.tokens.push({
                  index: this.index,
                  text: token,
                  operator: true
                });
                this.index += token.length;
              } else {
                this.throwError('Unexpected next character ', this.index, this.index + 1);
              }
            }
          }
          return this.tokens;
        },
        is: function(ch, chars) {
          return chars.indexOf(ch) !== -1;
        },
        peek: function(i) {
          var num = i || 1;
          return (this.index + num < this.text.length) ? this.text.charAt(this.index + num) : false;
        },
        isNumber: function(ch) {
          return ('0' <= ch && ch <= '9') && typeof ch === "string";
        },
        isWhitespace: function(ch) {
          return (ch === ' ' || ch === '\r' || ch === '\t' || ch === '\n' || ch === '\v' || ch === '\u00A0');
        },
        isIdentifierStart: function(ch) {
          return this.options.isIdentifierStart ? this.options.isIdentifierStart(ch, this.codePointAt(ch)) : this.isValidIdentifierStart(ch);
        },
        isValidIdentifierStart: function(ch) {
          return ('a' <= ch && ch <= 'z' || 'A' <= ch && ch <= 'Z' || '_' === ch || ch === '$');
        },
        isIdentifierContinue: function(ch) {
          return this.options.isIdentifierContinue ? this.options.isIdentifierContinue(ch, this.codePointAt(ch)) : this.isValidIdentifierContinue(ch);
        },
        isValidIdentifierContinue: function(ch, cp) {
          return this.isValidIdentifierStart(ch, cp) || this.isNumber(ch);
        },
        codePointAt: function(ch) {
          if (ch.length === 1)
            return ch.charCodeAt(0);
          return (ch.charCodeAt(0) << 10) + ch.charCodeAt(1) - 0x35FDC00;
        },
        peekMultichar: function() {
          var ch = this.text.charAt(this.index);
          var peek = this.peek();
          if (!peek) {
            return ch;
          }
          var cp1 = ch.charCodeAt(0);
          var cp2 = peek.charCodeAt(0);
          if (cp1 >= 0xD800 && cp1 <= 0xDBFF && cp2 >= 0xDC00 && cp2 <= 0xDFFF) {
            return ch + peek;
          }
          return ch;
        },
        isExpOperator: function(ch) {
          return (ch === '-' || ch === '+' || this.isNumber(ch));
        },
        throwError: function(error, start, end) {
          end = end || this.index;
          var colStr = (isDefined(start) ? 's ' + start + '-' + this.index + ' [' + this.text.substring(start, end) + ']' : ' ' + end);
          throw $parseMinErr('lexerr', 'Lexer Error: {0} at column{1} in expression [{2}].', error, colStr, this.text);
        },
        readNumber: function() {
          var number = '';
          var start = this.index;
          while (this.index < this.text.length) {
            var ch = lowercase(this.text.charAt(this.index));
            if (ch == '.' || this.isNumber(ch)) {
              number += ch;
            } else {
              var peekCh = this.peek();
              if (ch == 'e' && this.isExpOperator(peekCh)) {
                number += ch;
              } else if (this.isExpOperator(ch) && peekCh && this.isNumber(peekCh) && number.charAt(number.length - 1) == 'e') {
                number += ch;
              } else if (this.isExpOperator(ch) && (!peekCh || !this.isNumber(peekCh)) && number.charAt(number.length - 1) == 'e') {
                this.throwError('Invalid exponent');
              } else {
                break;
              }
            }
            this.index++;
          }
          this.tokens.push({
            index: start,
            text: number,
            constant: true,
            value: Number(number)
          });
        },
        readIdent: function() {
          var start = this.index;
          this.index += this.peekMultichar().length;
          while (this.index < this.text.length) {
            var ch = this.peekMultichar();
            if (!this.isIdentifierContinue(ch)) {
              break;
            }
            this.index += ch.length;
          }
          this.tokens.push({
            index: start,
            text: this.text.slice(start, this.index),
            identifier: true
          });
        },
        readString: function(quote) {
          var start = this.index;
          this.index++;
          var string = '';
          var rawString = quote;
          var escape = false;
          while (this.index < this.text.length) {
            var ch = this.text.charAt(this.index);
            rawString += ch;
            if (escape) {
              if (ch === 'u') {
                var hex = this.text.substring(this.index + 1, this.index + 5);
                if (!hex.match(/[\da-f]{4}/i)) {
                  this.throwError('Invalid unicode escape [\\u' + hex + ']');
                }
                this.index += 4;
                string += String.fromCharCode(parseInt(hex, 16));
              } else {
                var rep = ESCAPE[ch];
                string = string + (rep || ch);
              }
              escape = false;
            } else if (ch === '\\') {
              escape = true;
            } else if (ch === quote) {
              this.index++;
              this.tokens.push({
                index: start,
                text: rawString,
                constant: true,
                value: string
              });
              return;
            } else {
              string += ch;
            }
            this.index++;
          }
          this.throwError('Unterminated quote', start);
        }
      };
      var AST = function(lexer, options) {
        this.lexer = lexer;
        this.options = options;
      };
      AST.Program = 'Program';
      AST.ExpressionStatement = 'ExpressionStatement';
      AST.AssignmentExpression = 'AssignmentExpression';
      AST.ConditionalExpression = 'ConditionalExpression';
      AST.LogicalExpression = 'LogicalExpression';
      AST.BinaryExpression = 'BinaryExpression';
      AST.UnaryExpression = 'UnaryExpression';
      AST.CallExpression = 'CallExpression';
      AST.MemberExpression = 'MemberExpression';
      AST.Identifier = 'Identifier';
      AST.Literal = 'Literal';
      AST.ArrayExpression = 'ArrayExpression';
      AST.Property = 'Property';
      AST.ObjectExpression = 'ObjectExpression';
      AST.ThisExpression = 'ThisExpression';
      AST.LocalsExpression = 'LocalsExpression';
      AST.NGValueParameter = 'NGValueParameter';
      AST.prototype = {
        ast: function(text) {
          this.text = text;
          this.tokens = this.lexer.lex(text);
          var value = this.program();
          if (this.tokens.length !== 0) {
            this.throwError('is an unexpected token', this.tokens[0]);
          }
          return value;
        },
        program: function() {
          var body = [];
          while (true) {
            if (this.tokens.length > 0 && !this.peek('}', ')', ';', ']'))
              body.push(this.expressionStatement());
            if (!this.expect(';')) {
              return {
                type: AST.Program,
                body: body
              };
            }
          }
        },
        expressionStatement: function() {
          return {
            type: AST.ExpressionStatement,
            expression: this.filterChain()
          };
        },
        filterChain: function() {
          var left = this.expression();
          var token;
          while ((token = this.expect('|'))) {
            left = this.filter(left);
          }
          return left;
        },
        expression: function() {
          return this.assignment();
        },
        assignment: function() {
          var result = this.ternary();
          if (this.expect('=')) {
            result = {
              type: AST.AssignmentExpression,
              left: result,
              right: this.assignment(),
              operator: '='
            };
          }
          return result;
        },
        ternary: function() {
          var test = this.logicalOR();
          var alternate;
          var consequent;
          if (this.expect('?')) {
            alternate = this.expression();
            if (this.consume(':')) {
              consequent = this.expression();
              return {
                type: AST.ConditionalExpression,
                test: test,
                alternate: alternate,
                consequent: consequent
              };
            }
          }
          return test;
        },
        logicalOR: function() {
          var left = this.logicalAND();
          while (this.expect('||')) {
            left = {
              type: AST.LogicalExpression,
              operator: '||',
              left: left,
              right: this.logicalAND()
            };
          }
          return left;
        },
        logicalAND: function() {
          var left = this.equality();
          while (this.expect('&&')) {
            left = {
              type: AST.LogicalExpression,
              operator: '&&',
              left: left,
              right: this.equality()
            };
          }
          return left;
        },
        equality: function() {
          var left = this.relational();
          var token;
          while ((token = this.expect('==', '!=', '===', '!=='))) {
            left = {
              type: AST.BinaryExpression,
              operator: token.text,
              left: left,
              right: this.relational()
            };
          }
          return left;
        },
        relational: function() {
          var left = this.additive();
          var token;
          while ((token = this.expect('<', '>', '<=', '>='))) {
            left = {
              type: AST.BinaryExpression,
              operator: token.text,
              left: left,
              right: this.additive()
            };
          }
          return left;
        },
        additive: function() {
          var left = this.multiplicative();
          var token;
          while ((token = this.expect('+', '-'))) {
            left = {
              type: AST.BinaryExpression,
              operator: token.text,
              left: left,
              right: this.multiplicative()
            };
          }
          return left;
        },
        multiplicative: function() {
          var left = this.unary();
          var token;
          while ((token = this.expect('*', '/', '%'))) {
            left = {
              type: AST.BinaryExpression,
              operator: token.text,
              left: left,
              right: this.unary()
            };
          }
          return left;
        },
        unary: function() {
          var token;
          if ((token = this.expect('+', '-', '!'))) {
            return {
              type: AST.UnaryExpression,
              operator: token.text,
              prefix: true,
              argument: this.unary()
            };
          } else {
            return this.primary();
          }
        },
        primary: function() {
          var primary;
          if (this.expect('(')) {
            primary = this.filterChain();
            this.consume(')');
          } else if (this.expect('[')) {
            primary = this.arrayDeclaration();
          } else if (this.expect('{')) {
            primary = this.object();
          } else if (this.selfReferential.hasOwnProperty(this.peek().text)) {
            primary = copy(this.selfReferential[this.consume().text]);
          } else if (this.options.literals.hasOwnProperty(this.peek().text)) {
            primary = {
              type: AST.Literal,
              value: this.options.literals[this.consume().text]
            };
          } else if (this.peek().identifier) {
            primary = this.identifier();
          } else if (this.peek().constant) {
            primary = this.constant();
          } else {
            this.throwError('not a primary expression', this.peek());
          }
          var next;
          while ((next = this.expect('(', '[', '.'))) {
            if (next.text === '(') {
              primary = {
                type: AST.CallExpression,
                callee: primary,
                arguments: this.parseArguments()
              };
              this.consume(')');
            } else if (next.text === '[') {
              primary = {
                type: AST.MemberExpression,
                object: primary,
                property: this.expression(),
                computed: true
              };
              this.consume(']');
            } else if (next.text === '.') {
              primary = {
                type: AST.MemberExpression,
                object: primary,
                property: this.identifier(),
                computed: false
              };
            } else {
              this.throwError('IMPOSSIBLE');
            }
          }
          return primary;
        },
        filter: function(baseExpression) {
          var args = [baseExpression];
          var result = {
            type: AST.CallExpression,
            callee: this.identifier(),
            arguments: args,
            filter: true
          };
          while (this.expect(':')) {
            args.push(this.expression());
          }
          return result;
        },
        parseArguments: function() {
          var args = [];
          if (this.peekToken().text !== ')') {
            do {
              args.push(this.filterChain());
            } while (this.expect(','));
          }
          return args;
        },
        identifier: function() {
          var token = this.consume();
          if (!token.identifier) {
            this.throwError('is not a valid identifier', token);
          }
          return {
            type: AST.Identifier,
            name: token.text
          };
        },
        constant: function() {
          return {
            type: AST.Literal,
            value: this.consume().value
          };
        },
        arrayDeclaration: function() {
          var elements = [];
          if (this.peekToken().text !== ']') {
            do {
              if (this.peek(']')) {
                break;
              }
              elements.push(this.expression());
            } while (this.expect(','));
          }
          this.consume(']');
          return {
            type: AST.ArrayExpression,
            elements: elements
          };
        },
        object: function() {
          var properties = [],
              property;
          if (this.peekToken().text !== '}') {
            do {
              if (this.peek('}')) {
                break;
              }
              property = {
                type: AST.Property,
                kind: 'init'
              };
              if (this.peek().constant) {
                property.key = this.constant();
                property.computed = false;
                this.consume(':');
                property.value = this.expression();
              } else if (this.peek().identifier) {
                property.key = this.identifier();
                property.computed = false;
                if (this.peek(':')) {
                  this.consume(':');
                  property.value = this.expression();
                } else {
                  property.value = property.key;
                }
              } else if (this.peek('[')) {
                this.consume('[');
                property.key = this.expression();
                this.consume(']');
                property.computed = true;
                this.consume(':');
                property.value = this.expression();
              } else {
                this.throwError("invalid key", this.peek());
              }
              properties.push(property);
            } while (this.expect(','));
          }
          this.consume('}');
          return {
            type: AST.ObjectExpression,
            properties: properties
          };
        },
        throwError: function(msg, token) {
          throw $parseMinErr('syntax', 'Syntax Error: Token \'{0}\' {1} at column {2} of the expression [{3}] starting at [{4}].', token.text, msg, (token.index + 1), this.text, this.text.substring(token.index));
        },
        consume: function(e1) {
          if (this.tokens.length === 0) {
            throw $parseMinErr('ueoe', 'Unexpected end of expression: {0}', this.text);
          }
          var token = this.expect(e1);
          if (!token) {
            this.throwError('is unexpected, expecting [' + e1 + ']', this.peek());
          }
          return token;
        },
        peekToken: function() {
          if (this.tokens.length === 0) {
            throw $parseMinErr('ueoe', 'Unexpected end of expression: {0}', this.text);
          }
          return this.tokens[0];
        },
        peek: function(e1, e2, e3, e4) {
          return this.peekAhead(0, e1, e2, e3, e4);
        },
        peekAhead: function(i, e1, e2, e3, e4) {
          if (this.tokens.length > i) {
            var token = this.tokens[i];
            var t = token.text;
            if (t === e1 || t === e2 || t === e3 || t === e4 || (!e1 && !e2 && !e3 && !e4)) {
              return token;
            }
          }
          return false;
        },
        expect: function(e1, e2, e3, e4) {
          var token = this.peek(e1, e2, e3, e4);
          if (token) {
            this.tokens.shift();
            return token;
          }
          return false;
        },
        selfReferential: {
          'this': {type: AST.ThisExpression},
          '$locals': {type: AST.LocalsExpression}
        }
      };
      function ifDefined(v, d) {
        return typeof v !== 'undefined' ? v : d;
      }
      function plusFn(l, r) {
        if (typeof l === 'undefined')
          return r;
        if (typeof r === 'undefined')
          return l;
        return l + r;
      }
      function isStateless($filter, filterName) {
        var fn = $filter(filterName);
        return !fn.$stateful;
      }
      function findConstantAndWatchExpressions(ast, $filter) {
        var allConstants;
        var argsToWatch;
        switch (ast.type) {
          case AST.Program:
            allConstants = true;
            forEach(ast.body, function(expr) {
              findConstantAndWatchExpressions(expr.expression, $filter);
              allConstants = allConstants && expr.expression.constant;
            });
            ast.constant = allConstants;
            break;
          case AST.Literal:
            ast.constant = true;
            ast.toWatch = [];
            break;
          case AST.UnaryExpression:
            findConstantAndWatchExpressions(ast.argument, $filter);
            ast.constant = ast.argument.constant;
            ast.toWatch = ast.argument.toWatch;
            break;
          case AST.BinaryExpression:
            findConstantAndWatchExpressions(ast.left, $filter);
            findConstantAndWatchExpressions(ast.right, $filter);
            ast.constant = ast.left.constant && ast.right.constant;
            ast.toWatch = ast.left.toWatch.concat(ast.right.toWatch);
            break;
          case AST.LogicalExpression:
            findConstantAndWatchExpressions(ast.left, $filter);
            findConstantAndWatchExpressions(ast.right, $filter);
            ast.constant = ast.left.constant && ast.right.constant;
            ast.toWatch = ast.constant ? [] : [ast];
            break;
          case AST.ConditionalExpression:
            findConstantAndWatchExpressions(ast.test, $filter);
            findConstantAndWatchExpressions(ast.alternate, $filter);
            findConstantAndWatchExpressions(ast.consequent, $filter);
            ast.constant = ast.test.constant && ast.alternate.constant && ast.consequent.constant;
            ast.toWatch = ast.constant ? [] : [ast];
            break;
          case AST.Identifier:
            ast.constant = false;
            ast.toWatch = [ast];
            break;
          case AST.MemberExpression:
            findConstantAndWatchExpressions(ast.object, $filter);
            if (ast.computed) {
              findConstantAndWatchExpressions(ast.property, $filter);
            }
            ast.constant = ast.object.constant && (!ast.computed || ast.property.constant);
            ast.toWatch = [ast];
            break;
          case AST.CallExpression:
            allConstants = ast.filter ? isStateless($filter, ast.callee.name) : false;
            argsToWatch = [];
            forEach(ast.arguments, function(expr) {
              findConstantAndWatchExpressions(expr, $filter);
              allConstants = allConstants && expr.constant;
              if (!expr.constant) {
                argsToWatch.push.apply(argsToWatch, expr.toWatch);
              }
            });
            ast.constant = allConstants;
            ast.toWatch = ast.filter && isStateless($filter, ast.callee.name) ? argsToWatch : [ast];
            break;
          case AST.AssignmentExpression:
            findConstantAndWatchExpressions(ast.left, $filter);
            findConstantAndWatchExpressions(ast.right, $filter);
            ast.constant = ast.left.constant && ast.right.constant;
            ast.toWatch = [ast];
            break;
          case AST.ArrayExpression:
            allConstants = true;
            argsToWatch = [];
            forEach(ast.elements, function(expr) {
              findConstantAndWatchExpressions(expr, $filter);
              allConstants = allConstants && expr.constant;
              if (!expr.constant) {
                argsToWatch.push.apply(argsToWatch, expr.toWatch);
              }
            });
            ast.constant = allConstants;
            ast.toWatch = argsToWatch;
            break;
          case AST.ObjectExpression:
            allConstants = true;
            argsToWatch = [];
            forEach(ast.properties, function(property) {
              findConstantAndWatchExpressions(property.value, $filter);
              allConstants = allConstants && property.value.constant && !property.computed;
              if (!property.value.constant) {
                argsToWatch.push.apply(argsToWatch, property.value.toWatch);
              }
            });
            ast.constant = allConstants;
            ast.toWatch = argsToWatch;
            break;
          case AST.ThisExpression:
            ast.constant = false;
            ast.toWatch = [];
            break;
          case AST.LocalsExpression:
            ast.constant = false;
            ast.toWatch = [];
            break;
        }
      }
      function getInputs(body) {
        if (body.length != 1)
          return;
        var lastExpression = body[0].expression;
        var candidate = lastExpression.toWatch;
        if (candidate.length !== 1)
          return candidate;
        return candidate[0] !== lastExpression ? candidate : undefined;
      }
      function isAssignable(ast) {
        return ast.type === AST.Identifier || ast.type === AST.MemberExpression;
      }
      function assignableAST(ast) {
        if (ast.body.length === 1 && isAssignable(ast.body[0].expression)) {
          return {
            type: AST.AssignmentExpression,
            left: ast.body[0].expression,
            right: {type: AST.NGValueParameter},
            operator: '='
          };
        }
      }
      function isLiteral(ast) {
        return ast.body.length === 0 || ast.body.length === 1 && (ast.body[0].expression.type === AST.Literal || ast.body[0].expression.type === AST.ArrayExpression || ast.body[0].expression.type === AST.ObjectExpression);
      }
      function isConstant(ast) {
        return ast.constant;
      }
      function ASTCompiler(astBuilder, $filter) {
        this.astBuilder = astBuilder;
        this.$filter = $filter;
      }
      ASTCompiler.prototype = {
        compile: function(expression, expensiveChecks) {
          var self = this;
          var ast = this.astBuilder.ast(expression);
          this.state = {
            nextId: 0,
            filters: {},
            expensiveChecks: expensiveChecks,
            fn: {
              vars: [],
              body: [],
              own: {}
            },
            assign: {
              vars: [],
              body: [],
              own: {}
            },
            inputs: []
          };
          findConstantAndWatchExpressions(ast, self.$filter);
          var extra = '';
          var assignable;
          this.stage = 'assign';
          if ((assignable = assignableAST(ast))) {
            this.state.computing = 'assign';
            var result = this.nextId();
            this.recurse(assignable, result);
            this.return_(result);
            extra = 'fn.assign=' + this.generateFunction('assign', 's,v,l');
          }
          var toWatch = getInputs(ast.body);
          self.stage = 'inputs';
          forEach(toWatch, function(watch, key) {
            var fnKey = 'fn' + key;
            self.state[fnKey] = {
              vars: [],
              body: [],
              own: {}
            };
            self.state.computing = fnKey;
            var intoId = self.nextId();
            self.recurse(watch, intoId);
            self.return_(intoId);
            self.state.inputs.push(fnKey);
            watch.watchId = key;
          });
          this.state.computing = 'fn';
          this.stage = 'main';
          this.recurse(ast);
          var fnString = '"' + this.USE + ' ' + this.STRICT + '";\n' + this.filterPrefix() + 'var fn=' + this.generateFunction('fn', 's,l,a,i') + extra + this.watchFns() + 'return fn;';
          var fn = (new Function('$filter', 'ensureSafeMemberName', 'ensureSafeObject', 'ensureSafeFunction', 'getStringValue', 'ensureSafeAssignContext', 'ifDefined', 'plus', 'text', fnString))(this.$filter, ensureSafeMemberName, ensureSafeObject, ensureSafeFunction, getStringValue, ensureSafeAssignContext, ifDefined, plusFn, expression);
          this.state = this.stage = undefined;
          fn.literal = isLiteral(ast);
          fn.constant = isConstant(ast);
          return fn;
        },
        USE: 'use',
        STRICT: 'strict',
        watchFns: function() {
          var result = [];
          var fns = this.state.inputs;
          var self = this;
          forEach(fns, function(name) {
            result.push('var ' + name + '=' + self.generateFunction(name, 's'));
          });
          if (fns.length) {
            result.push('fn.inputs=[' + fns.join(',') + '];');
          }
          return result.join('');
        },
        generateFunction: function(name, params) {
          return 'function(' + params + '){' + this.varsPrefix(name) + this.body(name) + '};';
        },
        filterPrefix: function() {
          var parts = [];
          var self = this;
          forEach(this.state.filters, function(id, filter) {
            parts.push(id + '=$filter(' + self.escape(filter) + ')');
          });
          if (parts.length)
            return 'var ' + parts.join(',') + ';';
          return '';
        },
        varsPrefix: function(section) {
          return this.state[section].vars.length ? 'var ' + this.state[section].vars.join(',') + ';' : '';
        },
        body: function(section) {
          return this.state[section].body.join('');
        },
        recurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
          var left,
              right,
              self = this,
              args,
              expression,
              computed;
          recursionFn = recursionFn || noop;
          if (!skipWatchIdCheck && isDefined(ast.watchId)) {
            intoId = intoId || this.nextId();
            this.if_('i', this.lazyAssign(intoId, this.computedMember('i', ast.watchId)), this.lazyRecurse(ast, intoId, nameId, recursionFn, create, true));
            return;
          }
          switch (ast.type) {
            case AST.Program:
              forEach(ast.body, function(expression, pos) {
                self.recurse(expression.expression, undefined, undefined, function(expr) {
                  right = expr;
                });
                if (pos !== ast.body.length - 1) {
                  self.current().body.push(right, ';');
                } else {
                  self.return_(right);
                }
              });
              break;
            case AST.Literal:
              expression = this.escape(ast.value);
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.UnaryExpression:
              this.recurse(ast.argument, undefined, undefined, function(expr) {
                right = expr;
              });
              expression = ast.operator + '(' + this.ifDefined(right, 0) + ')';
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.BinaryExpression:
              this.recurse(ast.left, undefined, undefined, function(expr) {
                left = expr;
              });
              this.recurse(ast.right, undefined, undefined, function(expr) {
                right = expr;
              });
              if (ast.operator === '+') {
                expression = this.plus(left, right);
              } else if (ast.operator === '-') {
                expression = this.ifDefined(left, 0) + ast.operator + this.ifDefined(right, 0);
              } else {
                expression = '(' + left + ')' + ast.operator + '(' + right + ')';
              }
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.LogicalExpression:
              intoId = intoId || this.nextId();
              self.recurse(ast.left, intoId);
              self.if_(ast.operator === '&&' ? intoId : self.not(intoId), self.lazyRecurse(ast.right, intoId));
              recursionFn(intoId);
              break;
            case AST.ConditionalExpression:
              intoId = intoId || this.nextId();
              self.recurse(ast.test, intoId);
              self.if_(intoId, self.lazyRecurse(ast.alternate, intoId), self.lazyRecurse(ast.consequent, intoId));
              recursionFn(intoId);
              break;
            case AST.Identifier:
              intoId = intoId || this.nextId();
              if (nameId) {
                nameId.context = self.stage === 'inputs' ? 's' : this.assign(this.nextId(), this.getHasOwnProperty('l', ast.name) + '?l:s');
                nameId.computed = false;
                nameId.name = ast.name;
              }
              ensureSafeMemberName(ast.name);
              self.if_(self.stage === 'inputs' || self.not(self.getHasOwnProperty('l', ast.name)), function() {
                self.if_(self.stage === 'inputs' || 's', function() {
                  if (create && create !== 1) {
                    self.if_(self.not(self.nonComputedMember('s', ast.name)), self.lazyAssign(self.nonComputedMember('s', ast.name), '{}'));
                  }
                  self.assign(intoId, self.nonComputedMember('s', ast.name));
                });
              }, intoId && self.lazyAssign(intoId, self.nonComputedMember('l', ast.name)));
              if (self.state.expensiveChecks || isPossiblyDangerousMemberName(ast.name)) {
                self.addEnsureSafeObject(intoId);
              }
              recursionFn(intoId);
              break;
            case AST.MemberExpression:
              left = nameId && (nameId.context = this.nextId()) || this.nextId();
              intoId = intoId || this.nextId();
              self.recurse(ast.object, left, undefined, function() {
                self.if_(self.notNull(left), function() {
                  if (create && create !== 1) {
                    self.addEnsureSafeAssignContext(left);
                  }
                  if (ast.computed) {
                    right = self.nextId();
                    self.recurse(ast.property, right);
                    self.getStringValue(right);
                    self.addEnsureSafeMemberName(right);
                    if (create && create !== 1) {
                      self.if_(self.not(self.computedMember(left, right)), self.lazyAssign(self.computedMember(left, right), '{}'));
                    }
                    expression = self.ensureSafeObject(self.computedMember(left, right));
                    self.assign(intoId, expression);
                    if (nameId) {
                      nameId.computed = true;
                      nameId.name = right;
                    }
                  } else {
                    ensureSafeMemberName(ast.property.name);
                    if (create && create !== 1) {
                      self.if_(self.not(self.nonComputedMember(left, ast.property.name)), self.lazyAssign(self.nonComputedMember(left, ast.property.name), '{}'));
                    }
                    expression = self.nonComputedMember(left, ast.property.name);
                    if (self.state.expensiveChecks || isPossiblyDangerousMemberName(ast.property.name)) {
                      expression = self.ensureSafeObject(expression);
                    }
                    self.assign(intoId, expression);
                    if (nameId) {
                      nameId.computed = false;
                      nameId.name = ast.property.name;
                    }
                  }
                }, function() {
                  self.assign(intoId, 'undefined');
                });
                recursionFn(intoId);
              }, !!create);
              break;
            case AST.CallExpression:
              intoId = intoId || this.nextId();
              if (ast.filter) {
                right = self.filter(ast.callee.name);
                args = [];
                forEach(ast.arguments, function(expr) {
                  var argument = self.nextId();
                  self.recurse(expr, argument);
                  args.push(argument);
                });
                expression = right + '(' + args.join(',') + ')';
                self.assign(intoId, expression);
                recursionFn(intoId);
              } else {
                right = self.nextId();
                left = {};
                args = [];
                self.recurse(ast.callee, right, left, function() {
                  self.if_(self.notNull(right), function() {
                    self.addEnsureSafeFunction(right);
                    forEach(ast.arguments, function(expr) {
                      self.recurse(expr, self.nextId(), undefined, function(argument) {
                        args.push(self.ensureSafeObject(argument));
                      });
                    });
                    if (left.name) {
                      if (!self.state.expensiveChecks) {
                        self.addEnsureSafeObject(left.context);
                      }
                      expression = self.member(left.context, left.name, left.computed) + '(' + args.join(',') + ')';
                    } else {
                      expression = right + '(' + args.join(',') + ')';
                    }
                    expression = self.ensureSafeObject(expression);
                    self.assign(intoId, expression);
                  }, function() {
                    self.assign(intoId, 'undefined');
                  });
                  recursionFn(intoId);
                });
              }
              break;
            case AST.AssignmentExpression:
              right = this.nextId();
              left = {};
              if (!isAssignable(ast.left)) {
                throw $parseMinErr('lval', 'Trying to assign a value to a non l-value');
              }
              this.recurse(ast.left, undefined, left, function() {
                self.if_(self.notNull(left.context), function() {
                  self.recurse(ast.right, right);
                  self.addEnsureSafeObject(self.member(left.context, left.name, left.computed));
                  self.addEnsureSafeAssignContext(left.context);
                  expression = self.member(left.context, left.name, left.computed) + ast.operator + right;
                  self.assign(intoId, expression);
                  recursionFn(intoId || expression);
                });
              }, 1);
              break;
            case AST.ArrayExpression:
              args = [];
              forEach(ast.elements, function(expr) {
                self.recurse(expr, self.nextId(), undefined, function(argument) {
                  args.push(argument);
                });
              });
              expression = '[' + args.join(',') + ']';
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.ObjectExpression:
              args = [];
              computed = false;
              forEach(ast.properties, function(property) {
                if (property.computed) {
                  computed = true;
                }
              });
              if (computed) {
                intoId = intoId || this.nextId();
                this.assign(intoId, '{}');
                forEach(ast.properties, function(property) {
                  if (property.computed) {
                    left = self.nextId();
                    self.recurse(property.key, left);
                  } else {
                    left = property.key.type === AST.Identifier ? property.key.name : ('' + property.key.value);
                  }
                  right = self.nextId();
                  self.recurse(property.value, right);
                  self.assign(self.member(intoId, left, property.computed), right);
                });
              } else {
                forEach(ast.properties, function(property) {
                  self.recurse(property.value, ast.constant ? undefined : self.nextId(), undefined, function(expr) {
                    args.push(self.escape(property.key.type === AST.Identifier ? property.key.name : ('' + property.key.value)) + ':' + expr);
                  });
                });
                expression = '{' + args.join(',') + '}';
                this.assign(intoId, expression);
              }
              recursionFn(intoId || expression);
              break;
            case AST.ThisExpression:
              this.assign(intoId, 's');
              recursionFn('s');
              break;
            case AST.LocalsExpression:
              this.assign(intoId, 'l');
              recursionFn('l');
              break;
            case AST.NGValueParameter:
              this.assign(intoId, 'v');
              recursionFn('v');
              break;
          }
        },
        getHasOwnProperty: function(element, property) {
          var key = element + '.' + property;
          var own = this.current().own;
          if (!own.hasOwnProperty(key)) {
            own[key] = this.nextId(false, element + '&&(' + this.escape(property) + ' in ' + element + ')');
          }
          return own[key];
        },
        assign: function(id, value) {
          if (!id)
            return;
          this.current().body.push(id, '=', value, ';');
          return id;
        },
        filter: function(filterName) {
          if (!this.state.filters.hasOwnProperty(filterName)) {
            this.state.filters[filterName] = this.nextId(true);
          }
          return this.state.filters[filterName];
        },
        ifDefined: function(id, defaultValue) {
          return 'ifDefined(' + id + ',' + this.escape(defaultValue) + ')';
        },
        plus: function(left, right) {
          return 'plus(' + left + ',' + right + ')';
        },
        return_: function(id) {
          this.current().body.push('return ', id, ';');
        },
        if_: function(test, alternate, consequent) {
          if (test === true) {
            alternate();
          } else {
            var body = this.current().body;
            body.push('if(', test, '){');
            alternate();
            body.push('}');
            if (consequent) {
              body.push('else{');
              consequent();
              body.push('}');
            }
          }
        },
        not: function(expression) {
          return '!(' + expression + ')';
        },
        notNull: function(expression) {
          return expression + '!=null';
        },
        nonComputedMember: function(left, right) {
          var SAFE_IDENTIFIER = /[$_a-zA-Z][$_a-zA-Z0-9]*/;
          var UNSAFE_CHARACTERS = /[^$_a-zA-Z0-9]/g;
          if (SAFE_IDENTIFIER.test(right)) {
            return left + '.' + right;
          } else {
            return left + '["' + right.replace(UNSAFE_CHARACTERS, this.stringEscapeFn) + '"]';
          }
        },
        computedMember: function(left, right) {
          return left + '[' + right + ']';
        },
        member: function(left, right, computed) {
          if (computed)
            return this.computedMember(left, right);
          return this.nonComputedMember(left, right);
        },
        addEnsureSafeObject: function(item) {
          this.current().body.push(this.ensureSafeObject(item), ';');
        },
        addEnsureSafeMemberName: function(item) {
          this.current().body.push(this.ensureSafeMemberName(item), ';');
        },
        addEnsureSafeFunction: function(item) {
          this.current().body.push(this.ensureSafeFunction(item), ';');
        },
        addEnsureSafeAssignContext: function(item) {
          this.current().body.push(this.ensureSafeAssignContext(item), ';');
        },
        ensureSafeObject: function(item) {
          return 'ensureSafeObject(' + item + ',text)';
        },
        ensureSafeMemberName: function(item) {
          return 'ensureSafeMemberName(' + item + ',text)';
        },
        ensureSafeFunction: function(item) {
          return 'ensureSafeFunction(' + item + ',text)';
        },
        getStringValue: function(item) {
          this.assign(item, 'getStringValue(' + item + ')');
        },
        ensureSafeAssignContext: function(item) {
          return 'ensureSafeAssignContext(' + item + ',text)';
        },
        lazyRecurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
          var self = this;
          return function() {
            self.recurse(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck);
          };
        },
        lazyAssign: function(id, value) {
          var self = this;
          return function() {
            self.assign(id, value);
          };
        },
        stringEscapeRegex: /[^ a-zA-Z0-9]/g,
        stringEscapeFn: function(c) {
          return '\\u' + ('0000' + c.charCodeAt(0).toString(16)).slice(-4);
        },
        escape: function(value) {
          if (isString(value))
            return "'" + value.replace(this.stringEscapeRegex, this.stringEscapeFn) + "'";
          if (isNumber(value))
            return value.toString();
          if (value === true)
            return 'true';
          if (value === false)
            return 'false';
          if (value === null)
            return 'null';
          if (typeof value === 'undefined')
            return 'undefined';
          throw $parseMinErr('esc', 'IMPOSSIBLE');
        },
        nextId: function(skip, init) {
          var id = 'v' + (this.state.nextId++);
          if (!skip) {
            this.current().vars.push(id + (init ? '=' + init : ''));
          }
          return id;
        },
        current: function() {
          return this.state[this.state.computing];
        }
      };
      function ASTInterpreter(astBuilder, $filter) {
        this.astBuilder = astBuilder;
        this.$filter = $filter;
      }
      ASTInterpreter.prototype = {
        compile: function(expression, expensiveChecks) {
          var self = this;
          var ast = this.astBuilder.ast(expression);
          this.expression = expression;
          this.expensiveChecks = expensiveChecks;
          findConstantAndWatchExpressions(ast, self.$filter);
          var assignable;
          var assign;
          if ((assignable = assignableAST(ast))) {
            assign = this.recurse(assignable);
          }
          var toWatch = getInputs(ast.body);
          var inputs;
          if (toWatch) {
            inputs = [];
            forEach(toWatch, function(watch, key) {
              var input = self.recurse(watch);
              watch.input = input;
              inputs.push(input);
              watch.watchId = key;
            });
          }
          var expressions = [];
          forEach(ast.body, function(expression) {
            expressions.push(self.recurse(expression.expression));
          });
          var fn = ast.body.length === 0 ? noop : ast.body.length === 1 ? expressions[0] : function(scope, locals) {
            var lastValue;
            forEach(expressions, function(exp) {
              lastValue = exp(scope, locals);
            });
            return lastValue;
          };
          if (assign) {
            fn.assign = function(scope, value, locals) {
              return assign(scope, locals, value);
            };
          }
          if (inputs) {
            fn.inputs = inputs;
          }
          fn.literal = isLiteral(ast);
          fn.constant = isConstant(ast);
          return fn;
        },
        recurse: function(ast, context, create) {
          var left,
              right,
              self = this,
              args,
              expression;
          if (ast.input) {
            return this.inputs(ast.input, ast.watchId);
          }
          switch (ast.type) {
            case AST.Literal:
              return this.value(ast.value, context);
            case AST.UnaryExpression:
              right = this.recurse(ast.argument);
              return this['unary' + ast.operator](right, context);
            case AST.BinaryExpression:
              left = this.recurse(ast.left);
              right = this.recurse(ast.right);
              return this['binary' + ast.operator](left, right, context);
            case AST.LogicalExpression:
              left = this.recurse(ast.left);
              right = this.recurse(ast.right);
              return this['binary' + ast.operator](left, right, context);
            case AST.ConditionalExpression:
              return this['ternary?:'](this.recurse(ast.test), this.recurse(ast.alternate), this.recurse(ast.consequent), context);
            case AST.Identifier:
              ensureSafeMemberName(ast.name, self.expression);
              return self.identifier(ast.name, self.expensiveChecks || isPossiblyDangerousMemberName(ast.name), context, create, self.expression);
            case AST.MemberExpression:
              left = this.recurse(ast.object, false, !!create);
              if (!ast.computed) {
                ensureSafeMemberName(ast.property.name, self.expression);
                right = ast.property.name;
              }
              if (ast.computed)
                right = this.recurse(ast.property);
              return ast.computed ? this.computedMember(left, right, context, create, self.expression) : this.nonComputedMember(left, right, self.expensiveChecks, context, create, self.expression);
            case AST.CallExpression:
              args = [];
              forEach(ast.arguments, function(expr) {
                args.push(self.recurse(expr));
              });
              if (ast.filter)
                right = this.$filter(ast.callee.name);
              if (!ast.filter)
                right = this.recurse(ast.callee, true);
              return ast.filter ? function(scope, locals, assign, inputs) {
                var values = [];
                for (var i = 0; i < args.length; ++i) {
                  values.push(args[i](scope, locals, assign, inputs));
                }
                var value = right.apply(undefined, values, inputs);
                return context ? {
                  context: undefined,
                  name: undefined,
                  value: value
                } : value;
              } : function(scope, locals, assign, inputs) {
                var rhs = right(scope, locals, assign, inputs);
                var value;
                if (rhs.value != null) {
                  ensureSafeObject(rhs.context, self.expression);
                  ensureSafeFunction(rhs.value, self.expression);
                  var values = [];
                  for (var i = 0; i < args.length; ++i) {
                    values.push(ensureSafeObject(args[i](scope, locals, assign, inputs), self.expression));
                  }
                  value = ensureSafeObject(rhs.value.apply(rhs.context, values), self.expression);
                }
                return context ? {value: value} : value;
              };
            case AST.AssignmentExpression:
              left = this.recurse(ast.left, true, 1);
              right = this.recurse(ast.right);
              return function(scope, locals, assign, inputs) {
                var lhs = left(scope, locals, assign, inputs);
                var rhs = right(scope, locals, assign, inputs);
                ensureSafeObject(lhs.value, self.expression);
                ensureSafeAssignContext(lhs.context);
                lhs.context[lhs.name] = rhs;
                return context ? {value: rhs} : rhs;
              };
            case AST.ArrayExpression:
              args = [];
              forEach(ast.elements, function(expr) {
                args.push(self.recurse(expr));
              });
              return function(scope, locals, assign, inputs) {
                var value = [];
                for (var i = 0; i < args.length; ++i) {
                  value.push(args[i](scope, locals, assign, inputs));
                }
                return context ? {value: value} : value;
              };
            case AST.ObjectExpression:
              args = [];
              forEach(ast.properties, function(property) {
                if (property.computed) {
                  args.push({
                    key: self.recurse(property.key),
                    computed: true,
                    value: self.recurse(property.value)
                  });
                } else {
                  args.push({
                    key: property.key.type === AST.Identifier ? property.key.name : ('' + property.key.value),
                    computed: false,
                    value: self.recurse(property.value)
                  });
                }
              });
              return function(scope, locals, assign, inputs) {
                var value = {};
                for (var i = 0; i < args.length; ++i) {
                  if (args[i].computed) {
                    value[args[i].key(scope, locals, assign, inputs)] = args[i].value(scope, locals, assign, inputs);
                  } else {
                    value[args[i].key] = args[i].value(scope, locals, assign, inputs);
                  }
                }
                return context ? {value: value} : value;
              };
            case AST.ThisExpression:
              return function(scope) {
                return context ? {value: scope} : scope;
              };
            case AST.LocalsExpression:
              return function(scope, locals) {
                return context ? {value: locals} : locals;
              };
            case AST.NGValueParameter:
              return function(scope, locals, assign) {
                return context ? {value: assign} : assign;
              };
          }
        },
        'unary+': function(argument, context) {
          return function(scope, locals, assign, inputs) {
            var arg = argument(scope, locals, assign, inputs);
            if (isDefined(arg)) {
              arg = +arg;
            } else {
              arg = 0;
            }
            return context ? {value: arg} : arg;
          };
        },
        'unary-': function(argument, context) {
          return function(scope, locals, assign, inputs) {
            var arg = argument(scope, locals, assign, inputs);
            if (isDefined(arg)) {
              arg = -arg;
            } else {
              arg = 0;
            }
            return context ? {value: arg} : arg;
          };
        },
        'unary!': function(argument, context) {
          return function(scope, locals, assign, inputs) {
            var arg = !argument(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary+': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            var rhs = right(scope, locals, assign, inputs);
            var arg = plusFn(lhs, rhs);
            return context ? {value: arg} : arg;
          };
        },
        'binary-': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            var rhs = right(scope, locals, assign, inputs);
            var arg = (isDefined(lhs) ? lhs : 0) - (isDefined(rhs) ? rhs : 0);
            return context ? {value: arg} : arg;
          };
        },
        'binary*': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) * right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary/': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) / right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary%': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) % right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary===': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) === right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary!==': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) !== right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary==': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) == right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary!=': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) != right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary<': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) < right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary>': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) > right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary<=': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) <= right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary>=': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) >= right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary&&': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) && right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary||': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) || right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'ternary?:': function(test, alternate, consequent, context) {
          return function(scope, locals, assign, inputs) {
            var arg = test(scope, locals, assign, inputs) ? alternate(scope, locals, assign, inputs) : consequent(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        value: function(value, context) {
          return function() {
            return context ? {
              context: undefined,
              name: undefined,
              value: value
            } : value;
          };
        },
        identifier: function(name, expensiveChecks, context, create, expression) {
          return function(scope, locals, assign, inputs) {
            var base = locals && (name in locals) ? locals : scope;
            if (create && create !== 1 && base && !(base[name])) {
              base[name] = {};
            }
            var value = base ? base[name] : undefined;
            if (expensiveChecks) {
              ensureSafeObject(value, expression);
            }
            if (context) {
              return {
                context: base,
                name: name,
                value: value
              };
            } else {
              return value;
            }
          };
        },
        computedMember: function(left, right, context, create, expression) {
          return function(scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            var rhs;
            var value;
            if (lhs != null) {
              rhs = right(scope, locals, assign, inputs);
              rhs = getStringValue(rhs);
              ensureSafeMemberName(rhs, expression);
              if (create && create !== 1) {
                ensureSafeAssignContext(lhs);
                if (lhs && !(lhs[rhs])) {
                  lhs[rhs] = {};
                }
              }
              value = lhs[rhs];
              ensureSafeObject(value, expression);
            }
            if (context) {
              return {
                context: lhs,
                name: rhs,
                value: value
              };
            } else {
              return value;
            }
          };
        },
        nonComputedMember: function(left, right, expensiveChecks, context, create, expression) {
          return function(scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            if (create && create !== 1) {
              ensureSafeAssignContext(lhs);
              if (lhs && !(lhs[right])) {
                lhs[right] = {};
              }
            }
            var value = lhs != null ? lhs[right] : undefined;
            if (expensiveChecks || isPossiblyDangerousMemberName(right)) {
              ensureSafeObject(value, expression);
            }
            if (context) {
              return {
                context: lhs,
                name: right,
                value: value
              };
            } else {
              return value;
            }
          };
        },
        inputs: function(input, watchId) {
          return function(scope, value, locals, inputs) {
            if (inputs)
              return inputs[watchId];
            return input(scope, value, locals);
          };
        }
      };
      var Parser = function(lexer, $filter, options) {
        this.lexer = lexer;
        this.$filter = $filter;
        this.options = options;
        this.ast = new AST(lexer, options);
        this.astCompiler = options.csp ? new ASTInterpreter(this.ast, $filter) : new ASTCompiler(this.ast, $filter);
      };
      Parser.prototype = {
        constructor: Parser,
        parse: function(text) {
          return this.astCompiler.compile(text, this.options.expensiveChecks);
        }
      };
      function isPossiblyDangerousMemberName(name) {
        return name == 'constructor';
      }
      var objectValueOf = Object.prototype.valueOf;
      function getValueOf(value) {
        return isFunction(value.valueOf) ? value.valueOf() : objectValueOf.call(value);
      }
      function $ParseProvider() {
        var cacheDefault = createMap();
        var cacheExpensive = createMap();
        var literals = {
          'true': true,
          'false': false,
          'null': null,
          'undefined': undefined
        };
        var identStart,
            identContinue;
        this.addLiteral = function(literalName, literalValue) {
          literals[literalName] = literalValue;
        };
        this.setIdentifierFns = function(identifierStart, identifierContinue) {
          identStart = identifierStart;
          identContinue = identifierContinue;
          return this;
        };
        this.$get = ['$filter', function($filter) {
          var noUnsafeEval = csp().noUnsafeEval;
          var $parseOptions = {
            csp: noUnsafeEval,
            expensiveChecks: false,
            literals: copy(literals),
            isIdentifierStart: isFunction(identStart) && identStart,
            isIdentifierContinue: isFunction(identContinue) && identContinue
          },
              $parseOptionsExpensive = {
                csp: noUnsafeEval,
                expensiveChecks: true,
                literals: copy(literals),
                isIdentifierStart: isFunction(identStart) && identStart,
                isIdentifierContinue: isFunction(identContinue) && identContinue
              };
          var runningChecksEnabled = false;
          $parse.$$runningExpensiveChecks = function() {
            return runningChecksEnabled;
          };
          return $parse;
          function $parse(exp, interceptorFn, expensiveChecks) {
            var parsedExpression,
                oneTime,
                cacheKey;
            expensiveChecks = expensiveChecks || runningChecksEnabled;
            switch (typeof exp) {
              case 'string':
                exp = exp.trim();
                cacheKey = exp;
                var cache = (expensiveChecks ? cacheExpensive : cacheDefault);
                parsedExpression = cache[cacheKey];
                if (!parsedExpression) {
                  if (exp.charAt(0) === ':' && exp.charAt(1) === ':') {
                    oneTime = true;
                    exp = exp.substring(2);
                  }
                  var parseOptions = expensiveChecks ? $parseOptionsExpensive : $parseOptions;
                  var lexer = new Lexer(parseOptions);
                  var parser = new Parser(lexer, $filter, parseOptions);
                  parsedExpression = parser.parse(exp);
                  if (parsedExpression.constant) {
                    parsedExpression.$$watchDelegate = constantWatchDelegate;
                  } else if (oneTime) {
                    parsedExpression.$$watchDelegate = parsedExpression.literal ? oneTimeLiteralWatchDelegate : oneTimeWatchDelegate;
                  } else if (parsedExpression.inputs) {
                    parsedExpression.$$watchDelegate = inputsWatchDelegate;
                  }
                  if (expensiveChecks) {
                    parsedExpression = expensiveChecksInterceptor(parsedExpression);
                  }
                  cache[cacheKey] = parsedExpression;
                }
                return addInterceptor(parsedExpression, interceptorFn);
              case 'function':
                return addInterceptor(exp, interceptorFn);
              default:
                return addInterceptor(noop, interceptorFn);
            }
          }
          function expensiveChecksInterceptor(fn) {
            if (!fn)
              return fn;
            expensiveCheckFn.$$watchDelegate = fn.$$watchDelegate;
            expensiveCheckFn.assign = expensiveChecksInterceptor(fn.assign);
            expensiveCheckFn.constant = fn.constant;
            expensiveCheckFn.literal = fn.literal;
            for (var i = 0; fn.inputs && i < fn.inputs.length; ++i) {
              fn.inputs[i] = expensiveChecksInterceptor(fn.inputs[i]);
            }
            expensiveCheckFn.inputs = fn.inputs;
            return expensiveCheckFn;
            function expensiveCheckFn(scope, locals, assign, inputs) {
              var expensiveCheckOldValue = runningChecksEnabled;
              runningChecksEnabled = true;
              try {
                return fn(scope, locals, assign, inputs);
              } finally {
                runningChecksEnabled = expensiveCheckOldValue;
              }
            }
          }
          function expressionInputDirtyCheck(newValue, oldValueOfValue) {
            if (newValue == null || oldValueOfValue == null) {
              return newValue === oldValueOfValue;
            }
            if (typeof newValue === 'object') {
              newValue = getValueOf(newValue);
              if (typeof newValue === 'object') {
                return false;
              }
            }
            return newValue === oldValueOfValue || (newValue !== newValue && oldValueOfValue !== oldValueOfValue);
          }
          function inputsWatchDelegate(scope, listener, objectEquality, parsedExpression, prettyPrintExpression) {
            var inputExpressions = parsedExpression.inputs;
            var lastResult;
            if (inputExpressions.length === 1) {
              var oldInputValueOf = expressionInputDirtyCheck;
              inputExpressions = inputExpressions[0];
              return scope.$watch(function expressionInputWatch(scope) {
                var newInputValue = inputExpressions(scope);
                if (!expressionInputDirtyCheck(newInputValue, oldInputValueOf)) {
                  lastResult = parsedExpression(scope, undefined, undefined, [newInputValue]);
                  oldInputValueOf = newInputValue && getValueOf(newInputValue);
                }
                return lastResult;
              }, listener, objectEquality, prettyPrintExpression);
            }
            var oldInputValueOfValues = [];
            var oldInputValues = [];
            for (var i = 0,
                ii = inputExpressions.length; i < ii; i++) {
              oldInputValueOfValues[i] = expressionInputDirtyCheck;
              oldInputValues[i] = null;
            }
            return scope.$watch(function expressionInputsWatch(scope) {
              var changed = false;
              for (var i = 0,
                  ii = inputExpressions.length; i < ii; i++) {
                var newInputValue = inputExpressions[i](scope);
                if (changed || (changed = !expressionInputDirtyCheck(newInputValue, oldInputValueOfValues[i]))) {
                  oldInputValues[i] = newInputValue;
                  oldInputValueOfValues[i] = newInputValue && getValueOf(newInputValue);
                }
              }
              if (changed) {
                lastResult = parsedExpression(scope, undefined, undefined, oldInputValues);
              }
              return lastResult;
            }, listener, objectEquality, prettyPrintExpression);
          }
          function oneTimeWatchDelegate(scope, listener, objectEquality, parsedExpression) {
            var unwatch,
                lastValue;
            return unwatch = scope.$watch(function oneTimeWatch(scope) {
              return parsedExpression(scope);
            }, function oneTimeListener(value, old, scope) {
              lastValue = value;
              if (isFunction(listener)) {
                listener.apply(this, arguments);
              }
              if (isDefined(value)) {
                scope.$$postDigest(function() {
                  if (isDefined(lastValue)) {
                    unwatch();
                  }
                });
              }
            }, objectEquality);
          }
          function oneTimeLiteralWatchDelegate(scope, listener, objectEquality, parsedExpression) {
            var unwatch,
                lastValue;
            return unwatch = scope.$watch(function oneTimeWatch(scope) {
              return parsedExpression(scope);
            }, function oneTimeListener(value, old, scope) {
              lastValue = value;
              if (isFunction(listener)) {
                listener.call(this, value, old, scope);
              }
              if (isAllDefined(value)) {
                scope.$$postDigest(function() {
                  if (isAllDefined(lastValue))
                    unwatch();
                });
              }
            }, objectEquality);
            function isAllDefined(value) {
              var allDefined = true;
              forEach(value, function(val) {
                if (!isDefined(val))
                  allDefined = false;
              });
              return allDefined;
            }
          }
          function constantWatchDelegate(scope, listener, objectEquality, parsedExpression) {
            var unwatch;
            return unwatch = scope.$watch(function constantWatch(scope) {
              unwatch();
              return parsedExpression(scope);
            }, listener, objectEquality);
          }
          function addInterceptor(parsedExpression, interceptorFn) {
            if (!interceptorFn)
              return parsedExpression;
            var watchDelegate = parsedExpression.$$watchDelegate;
            var useInputs = false;
            var regularWatch = watchDelegate !== oneTimeLiteralWatchDelegate && watchDelegate !== oneTimeWatchDelegate;
            var fn = regularWatch ? function regularInterceptedExpression(scope, locals, assign, inputs) {
              var value = useInputs && inputs ? inputs[0] : parsedExpression(scope, locals, assign, inputs);
              return interceptorFn(value, scope, locals);
            } : function oneTimeInterceptedExpression(scope, locals, assign, inputs) {
              var value = parsedExpression(scope, locals, assign, inputs);
              var result = interceptorFn(value, scope, locals);
              return isDefined(value) ? result : value;
            };
            if (parsedExpression.$$watchDelegate && parsedExpression.$$watchDelegate !== inputsWatchDelegate) {
              fn.$$watchDelegate = parsedExpression.$$watchDelegate;
            } else if (!interceptorFn.$stateful) {
              fn.$$watchDelegate = inputsWatchDelegate;
              useInputs = !parsedExpression.inputs;
              fn.inputs = parsedExpression.inputs ? parsedExpression.inputs : [parsedExpression];
            }
            return fn;
          }
        }];
      }
      function $QProvider() {
        this.$get = ['$rootScope', '$exceptionHandler', function($rootScope, $exceptionHandler) {
          return qFactory(function(callback) {
            $rootScope.$evalAsync(callback);
          }, $exceptionHandler);
        }];
      }
      function $$QProvider() {
        this.$get = ['$browser', '$exceptionHandler', function($browser, $exceptionHandler) {
          return qFactory(function(callback) {
            $browser.defer(callback);
          }, $exceptionHandler);
        }];
      }
      function qFactory(nextTick, exceptionHandler) {
        var $qMinErr = minErr('$q', TypeError);
        var defer = function() {
          var d = new Deferred();
          d.resolve = simpleBind(d, d.resolve);
          d.reject = simpleBind(d, d.reject);
          d.notify = simpleBind(d, d.notify);
          return d;
        };
        function Promise() {
          this.$$state = {status: 0};
        }
        extend(Promise.prototype, {
          then: function(onFulfilled, onRejected, progressBack) {
            if (isUndefined(onFulfilled) && isUndefined(onRejected) && isUndefined(progressBack)) {
              return this;
            }
            var result = new Deferred();
            this.$$state.pending = this.$$state.pending || [];
            this.$$state.pending.push([result, onFulfilled, onRejected, progressBack]);
            if (this.$$state.status > 0)
              scheduleProcessQueue(this.$$state);
            return result.promise;
          },
          "catch": function(callback) {
            return this.then(null, callback);
          },
          "finally": function(callback, progressBack) {
            return this.then(function(value) {
              return handleCallback(value, true, callback);
            }, function(error) {
              return handleCallback(error, false, callback);
            }, progressBack);
          }
        });
        function simpleBind(context, fn) {
          return function(value) {
            fn.call(context, value);
          };
        }
        function processQueue(state) {
          var fn,
              deferred,
              pending;
          pending = state.pending;
          state.processScheduled = false;
          state.pending = undefined;
          for (var i = 0,
              ii = pending.length; i < ii; ++i) {
            deferred = pending[i][0];
            fn = pending[i][state.status];
            try {
              if (isFunction(fn)) {
                deferred.resolve(fn(state.value));
              } else if (state.status === 1) {
                deferred.resolve(state.value);
              } else {
                deferred.reject(state.value);
              }
            } catch (e) {
              deferred.reject(e);
              exceptionHandler(e);
            }
          }
        }
        function scheduleProcessQueue(state) {
          if (state.processScheduled || !state.pending)
            return;
          state.processScheduled = true;
          nextTick(function() {
            processQueue(state);
          });
        }
        function Deferred() {
          this.promise = new Promise();
        }
        extend(Deferred.prototype, {
          resolve: function(val) {
            if (this.promise.$$state.status)
              return;
            if (val === this.promise) {
              this.$$reject($qMinErr('qcycle', "Expected promise to be resolved with value other than itself '{0}'", val));
            } else {
              this.$$resolve(val);
            }
          },
          $$resolve: function(val) {
            var then;
            var that = this;
            var done = false;
            try {
              if ((isObject(val) || isFunction(val)))
                then = val && val.then;
              if (isFunction(then)) {
                this.promise.$$state.status = -1;
                then.call(val, resolvePromise, rejectPromise, simpleBind(this, this.notify));
              } else {
                this.promise.$$state.value = val;
                this.promise.$$state.status = 1;
                scheduleProcessQueue(this.promise.$$state);
              }
            } catch (e) {
              rejectPromise(e);
              exceptionHandler(e);
            }
            function resolvePromise(val) {
              if (done)
                return;
              done = true;
              that.$$resolve(val);
            }
            function rejectPromise(val) {
              if (done)
                return;
              done = true;
              that.$$reject(val);
            }
          },
          reject: function(reason) {
            if (this.promise.$$state.status)
              return;
            this.$$reject(reason);
          },
          $$reject: function(reason) {
            this.promise.$$state.value = reason;
            this.promise.$$state.status = 2;
            scheduleProcessQueue(this.promise.$$state);
          },
          notify: function(progress) {
            var callbacks = this.promise.$$state.pending;
            if ((this.promise.$$state.status <= 0) && callbacks && callbacks.length) {
              nextTick(function() {
                var callback,
                    result;
                for (var i = 0,
                    ii = callbacks.length; i < ii; i++) {
                  result = callbacks[i][0];
                  callback = callbacks[i][3];
                  try {
                    result.notify(isFunction(callback) ? callback(progress) : progress);
                  } catch (e) {
                    exceptionHandler(e);
                  }
                }
              });
            }
          }
        });
        var reject = function(reason) {
          var result = new Deferred();
          result.reject(reason);
          return result.promise;
        };
        var makePromise = function makePromise(value, resolved) {
          var result = new Deferred();
          if (resolved) {
            result.resolve(value);
          } else {
            result.reject(value);
          }
          return result.promise;
        };
        var handleCallback = function handleCallback(value, isResolved, callback) {
          var callbackOutput = null;
          try {
            if (isFunction(callback))
              callbackOutput = callback();
          } catch (e) {
            return makePromise(e, false);
          }
          if (isPromiseLike(callbackOutput)) {
            return callbackOutput.then(function() {
              return makePromise(value, isResolved);
            }, function(error) {
              return makePromise(error, false);
            });
          } else {
            return makePromise(value, isResolved);
          }
        };
        var when = function(value, callback, errback, progressBack) {
          var result = new Deferred();
          result.resolve(value);
          return result.promise.then(callback, errback, progressBack);
        };
        var resolve = when;
        function all(promises) {
          var deferred = new Deferred(),
              counter = 0,
              results = isArray(promises) ? [] : {};
          forEach(promises, function(promise, key) {
            counter++;
            when(promise).then(function(value) {
              if (results.hasOwnProperty(key))
                return;
              results[key] = value;
              if (!(--counter))
                deferred.resolve(results);
            }, function(reason) {
              if (results.hasOwnProperty(key))
                return;
              deferred.reject(reason);
            });
          });
          if (counter === 0) {
            deferred.resolve(results);
          }
          return deferred.promise;
        }
        var $Q = function Q(resolver) {
          if (!isFunction(resolver)) {
            throw $qMinErr('norslvr', "Expected resolverFn, got '{0}'", resolver);
          }
          var deferred = new Deferred();
          function resolveFn(value) {
            deferred.resolve(value);
          }
          function rejectFn(reason) {
            deferred.reject(reason);
          }
          resolver(resolveFn, rejectFn);
          return deferred.promise;
        };
        $Q.prototype = Promise.prototype;
        $Q.defer = defer;
        $Q.reject = reject;
        $Q.when = when;
        $Q.resolve = resolve;
        $Q.all = all;
        return $Q;
      }
      function $$RAFProvider() {
        this.$get = ['$window', '$timeout', function($window, $timeout) {
          var requestAnimationFrame = $window.requestAnimationFrame || $window.webkitRequestAnimationFrame;
          var cancelAnimationFrame = $window.cancelAnimationFrame || $window.webkitCancelAnimationFrame || $window.webkitCancelRequestAnimationFrame;
          var rafSupported = !!requestAnimationFrame;
          var raf = rafSupported ? function(fn) {
            var id = requestAnimationFrame(fn);
            return function() {
              cancelAnimationFrame(id);
            };
          } : function(fn) {
            var timer = $timeout(fn, 16.66, false);
            return function() {
              $timeout.cancel(timer);
            };
          };
          raf.supported = rafSupported;
          return raf;
        }];
      }
      function $RootScopeProvider() {
        var TTL = 10;
        var $rootScopeMinErr = minErr('$rootScope');
        var lastDirtyWatch = null;
        var applyAsyncId = null;
        this.digestTtl = function(value) {
          if (arguments.length) {
            TTL = value;
          }
          return TTL;
        };
        function createChildScopeClass(parent) {
          function ChildScope() {
            this.$$watchers = this.$$nextSibling = this.$$childHead = this.$$childTail = null;
            this.$$listeners = {};
            this.$$listenerCount = {};
            this.$$watchersCount = 0;
            this.$id = nextUid();
            this.$$ChildScope = null;
          }
          ChildScope.prototype = parent;
          return ChildScope;
        }
        this.$get = ['$exceptionHandler', '$parse', '$browser', function($exceptionHandler, $parse, $browser) {
          function destroyChildScope($event) {
            $event.currentScope.$$destroyed = true;
          }
          function cleanUpScope($scope) {
            if (msie === 9) {
              $scope.$$childHead && cleanUpScope($scope.$$childHead);
              $scope.$$nextSibling && cleanUpScope($scope.$$nextSibling);
            }
            $scope.$parent = $scope.$$nextSibling = $scope.$$prevSibling = $scope.$$childHead = $scope.$$childTail = $scope.$root = $scope.$$watchers = null;
          }
          function Scope() {
            this.$id = nextUid();
            this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null;
            this.$root = this;
            this.$$destroyed = false;
            this.$$listeners = {};
            this.$$listenerCount = {};
            this.$$watchersCount = 0;
            this.$$isolateBindings = null;
          }
          Scope.prototype = {
            constructor: Scope,
            $new: function(isolate, parent) {
              var child;
              parent = parent || this;
              if (isolate) {
                child = new Scope();
                child.$root = this.$root;
              } else {
                if (!this.$$ChildScope) {
                  this.$$ChildScope = createChildScopeClass(this);
                }
                child = new this.$$ChildScope();
              }
              child.$parent = parent;
              child.$$prevSibling = parent.$$childTail;
              if (parent.$$childHead) {
                parent.$$childTail.$$nextSibling = child;
                parent.$$childTail = child;
              } else {
                parent.$$childHead = parent.$$childTail = child;
              }
              if (isolate || parent != this)
                child.$on('$destroy', destroyChildScope);
              return child;
            },
            $watch: function(watchExp, listener, objectEquality, prettyPrintExpression) {
              var get = $parse(watchExp);
              if (get.$$watchDelegate) {
                return get.$$watchDelegate(this, listener, objectEquality, get, watchExp);
              }
              var scope = this,
                  array = scope.$$watchers,
                  watcher = {
                    fn: listener,
                    last: initWatchVal,
                    get: get,
                    exp: prettyPrintExpression || watchExp,
                    eq: !!objectEquality
                  };
              lastDirtyWatch = null;
              if (!isFunction(listener)) {
                watcher.fn = noop;
              }
              if (!array) {
                array = scope.$$watchers = [];
              }
              array.unshift(watcher);
              incrementWatchersCount(this, 1);
              return function deregisterWatch() {
                if (arrayRemove(array, watcher) >= 0) {
                  incrementWatchersCount(scope, -1);
                }
                lastDirtyWatch = null;
              };
            },
            $watchGroup: function(watchExpressions, listener) {
              var oldValues = new Array(watchExpressions.length);
              var newValues = new Array(watchExpressions.length);
              var deregisterFns = [];
              var self = this;
              var changeReactionScheduled = false;
              var firstRun = true;
              if (!watchExpressions.length) {
                var shouldCall = true;
                self.$evalAsync(function() {
                  if (shouldCall)
                    listener(newValues, newValues, self);
                });
                return function deregisterWatchGroup() {
                  shouldCall = false;
                };
              }
              if (watchExpressions.length === 1) {
                return this.$watch(watchExpressions[0], function watchGroupAction(value, oldValue, scope) {
                  newValues[0] = value;
                  oldValues[0] = oldValue;
                  listener(newValues, (value === oldValue) ? newValues : oldValues, scope);
                });
              }
              forEach(watchExpressions, function(expr, i) {
                var unwatchFn = self.$watch(expr, function watchGroupSubAction(value, oldValue) {
                  newValues[i] = value;
                  oldValues[i] = oldValue;
                  if (!changeReactionScheduled) {
                    changeReactionScheduled = true;
                    self.$evalAsync(watchGroupAction);
                  }
                });
                deregisterFns.push(unwatchFn);
              });
              function watchGroupAction() {
                changeReactionScheduled = false;
                if (firstRun) {
                  firstRun = false;
                  listener(newValues, newValues, self);
                } else {
                  listener(newValues, oldValues, self);
                }
              }
              return function deregisterWatchGroup() {
                while (deregisterFns.length) {
                  deregisterFns.shift()();
                }
              };
            },
            $watchCollection: function(obj, listener) {
              $watchCollectionInterceptor.$stateful = true;
              var self = this;
              var newValue;
              var oldValue;
              var veryOldValue;
              var trackVeryOldValue = (listener.length > 1);
              var changeDetected = 0;
              var changeDetector = $parse(obj, $watchCollectionInterceptor);
              var internalArray = [];
              var internalObject = {};
              var initRun = true;
              var oldLength = 0;
              function $watchCollectionInterceptor(_value) {
                newValue = _value;
                var newLength,
                    key,
                    bothNaN,
                    newItem,
                    oldItem;
                if (isUndefined(newValue))
                  return;
                if (!isObject(newValue)) {
                  if (oldValue !== newValue) {
                    oldValue = newValue;
                    changeDetected++;
                  }
                } else if (isArrayLike(newValue)) {
                  if (oldValue !== internalArray) {
                    oldValue = internalArray;
                    oldLength = oldValue.length = 0;
                    changeDetected++;
                  }
                  newLength = newValue.length;
                  if (oldLength !== newLength) {
                    changeDetected++;
                    oldValue.length = oldLength = newLength;
                  }
                  for (var i = 0; i < newLength; i++) {
                    oldItem = oldValue[i];
                    newItem = newValue[i];
                    bothNaN = (oldItem !== oldItem) && (newItem !== newItem);
                    if (!bothNaN && (oldItem !== newItem)) {
                      changeDetected++;
                      oldValue[i] = newItem;
                    }
                  }
                } else {
                  if (oldValue !== internalObject) {
                    oldValue = internalObject = {};
                    oldLength = 0;
                    changeDetected++;
                  }
                  newLength = 0;
                  for (key in newValue) {
                    if (hasOwnProperty.call(newValue, key)) {
                      newLength++;
                      newItem = newValue[key];
                      oldItem = oldValue[key];
                      if (key in oldValue) {
                        bothNaN = (oldItem !== oldItem) && (newItem !== newItem);
                        if (!bothNaN && (oldItem !== newItem)) {
                          changeDetected++;
                          oldValue[key] = newItem;
                        }
                      } else {
                        oldLength++;
                        oldValue[key] = newItem;
                        changeDetected++;
                      }
                    }
                  }
                  if (oldLength > newLength) {
                    changeDetected++;
                    for (key in oldValue) {
                      if (!hasOwnProperty.call(newValue, key)) {
                        oldLength--;
                        delete oldValue[key];
                      }
                    }
                  }
                }
                return changeDetected;
              }
              function $watchCollectionAction() {
                if (initRun) {
                  initRun = false;
                  listener(newValue, newValue, self);
                } else {
                  listener(newValue, veryOldValue, self);
                }
                if (trackVeryOldValue) {
                  if (!isObject(newValue)) {
                    veryOldValue = newValue;
                  } else if (isArrayLike(newValue)) {
                    veryOldValue = new Array(newValue.length);
                    for (var i = 0; i < newValue.length; i++) {
                      veryOldValue[i] = newValue[i];
                    }
                  } else {
                    veryOldValue = {};
                    for (var key in newValue) {
                      if (hasOwnProperty.call(newValue, key)) {
                        veryOldValue[key] = newValue[key];
                      }
                    }
                  }
                }
              }
              return this.$watch(changeDetector, $watchCollectionAction);
            },
            $digest: function() {
              var watch,
                  value,
                  last,
                  fn,
                  get,
                  watchers,
                  length,
                  dirty,
                  ttl = TTL,
                  next,
                  current,
                  target = this,
                  watchLog = [],
                  logIdx,
                  asyncTask;
              beginPhase('$digest');
              $browser.$$checkUrlChange();
              if (this === $rootScope && applyAsyncId !== null) {
                $browser.defer.cancel(applyAsyncId);
                flushApplyAsync();
              }
              lastDirtyWatch = null;
              do {
                dirty = false;
                current = target;
                for (var asyncQueuePosition = 0; asyncQueuePosition < asyncQueue.length; asyncQueuePosition++) {
                  try {
                    asyncTask = asyncQueue[asyncQueuePosition];
                    asyncTask.scope.$eval(asyncTask.expression, asyncTask.locals);
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                  lastDirtyWatch = null;
                }
                asyncQueue.length = 0;
                traverseScopesLoop: do {
                  if ((watchers = current.$$watchers)) {
                    length = watchers.length;
                    while (length--) {
                      try {
                        watch = watchers[length];
                        if (watch) {
                          get = watch.get;
                          if ((value = get(current)) !== (last = watch.last) && !(watch.eq ? equals(value, last) : (typeof value === 'number' && typeof last === 'number' && isNaN(value) && isNaN(last)))) {
                            dirty = true;
                            lastDirtyWatch = watch;
                            watch.last = watch.eq ? copy(value, null) : value;
                            fn = watch.fn;
                            fn(value, ((last === initWatchVal) ? value : last), current);
                            if (ttl < 5) {
                              logIdx = 4 - ttl;
                              if (!watchLog[logIdx])
                                watchLog[logIdx] = [];
                              watchLog[logIdx].push({
                                msg: isFunction(watch.exp) ? 'fn: ' + (watch.exp.name || watch.exp.toString()) : watch.exp,
                                newVal: value,
                                oldVal: last
                              });
                            }
                          } else if (watch === lastDirtyWatch) {
                            dirty = false;
                            break traverseScopesLoop;
                          }
                        }
                      } catch (e) {
                        $exceptionHandler(e);
                      }
                    }
                  }
                  if (!(next = ((current.$$watchersCount && current.$$childHead) || (current !== target && current.$$nextSibling)))) {
                    while (current !== target && !(next = current.$$nextSibling)) {
                      current = current.$parent;
                    }
                  }
                } while ((current = next));
                if ((dirty || asyncQueue.length) && !(ttl--)) {
                  clearPhase();
                  throw $rootScopeMinErr('infdig', '{0} $digest() iterations reached. Aborting!\n' + 'Watchers fired in the last 5 iterations: {1}', TTL, watchLog);
                }
              } while (dirty || asyncQueue.length);
              clearPhase();
              while (postDigestQueuePosition < postDigestQueue.length) {
                try {
                  postDigestQueue[postDigestQueuePosition++]();
                } catch (e) {
                  $exceptionHandler(e);
                }
              }
              postDigestQueue.length = postDigestQueuePosition = 0;
            },
            $destroy: function() {
              if (this.$$destroyed)
                return;
              var parent = this.$parent;
              this.$broadcast('$destroy');
              this.$$destroyed = true;
              if (this === $rootScope) {
                $browser.$$applicationDestroyed();
              }
              incrementWatchersCount(this, -this.$$watchersCount);
              for (var eventName in this.$$listenerCount) {
                decrementListenerCount(this, this.$$listenerCount[eventName], eventName);
              }
              if (parent && parent.$$childHead == this)
                parent.$$childHead = this.$$nextSibling;
              if (parent && parent.$$childTail == this)
                parent.$$childTail = this.$$prevSibling;
              if (this.$$prevSibling)
                this.$$prevSibling.$$nextSibling = this.$$nextSibling;
              if (this.$$nextSibling)
                this.$$nextSibling.$$prevSibling = this.$$prevSibling;
              this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = noop;
              this.$on = this.$watch = this.$watchGroup = function() {
                return noop;
              };
              this.$$listeners = {};
              this.$$nextSibling = null;
              cleanUpScope(this);
            },
            $eval: function(expr, locals) {
              return $parse(expr)(this, locals);
            },
            $evalAsync: function(expr, locals) {
              if (!$rootScope.$$phase && !asyncQueue.length) {
                $browser.defer(function() {
                  if (asyncQueue.length) {
                    $rootScope.$digest();
                  }
                });
              }
              asyncQueue.push({
                scope: this,
                expression: $parse(expr),
                locals: locals
              });
            },
            $$postDigest: function(fn) {
              postDigestQueue.push(fn);
            },
            $apply: function(expr) {
              try {
                beginPhase('$apply');
                try {
                  return this.$eval(expr);
                } finally {
                  clearPhase();
                }
              } catch (e) {
                $exceptionHandler(e);
              } finally {
                try {
                  $rootScope.$digest();
                } catch (e) {
                  $exceptionHandler(e);
                  throw e;
                }
              }
            },
            $applyAsync: function(expr) {
              var scope = this;
              expr && applyAsyncQueue.push($applyAsyncExpression);
              expr = $parse(expr);
              scheduleApplyAsync();
              function $applyAsyncExpression() {
                scope.$eval(expr);
              }
            },
            $on: function(name, listener) {
              var namedListeners = this.$$listeners[name];
              if (!namedListeners) {
                this.$$listeners[name] = namedListeners = [];
              }
              namedListeners.push(listener);
              var current = this;
              do {
                if (!current.$$listenerCount[name]) {
                  current.$$listenerCount[name] = 0;
                }
                current.$$listenerCount[name]++;
              } while ((current = current.$parent));
              var self = this;
              return function() {
                var indexOfListener = namedListeners.indexOf(listener);
                if (indexOfListener !== -1) {
                  namedListeners[indexOfListener] = null;
                  decrementListenerCount(self, 1, name);
                }
              };
            },
            $emit: function(name, args) {
              var empty = [],
                  namedListeners,
                  scope = this,
                  stopPropagation = false,
                  event = {
                    name: name,
                    targetScope: scope,
                    stopPropagation: function() {
                      stopPropagation = true;
                    },
                    preventDefault: function() {
                      event.defaultPrevented = true;
                    },
                    defaultPrevented: false
                  },
                  listenerArgs = concat([event], arguments, 1),
                  i,
                  length;
              do {
                namedListeners = scope.$$listeners[name] || empty;
                event.currentScope = scope;
                for (i = 0, length = namedListeners.length; i < length; i++) {
                  if (!namedListeners[i]) {
                    namedListeners.splice(i, 1);
                    i--;
                    length--;
                    continue;
                  }
                  try {
                    namedListeners[i].apply(null, listenerArgs);
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                }
                if (stopPropagation) {
                  event.currentScope = null;
                  return event;
                }
                scope = scope.$parent;
              } while (scope);
              event.currentScope = null;
              return event;
            },
            $broadcast: function(name, args) {
              var target = this,
                  current = target,
                  next = target,
                  event = {
                    name: name,
                    targetScope: target,
                    preventDefault: function() {
                      event.defaultPrevented = true;
                    },
                    defaultPrevented: false
                  };
              if (!target.$$listenerCount[name])
                return event;
              var listenerArgs = concat([event], arguments, 1),
                  listeners,
                  i,
                  length;
              while ((current = next)) {
                event.currentScope = current;
                listeners = current.$$listeners[name] || [];
                for (i = 0, length = listeners.length; i < length; i++) {
                  if (!listeners[i]) {
                    listeners.splice(i, 1);
                    i--;
                    length--;
                    continue;
                  }
                  try {
                    listeners[i].apply(null, listenerArgs);
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                }
                if (!(next = ((current.$$listenerCount[name] && current.$$childHead) || (current !== target && current.$$nextSibling)))) {
                  while (current !== target && !(next = current.$$nextSibling)) {
                    current = current.$parent;
                  }
                }
              }
              event.currentScope = null;
              return event;
            }
          };
          var $rootScope = new Scope();
          var asyncQueue = $rootScope.$$asyncQueue = [];
          var postDigestQueue = $rootScope.$$postDigestQueue = [];
          var applyAsyncQueue = $rootScope.$$applyAsyncQueue = [];
          var postDigestQueuePosition = 0;
          return $rootScope;
          function beginPhase(phase) {
            if ($rootScope.$$phase) {
              throw $rootScopeMinErr('inprog', '{0} already in progress', $rootScope.$$phase);
            }
            $rootScope.$$phase = phase;
          }
          function clearPhase() {
            $rootScope.$$phase = null;
          }
          function incrementWatchersCount(current, count) {
            do {
              current.$$watchersCount += count;
            } while ((current = current.$parent));
          }
          function decrementListenerCount(current, count, name) {
            do {
              current.$$listenerCount[name] -= count;
              if (current.$$listenerCount[name] === 0) {
                delete current.$$listenerCount[name];
              }
            } while ((current = current.$parent));
          }
          function initWatchVal() {}
          function flushApplyAsync() {
            while (applyAsyncQueue.length) {
              try {
                applyAsyncQueue.shift()();
              } catch (e) {
                $exceptionHandler(e);
              }
            }
            applyAsyncId = null;
          }
          function scheduleApplyAsync() {
            if (applyAsyncId === null) {
              applyAsyncId = $browser.defer(function() {
                $rootScope.$apply(flushApplyAsync);
              });
            }
          }
        }];
      }
      function $$SanitizeUriProvider() {
        var aHrefSanitizationWhitelist = /^\s*(https?|ftp|mailto|tel|file):/,
            imgSrcSanitizationWhitelist = /^\s*((https?|ftp|file|blob):|data:image\/)/;
        this.aHrefSanitizationWhitelist = function(regexp) {
          if (isDefined(regexp)) {
            aHrefSanitizationWhitelist = regexp;
            return this;
          }
          return aHrefSanitizationWhitelist;
        };
        this.imgSrcSanitizationWhitelist = function(regexp) {
          if (isDefined(regexp)) {
            imgSrcSanitizationWhitelist = regexp;
            return this;
          }
          return imgSrcSanitizationWhitelist;
        };
        this.$get = function() {
          return function sanitizeUri(uri, isImage) {
            var regex = isImage ? imgSrcSanitizationWhitelist : aHrefSanitizationWhitelist;
            var normalizedVal;
            normalizedVal = urlResolve(uri).href;
            if (normalizedVal !== '' && !normalizedVal.match(regex)) {
              return 'unsafe:' + normalizedVal;
            }
            return uri;
          };
        };
      }
      var $sceMinErr = minErr('$sce');
      var SCE_CONTEXTS = {
        HTML: 'html',
        CSS: 'css',
        URL: 'url',
        RESOURCE_URL: 'resourceUrl',
        JS: 'js'
      };
      function adjustMatcher(matcher) {
        if (matcher === 'self') {
          return matcher;
        } else if (isString(matcher)) {
          if (matcher.indexOf('***') > -1) {
            throw $sceMinErr('iwcard', 'Illegal sequence *** in string matcher.  String: {0}', matcher);
          }
          matcher = escapeForRegexp(matcher).replace('\\*\\*', '.*').replace('\\*', '[^:/.?&;]*');
          return new RegExp('^' + matcher + '$');
        } else if (isRegExp(matcher)) {
          return new RegExp('^' + matcher.source + '$');
        } else {
          throw $sceMinErr('imatcher', 'Matchers may only be "self", string patterns or RegExp objects');
        }
      }
      function adjustMatchers(matchers) {
        var adjustedMatchers = [];
        if (isDefined(matchers)) {
          forEach(matchers, function(matcher) {
            adjustedMatchers.push(adjustMatcher(matcher));
          });
        }
        return adjustedMatchers;
      }
      function $SceDelegateProvider() {
        this.SCE_CONTEXTS = SCE_CONTEXTS;
        var resourceUrlWhitelist = ['self'],
            resourceUrlBlacklist = [];
        this.resourceUrlWhitelist = function(value) {
          if (arguments.length) {
            resourceUrlWhitelist = adjustMatchers(value);
          }
          return resourceUrlWhitelist;
        };
        this.resourceUrlBlacklist = function(value) {
          if (arguments.length) {
            resourceUrlBlacklist = adjustMatchers(value);
          }
          return resourceUrlBlacklist;
        };
        this.$get = ['$injector', function($injector) {
          var htmlSanitizer = function htmlSanitizer(html) {
            throw $sceMinErr('unsafe', 'Attempting to use an unsafe value in a safe context.');
          };
          if ($injector.has('$sanitize')) {
            htmlSanitizer = $injector.get('$sanitize');
          }
          function matchUrl(matcher, parsedUrl) {
            if (matcher === 'self') {
              return urlIsSameOrigin(parsedUrl);
            } else {
              return !!matcher.exec(parsedUrl.href);
            }
          }
          function isResourceUrlAllowedByPolicy(url) {
            var parsedUrl = urlResolve(url.toString());
            var i,
                n,
                allowed = false;
            for (i = 0, n = resourceUrlWhitelist.length; i < n; i++) {
              if (matchUrl(resourceUrlWhitelist[i], parsedUrl)) {
                allowed = true;
                break;
              }
            }
            if (allowed) {
              for (i = 0, n = resourceUrlBlacklist.length; i < n; i++) {
                if (matchUrl(resourceUrlBlacklist[i], parsedUrl)) {
                  allowed = false;
                  break;
                }
              }
            }
            return allowed;
          }
          function generateHolderType(Base) {
            var holderType = function TrustedValueHolderType(trustedValue) {
              this.$$unwrapTrustedValue = function() {
                return trustedValue;
              };
            };
            if (Base) {
              holderType.prototype = new Base();
            }
            holderType.prototype.valueOf = function sceValueOf() {
              return this.$$unwrapTrustedValue();
            };
            holderType.prototype.toString = function sceToString() {
              return this.$$unwrapTrustedValue().toString();
            };
            return holderType;
          }
          var trustedValueHolderBase = generateHolderType(),
              byType = {};
          byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase);
          byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase);
          byType[SCE_CONTEXTS.URL] = generateHolderType(trustedValueHolderBase);
          byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase);
          byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(byType[SCE_CONTEXTS.URL]);
          function trustAs(type, trustedValue) {
            var Constructor = (byType.hasOwnProperty(type) ? byType[type] : null);
            if (!Constructor) {
              throw $sceMinErr('icontext', 'Attempted to trust a value in invalid context. Context: {0}; Value: {1}', type, trustedValue);
            }
            if (trustedValue === null || isUndefined(trustedValue) || trustedValue === '') {
              return trustedValue;
            }
            if (typeof trustedValue !== 'string') {
              throw $sceMinErr('itype', 'Attempted to trust a non-string value in a content requiring a string: Context: {0}', type);
            }
            return new Constructor(trustedValue);
          }
          function valueOf(maybeTrusted) {
            if (maybeTrusted instanceof trustedValueHolderBase) {
              return maybeTrusted.$$unwrapTrustedValue();
            } else {
              return maybeTrusted;
            }
          }
          function getTrusted(type, maybeTrusted) {
            if (maybeTrusted === null || isUndefined(maybeTrusted) || maybeTrusted === '') {
              return maybeTrusted;
            }
            var constructor = (byType.hasOwnProperty(type) ? byType[type] : null);
            if (constructor && maybeTrusted instanceof constructor) {
              return maybeTrusted.$$unwrapTrustedValue();
            }
            if (type === SCE_CONTEXTS.RESOURCE_URL) {
              if (isResourceUrlAllowedByPolicy(maybeTrusted)) {
                return maybeTrusted;
              } else {
                throw $sceMinErr('insecurl', 'Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}', maybeTrusted.toString());
              }
            } else if (type === SCE_CONTEXTS.HTML) {
              return htmlSanitizer(maybeTrusted);
            }
            throw $sceMinErr('unsafe', 'Attempting to use an unsafe value in a safe context.');
          }
          return {
            trustAs: trustAs,
            getTrusted: getTrusted,
            valueOf: valueOf
          };
        }];
      }
      function $SceProvider() {
        var enabled = true;
        this.enabled = function(value) {
          if (arguments.length) {
            enabled = !!value;
          }
          return enabled;
        };
        this.$get = ['$parse', '$sceDelegate', function($parse, $sceDelegate) {
          if (enabled && msie < 8) {
            throw $sceMinErr('iequirks', 'Strict Contextual Escaping does not support Internet Explorer version < 11 in quirks ' + 'mode.  You can fix this by adding the text <!doctype html> to the top of your HTML ' + 'document.  See http://docs.angularjs.org/api/ng.$sce for more information.');
          }
          var sce = shallowCopy(SCE_CONTEXTS);
          sce.isEnabled = function() {
            return enabled;
          };
          sce.trustAs = $sceDelegate.trustAs;
          sce.getTrusted = $sceDelegate.getTrusted;
          sce.valueOf = $sceDelegate.valueOf;
          if (!enabled) {
            sce.trustAs = sce.getTrusted = function(type, value) {
              return value;
            };
            sce.valueOf = identity;
          }
          sce.parseAs = function sceParseAs(type, expr) {
            var parsed = $parse(expr);
            if (parsed.literal && parsed.constant) {
              return parsed;
            } else {
              return $parse(expr, function(value) {
                return sce.getTrusted(type, value);
              });
            }
          };
          var parse = sce.parseAs,
              getTrusted = sce.getTrusted,
              trustAs = sce.trustAs;
          forEach(SCE_CONTEXTS, function(enumValue, name) {
            var lName = lowercase(name);
            sce[camelCase("parse_as_" + lName)] = function(expr) {
              return parse(enumValue, expr);
            };
            sce[camelCase("get_trusted_" + lName)] = function(value) {
              return getTrusted(enumValue, value);
            };
            sce[camelCase("trust_as_" + lName)] = function(value) {
              return trustAs(enumValue, value);
            };
          });
          return sce;
        }];
      }
      function $SnifferProvider() {
        this.$get = ['$window', '$document', function($window, $document) {
          var eventSupport = {},
              isChromePackagedApp = $window.chrome && $window.chrome.app && $window.chrome.app.runtime,
              hasHistoryPushState = !isChromePackagedApp && $window.history && $window.history.pushState,
              android = toInt((/android (\d+)/.exec(lowercase(($window.navigator || {}).userAgent)) || [])[1]),
              boxee = /Boxee/i.test(($window.navigator || {}).userAgent),
              document = $document[0] || {},
              vendorPrefix,
              vendorRegex = /^(Moz|webkit|ms)(?=[A-Z])/,
              bodyStyle = document.body && document.body.style,
              transitions = false,
              animations = false,
              match;
          if (bodyStyle) {
            for (var prop in bodyStyle) {
              if (match = vendorRegex.exec(prop)) {
                vendorPrefix = match[0];
                vendorPrefix = vendorPrefix[0].toUpperCase() + vendorPrefix.substr(1);
                break;
              }
            }
            if (!vendorPrefix) {
              vendorPrefix = ('WebkitOpacity' in bodyStyle) && 'webkit';
            }
            transitions = !!(('transition' in bodyStyle) || (vendorPrefix + 'Transition' in bodyStyle));
            animations = !!(('animation' in bodyStyle) || (vendorPrefix + 'Animation' in bodyStyle));
            if (android && (!transitions || !animations)) {
              transitions = isString(bodyStyle.webkitTransition);
              animations = isString(bodyStyle.webkitAnimation);
            }
          }
          return {
            history: !!(hasHistoryPushState && !(android < 4) && !boxee),
            hasEvent: function(event) {
              if (event === 'input' && msie <= 11)
                return false;
              if (isUndefined(eventSupport[event])) {
                var divElm = document.createElement('div');
                eventSupport[event] = 'on' + event in divElm;
              }
              return eventSupport[event];
            },
            csp: csp(),
            vendorPrefix: vendorPrefix,
            transitions: transitions,
            animations: animations,
            android: android
          };
        }];
      }
      var $templateRequestMinErr = minErr('$compile');
      function $TemplateRequestProvider() {
        var httpOptions;
        this.httpOptions = function(val) {
          if (val) {
            httpOptions = val;
            return this;
          }
          return httpOptions;
        };
        this.$get = ['$templateCache', '$http', '$q', '$sce', function($templateCache, $http, $q, $sce) {
          function handleRequestFn(tpl, ignoreRequestError) {
            handleRequestFn.totalPendingRequests++;
            if (!isString(tpl) || isUndefined($templateCache.get(tpl))) {
              tpl = $sce.getTrustedResourceUrl(tpl);
            }
            var transformResponse = $http.defaults && $http.defaults.transformResponse;
            if (isArray(transformResponse)) {
              transformResponse = transformResponse.filter(function(transformer) {
                return transformer !== defaultHttpResponseTransform;
              });
            } else if (transformResponse === defaultHttpResponseTransform) {
              transformResponse = null;
            }
            return $http.get(tpl, extend({
              cache: $templateCache,
              transformResponse: transformResponse
            }, httpOptions))['finally'](function() {
              handleRequestFn.totalPendingRequests--;
            }).then(function(response) {
              $templateCache.put(tpl, response.data);
              return response.data;
            }, handleError);
            function handleError(resp) {
              if (!ignoreRequestError) {
                throw $templateRequestMinErr('tpload', 'Failed to load template: {0} (HTTP status: {1} {2})', tpl, resp.status, resp.statusText);
              }
              return $q.reject(resp);
            }
          }
          handleRequestFn.totalPendingRequests = 0;
          return handleRequestFn;
        }];
      }
      function $$TestabilityProvider() {
        this.$get = ['$rootScope', '$browser', '$location', function($rootScope, $browser, $location) {
          var testability = {};
          testability.findBindings = function(element, expression, opt_exactMatch) {
            var bindings = element.getElementsByClassName('ng-binding');
            var matches = [];
            forEach(bindings, function(binding) {
              var dataBinding = angular.element(binding).data('$binding');
              if (dataBinding) {
                forEach(dataBinding, function(bindingName) {
                  if (opt_exactMatch) {
                    var matcher = new RegExp('(^|\\s)' + escapeForRegexp(expression) + '(\\s|\\||$)');
                    if (matcher.test(bindingName)) {
                      matches.push(binding);
                    }
                  } else {
                    if (bindingName.indexOf(expression) != -1) {
                      matches.push(binding);
                    }
                  }
                });
              }
            });
            return matches;
          };
          testability.findModels = function(element, expression, opt_exactMatch) {
            var prefixes = ['ng-', 'data-ng-', 'ng\\:'];
            for (var p = 0; p < prefixes.length; ++p) {
              var attributeEquals = opt_exactMatch ? '=' : '*=';
              var selector = '[' + prefixes[p] + 'model' + attributeEquals + '"' + expression + '"]';
              var elements = element.querySelectorAll(selector);
              if (elements.length) {
                return elements;
              }
            }
          };
          testability.getLocation = function() {
            return $location.url();
          };
          testability.setLocation = function(url) {
            if (url !== $location.url()) {
              $location.url(url);
              $rootScope.$digest();
            }
          };
          testability.whenStable = function(callback) {
            $browser.notifyWhenNoOutstandingRequests(callback);
          };
          return testability;
        }];
      }
      function $TimeoutProvider() {
        this.$get = ['$rootScope', '$browser', '$q', '$$q', '$exceptionHandler', function($rootScope, $browser, $q, $$q, $exceptionHandler) {
          var deferreds = {};
          function timeout(fn, delay, invokeApply) {
            if (!isFunction(fn)) {
              invokeApply = delay;
              delay = fn;
              fn = noop;
            }
            var args = sliceArgs(arguments, 3),
                skipApply = (isDefined(invokeApply) && !invokeApply),
                deferred = (skipApply ? $$q : $q).defer(),
                promise = deferred.promise,
                timeoutId;
            timeoutId = $browser.defer(function() {
              try {
                deferred.resolve(fn.apply(null, args));
              } catch (e) {
                deferred.reject(e);
                $exceptionHandler(e);
              } finally {
                delete deferreds[promise.$$timeoutId];
              }
              if (!skipApply)
                $rootScope.$apply();
            }, delay);
            promise.$$timeoutId = timeoutId;
            deferreds[timeoutId] = deferred;
            return promise;
          }
          timeout.cancel = function(promise) {
            if (promise && promise.$$timeoutId in deferreds) {
              deferreds[promise.$$timeoutId].reject('canceled');
              delete deferreds[promise.$$timeoutId];
              return $browser.defer.cancel(promise.$$timeoutId);
            }
            return false;
          };
          return timeout;
        }];
      }
      var urlParsingNode = window.document.createElement("a");
      var originUrl = urlResolve(window.location.href);
      function urlResolve(url) {
        var href = url;
        if (msie) {
          urlParsingNode.setAttribute("href", href);
          href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute('href', href);
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: (urlParsingNode.pathname.charAt(0) === '/') ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
        };
      }
      function urlIsSameOrigin(requestUrl) {
        var parsed = (isString(requestUrl)) ? urlResolve(requestUrl) : requestUrl;
        return (parsed.protocol === originUrl.protocol && parsed.host === originUrl.host);
      }
      function $WindowProvider() {
        this.$get = valueFn(window);
      }
      function $$CookieReader($document) {
        var rawDocument = $document[0] || {};
        var lastCookies = {};
        var lastCookieString = '';
        function safeDecodeURIComponent(str) {
          try {
            return decodeURIComponent(str);
          } catch (e) {
            return str;
          }
        }
        return function() {
          var cookieArray,
              cookie,
              i,
              index,
              name;
          var currentCookieString = rawDocument.cookie || '';
          if (currentCookieString !== lastCookieString) {
            lastCookieString = currentCookieString;
            cookieArray = lastCookieString.split('; ');
            lastCookies = {};
            for (i = 0; i < cookieArray.length; i++) {
              cookie = cookieArray[i];
              index = cookie.indexOf('=');
              if (index > 0) {
                name = safeDecodeURIComponent(cookie.substring(0, index));
                if (isUndefined(lastCookies[name])) {
                  lastCookies[name] = safeDecodeURIComponent(cookie.substring(index + 1));
                }
              }
            }
          }
          return lastCookies;
        };
      }
      $$CookieReader.$inject = ['$document'];
      function $$CookieReaderProvider() {
        this.$get = $$CookieReader;
      }
      $FilterProvider.$inject = ['$provide'];
      function $FilterProvider($provide) {
        var suffix = 'Filter';
        function register(name, factory) {
          if (isObject(name)) {
            var filters = {};
            forEach(name, function(filter, key) {
              filters[key] = register(key, filter);
            });
            return filters;
          } else {
            return $provide.factory(name + suffix, factory);
          }
        }
        this.register = register;
        this.$get = ['$injector', function($injector) {
          return function(name) {
            return $injector.get(name + suffix);
          };
        }];
        register('currency', currencyFilter);
        register('date', dateFilter);
        register('filter', filterFilter);
        register('json', jsonFilter);
        register('limitTo', limitToFilter);
        register('lowercase', lowercaseFilter);
        register('number', numberFilter);
        register('orderBy', orderByFilter);
        register('uppercase', uppercaseFilter);
      }
      function filterFilter() {
        return function(array, expression, comparator) {
          if (!isArrayLike(array)) {
            if (array == null) {
              return array;
            } else {
              throw minErr('filter')('notarray', 'Expected array but received: {0}', array);
            }
          }
          var expressionType = getTypeForFilter(expression);
          var predicateFn;
          var matchAgainstAnyProp;
          switch (expressionType) {
            case 'function':
              predicateFn = expression;
              break;
            case 'boolean':
            case 'null':
            case 'number':
            case 'string':
              matchAgainstAnyProp = true;
            case 'object':
              predicateFn = createPredicateFn(expression, comparator, matchAgainstAnyProp);
              break;
            default:
              return array;
          }
          return Array.prototype.filter.call(array, predicateFn);
        };
      }
      function createPredicateFn(expression, comparator, matchAgainstAnyProp) {
        var shouldMatchPrimitives = isObject(expression) && ('$' in expression);
        var predicateFn;
        if (comparator === true) {
          comparator = equals;
        } else if (!isFunction(comparator)) {
          comparator = function(actual, expected) {
            if (isUndefined(actual)) {
              return false;
            }
            if ((actual === null) || (expected === null)) {
              return actual === expected;
            }
            if (isObject(expected) || (isObject(actual) && !hasCustomToString(actual))) {
              return false;
            }
            actual = lowercase('' + actual);
            expected = lowercase('' + expected);
            return actual.indexOf(expected) !== -1;
          };
        }
        predicateFn = function(item) {
          if (shouldMatchPrimitives && !isObject(item)) {
            return deepCompare(item, expression.$, comparator, false);
          }
          return deepCompare(item, expression, comparator, matchAgainstAnyProp);
        };
        return predicateFn;
      }
      function deepCompare(actual, expected, comparator, matchAgainstAnyProp, dontMatchWholeObject) {
        var actualType = getTypeForFilter(actual);
        var expectedType = getTypeForFilter(expected);
        if ((expectedType === 'string') && (expected.charAt(0) === '!')) {
          return !deepCompare(actual, expected.substring(1), comparator, matchAgainstAnyProp);
        } else if (isArray(actual)) {
          return actual.some(function(item) {
            return deepCompare(item, expected, comparator, matchAgainstAnyProp);
          });
        }
        switch (actualType) {
          case 'object':
            var key;
            if (matchAgainstAnyProp) {
              for (key in actual) {
                if ((key.charAt(0) !== '$') && deepCompare(actual[key], expected, comparator, true)) {
                  return true;
                }
              }
              return dontMatchWholeObject ? false : deepCompare(actual, expected, comparator, false);
            } else if (expectedType === 'object') {
              for (key in expected) {
                var expectedVal = expected[key];
                if (isFunction(expectedVal) || isUndefined(expectedVal)) {
                  continue;
                }
                var matchAnyProperty = key === '$';
                var actualVal = matchAnyProperty ? actual : actual[key];
                if (!deepCompare(actualVal, expectedVal, comparator, matchAnyProperty, matchAnyProperty)) {
                  return false;
                }
              }
              return true;
            } else {
              return comparator(actual, expected);
            }
            break;
          case 'function':
            return false;
          default:
            return comparator(actual, expected);
        }
      }
      function getTypeForFilter(val) {
        return (val === null) ? 'null' : typeof val;
      }
      var MAX_DIGITS = 22;
      var DECIMAL_SEP = '.';
      var ZERO_CHAR = '0';
      currencyFilter.$inject = ['$locale'];
      function currencyFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function(amount, currencySymbol, fractionSize) {
          if (isUndefined(currencySymbol)) {
            currencySymbol = formats.CURRENCY_SYM;
          }
          if (isUndefined(fractionSize)) {
            fractionSize = formats.PATTERNS[1].maxFrac;
          }
          return (amount == null) ? amount : formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize).replace(/\u00A4/g, currencySymbol);
        };
      }
      numberFilter.$inject = ['$locale'];
      function numberFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function(number, fractionSize) {
          return (number == null) ? number : formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize);
        };
      }
      function parse(numStr) {
        var exponent = 0,
            digits,
            numberOfIntegerDigits;
        var i,
            j,
            zeros;
        if ((numberOfIntegerDigits = numStr.indexOf(DECIMAL_SEP)) > -1) {
          numStr = numStr.replace(DECIMAL_SEP, '');
        }
        if ((i = numStr.search(/e/i)) > 0) {
          if (numberOfIntegerDigits < 0)
            numberOfIntegerDigits = i;
          numberOfIntegerDigits += +numStr.slice(i + 1);
          numStr = numStr.substring(0, i);
        } else if (numberOfIntegerDigits < 0) {
          numberOfIntegerDigits = numStr.length;
        }
        for (i = 0; numStr.charAt(i) == ZERO_CHAR; i++) {}
        if (i == (zeros = numStr.length)) {
          digits = [0];
          numberOfIntegerDigits = 1;
        } else {
          zeros--;
          while (numStr.charAt(zeros) == ZERO_CHAR)
            zeros--;
          numberOfIntegerDigits -= i;
          digits = [];
          for (j = 0; i <= zeros; i++, j++) {
            digits[j] = +numStr.charAt(i);
          }
        }
        if (numberOfIntegerDigits > MAX_DIGITS) {
          digits = digits.splice(0, MAX_DIGITS - 1);
          exponent = numberOfIntegerDigits - 1;
          numberOfIntegerDigits = 1;
        }
        return {
          d: digits,
          e: exponent,
          i: numberOfIntegerDigits
        };
      }
      function roundNumber(parsedNumber, fractionSize, minFrac, maxFrac) {
        var digits = parsedNumber.d;
        var fractionLen = digits.length - parsedNumber.i;
        fractionSize = (isUndefined(fractionSize)) ? Math.min(Math.max(minFrac, fractionLen), maxFrac) : +fractionSize;
        var roundAt = fractionSize + parsedNumber.i;
        var digit = digits[roundAt];
        if (roundAt > 0) {
          digits.splice(Math.max(parsedNumber.i, roundAt));
          for (var j = roundAt; j < digits.length; j++) {
            digits[j] = 0;
          }
        } else {
          fractionLen = Math.max(0, fractionLen);
          parsedNumber.i = 1;
          digits.length = Math.max(1, roundAt = fractionSize + 1);
          digits[0] = 0;
          for (var i = 1; i < roundAt; i++)
            digits[i] = 0;
        }
        if (digit >= 5) {
          if (roundAt - 1 < 0) {
            for (var k = 0; k > roundAt; k--) {
              digits.unshift(0);
              parsedNumber.i++;
            }
            digits.unshift(1);
            parsedNumber.i++;
          } else {
            digits[roundAt - 1]++;
          }
        }
        for (; fractionLen < Math.max(0, fractionSize); fractionLen++)
          digits.push(0);
        var carry = digits.reduceRight(function(carry, d, i, digits) {
          d = d + carry;
          digits[i] = d % 10;
          return Math.floor(d / 10);
        }, 0);
        if (carry) {
          digits.unshift(carry);
          parsedNumber.i++;
        }
      }
      function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
        if (!(isString(number) || isNumber(number)) || isNaN(number))
          return '';
        var isInfinity = !isFinite(number);
        var isZero = false;
        var numStr = Math.abs(number) + '',
            formattedText = '',
            parsedNumber;
        if (isInfinity) {
          formattedText = '\u221e';
        } else {
          parsedNumber = parse(numStr);
          roundNumber(parsedNumber, fractionSize, pattern.minFrac, pattern.maxFrac);
          var digits = parsedNumber.d;
          var integerLen = parsedNumber.i;
          var exponent = parsedNumber.e;
          var decimals = [];
          isZero = digits.reduce(function(isZero, d) {
            return isZero && !d;
          }, true);
          while (integerLen < 0) {
            digits.unshift(0);
            integerLen++;
          }
          if (integerLen > 0) {
            decimals = digits.splice(integerLen, digits.length);
          } else {
            decimals = digits;
            digits = [0];
          }
          var groups = [];
          if (digits.length >= pattern.lgSize) {
            groups.unshift(digits.splice(-pattern.lgSize, digits.length).join(''));
          }
          while (digits.length > pattern.gSize) {
            groups.unshift(digits.splice(-pattern.gSize, digits.length).join(''));
          }
          if (digits.length) {
            groups.unshift(digits.join(''));
          }
          formattedText = groups.join(groupSep);
          if (decimals.length) {
            formattedText += decimalSep + decimals.join('');
          }
          if (exponent) {
            formattedText += 'e+' + exponent;
          }
        }
        if (number < 0 && !isZero) {
          return pattern.negPre + formattedText + pattern.negSuf;
        } else {
          return pattern.posPre + formattedText + pattern.posSuf;
        }
      }
      function padNumber(num, digits, trim, negWrap) {
        var neg = '';
        if (num < 0 || (negWrap && num <= 0)) {
          if (negWrap) {
            num = -num + 1;
          } else {
            num = -num;
            neg = '-';
          }
        }
        num = '' + num;
        while (num.length < digits)
          num = ZERO_CHAR + num;
        if (trim) {
          num = num.substr(num.length - digits);
        }
        return neg + num;
      }
      function dateGetter(name, size, offset, trim, negWrap) {
        offset = offset || 0;
        return function(date) {
          var value = date['get' + name]();
          if (offset > 0 || value > -offset) {
            value += offset;
          }
          if (value === 0 && offset == -12)
            value = 12;
          return padNumber(value, size, trim, negWrap);
        };
      }
      function dateStrGetter(name, shortForm, standAlone) {
        return function(date, formats) {
          var value = date['get' + name]();
          var propPrefix = (standAlone ? 'STANDALONE' : '') + (shortForm ? 'SHORT' : '');
          var get = uppercase(propPrefix + name);
          return formats[get][value];
        };
      }
      function timeZoneGetter(date, formats, offset) {
        var zone = -1 * offset;
        var paddedZone = (zone >= 0) ? "+" : "";
        paddedZone += padNumber(Math[zone > 0 ? 'floor' : 'ceil'](zone / 60), 2) + padNumber(Math.abs(zone % 60), 2);
        return paddedZone;
      }
      function getFirstThursdayOfYear(year) {
        var dayOfWeekOnFirst = (new Date(year, 0, 1)).getDay();
        return new Date(year, 0, ((dayOfWeekOnFirst <= 4) ? 5 : 12) - dayOfWeekOnFirst);
      }
      function getThursdayThisWeek(datetime) {
        return new Date(datetime.getFullYear(), datetime.getMonth(), datetime.getDate() + (4 - datetime.getDay()));
      }
      function weekGetter(size) {
        return function(date) {
          var firstThurs = getFirstThursdayOfYear(date.getFullYear()),
              thisThurs = getThursdayThisWeek(date);
          var diff = +thisThurs - +firstThurs,
              result = 1 + Math.round(diff / 6.048e8);
          return padNumber(result, size);
        };
      }
      function ampmGetter(date, formats) {
        return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1];
      }
      function eraGetter(date, formats) {
        return date.getFullYear() <= 0 ? formats.ERAS[0] : formats.ERAS[1];
      }
      function longEraGetter(date, formats) {
        return date.getFullYear() <= 0 ? formats.ERANAMES[0] : formats.ERANAMES[1];
      }
      var DATE_FORMATS = {
        yyyy: dateGetter('FullYear', 4, 0, false, true),
        yy: dateGetter('FullYear', 2, 0, true, true),
        y: dateGetter('FullYear', 1, 0, false, true),
        MMMM: dateStrGetter('Month'),
        MMM: dateStrGetter('Month', true),
        MM: dateGetter('Month', 2, 1),
        M: dateGetter('Month', 1, 1),
        LLLL: dateStrGetter('Month', false, true),
        dd: dateGetter('Date', 2),
        d: dateGetter('Date', 1),
        HH: dateGetter('Hours', 2),
        H: dateGetter('Hours', 1),
        hh: dateGetter('Hours', 2, -12),
        h: dateGetter('Hours', 1, -12),
        mm: dateGetter('Minutes', 2),
        m: dateGetter('Minutes', 1),
        ss: dateGetter('Seconds', 2),
        s: dateGetter('Seconds', 1),
        sss: dateGetter('Milliseconds', 3),
        EEEE: dateStrGetter('Day'),
        EEE: dateStrGetter('Day', true),
        a: ampmGetter,
        Z: timeZoneGetter,
        ww: weekGetter(2),
        w: weekGetter(1),
        G: eraGetter,
        GG: eraGetter,
        GGG: eraGetter,
        GGGG: longEraGetter
      };
      var DATE_FORMATS_SPLIT = /((?:[^yMLdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|L+|d+|H+|h+|m+|s+|a|Z|G+|w+))(.*)/,
          NUMBER_STRING = /^\-?\d+$/;
      dateFilter.$inject = ['$locale'];
      function dateFilter($locale) {
        var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
        function jsonStringToDate(string) {
          var match;
          if (match = string.match(R_ISO8601_STR)) {
            var date = new Date(0),
                tzHour = 0,
                tzMin = 0,
                dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear,
                timeSetter = match[8] ? date.setUTCHours : date.setHours;
            if (match[9]) {
              tzHour = toInt(match[9] + match[10]);
              tzMin = toInt(match[9] + match[11]);
            }
            dateSetter.call(date, toInt(match[1]), toInt(match[2]) - 1, toInt(match[3]));
            var h = toInt(match[4] || 0) - tzHour;
            var m = toInt(match[5] || 0) - tzMin;
            var s = toInt(match[6] || 0);
            var ms = Math.round(parseFloat('0.' + (match[7] || 0)) * 1000);
            timeSetter.call(date, h, m, s, ms);
            return date;
          }
          return string;
        }
        return function(date, format, timezone) {
          var text = '',
              parts = [],
              fn,
              match;
          format = format || 'mediumDate';
          format = $locale.DATETIME_FORMATS[format] || format;
          if (isString(date)) {
            date = NUMBER_STRING.test(date) ? toInt(date) : jsonStringToDate(date);
          }
          if (isNumber(date)) {
            date = new Date(date);
          }
          if (!isDate(date) || !isFinite(date.getTime())) {
            return date;
          }
          while (format) {
            match = DATE_FORMATS_SPLIT.exec(format);
            if (match) {
              parts = concat(parts, match, 1);
              format = parts.pop();
            } else {
              parts.push(format);
              format = null;
            }
          }
          var dateTimezoneOffset = date.getTimezoneOffset();
          if (timezone) {
            dateTimezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
            date = convertTimezoneToLocal(date, timezone, true);
          }
          forEach(parts, function(value) {
            fn = DATE_FORMATS[value];
            text += fn ? fn(date, $locale.DATETIME_FORMATS, dateTimezoneOffset) : value === "''" ? "'" : value.replace(/(^'|'$)/g, '').replace(/''/g, "'");
          });
          return text;
        };
      }
      function jsonFilter() {
        return function(object, spacing) {
          if (isUndefined(spacing)) {
            spacing = 2;
          }
          return toJson(object, spacing);
        };
      }
      var lowercaseFilter = valueFn(lowercase);
      var uppercaseFilter = valueFn(uppercase);
      function limitToFilter() {
        return function(input, limit, begin) {
          if (Math.abs(Number(limit)) === Infinity) {
            limit = Number(limit);
          } else {
            limit = toInt(limit);
          }
          if (isNaN(limit))
            return input;
          if (isNumber(input))
            input = input.toString();
          if (!isArrayLike(input))
            return input;
          begin = (!begin || isNaN(begin)) ? 0 : toInt(begin);
          begin = (begin < 0) ? Math.max(0, input.length + begin) : begin;
          if (limit >= 0) {
            return sliceFn(input, begin, begin + limit);
          } else {
            if (begin === 0) {
              return sliceFn(input, limit, input.length);
            } else {
              return sliceFn(input, Math.max(0, begin + limit), begin);
            }
          }
        };
      }
      function sliceFn(input, begin, end) {
        if (isString(input))
          return input.slice(begin, end);
        return slice.call(input, begin, end);
      }
      orderByFilter.$inject = ['$parse'];
      function orderByFilter($parse) {
        return function(array, sortPredicate, reverseOrder, compareFn) {
          if (array == null)
            return array;
          if (!isArrayLike(array)) {
            throw minErr('orderBy')('notarray', 'Expected array but received: {0}', array);
          }
          if (!isArray(sortPredicate)) {
            sortPredicate = [sortPredicate];
          }
          if (sortPredicate.length === 0) {
            sortPredicate = ['+'];
          }
          var predicates = processPredicates(sortPredicate);
          var descending = reverseOrder ? -1 : 1;
          var compare = isFunction(compareFn) ? compareFn : defaultCompare;
          var compareValues = Array.prototype.map.call(array, getComparisonObject);
          compareValues.sort(doComparison);
          array = compareValues.map(function(item) {
            return item.value;
          });
          return array;
          function getComparisonObject(value, index) {
            return {
              value: value,
              tieBreaker: {
                value: index,
                type: 'number',
                index: index
              },
              predicateValues: predicates.map(function(predicate) {
                return getPredicateValue(predicate.get(value), index);
              })
            };
          }
          function doComparison(v1, v2) {
            for (var i = 0,
                ii = predicates.length; i < ii; i++) {
              var result = compare(v1.predicateValues[i], v2.predicateValues[i]);
              if (result) {
                return result * predicates[i].descending * descending;
              }
            }
            return compare(v1.tieBreaker, v2.tieBreaker) * descending;
          }
        };
        function processPredicates(sortPredicates) {
          return sortPredicates.map(function(predicate) {
            var descending = 1,
                get = identity;
            if (isFunction(predicate)) {
              get = predicate;
            } else if (isString(predicate)) {
              if ((predicate.charAt(0) == '+' || predicate.charAt(0) == '-')) {
                descending = predicate.charAt(0) == '-' ? -1 : 1;
                predicate = predicate.substring(1);
              }
              if (predicate !== '') {
                get = $parse(predicate);
                if (get.constant) {
                  var key = get();
                  get = function(value) {
                    return value[key];
                  };
                }
              }
            }
            return {
              get: get,
              descending: descending
            };
          });
        }
        function isPrimitive(value) {
          switch (typeof value) {
            case 'number':
            case 'boolean':
            case 'string':
              return true;
            default:
              return false;
          }
        }
        function objectValue(value) {
          if (isFunction(value.valueOf)) {
            value = value.valueOf();
            if (isPrimitive(value))
              return value;
          }
          if (hasCustomToString(value)) {
            value = value.toString();
            if (isPrimitive(value))
              return value;
          }
          return value;
        }
        function getPredicateValue(value, index) {
          var type = typeof value;
          if (value === null) {
            type = 'string';
            value = 'null';
          } else if (type === 'object') {
            value = objectValue(value);
          }
          return {
            value: value,
            type: type,
            index: index
          };
        }
        function defaultCompare(v1, v2) {
          var result = 0;
          var type1 = v1.type;
          var type2 = v2.type;
          if (type1 === type2) {
            var value1 = v1.value;
            var value2 = v2.value;
            if (type1 === 'string') {
              value1 = value1.toLowerCase();
              value2 = value2.toLowerCase();
            } else if (type1 === 'object') {
              if (isObject(value1))
                value1 = v1.index;
              if (isObject(value2))
                value2 = v2.index;
            }
            if (value1 !== value2) {
              result = value1 < value2 ? -1 : 1;
            }
          } else {
            result = type1 < type2 ? -1 : 1;
          }
          return result;
        }
      }
      function ngDirective(directive) {
        if (isFunction(directive)) {
          directive = {link: directive};
        }
        directive.restrict = directive.restrict || 'AC';
        return valueFn(directive);
      }
      var htmlAnchorDirective = valueFn({
        restrict: 'E',
        compile: function(element, attr) {
          if (!attr.href && !attr.xlinkHref) {
            return function(scope, element) {
              if (element[0].nodeName.toLowerCase() !== 'a')
                return;
              var href = toString.call(element.prop('href')) === '[object SVGAnimatedString]' ? 'xlink:href' : 'href';
              element.on('click', function(event) {
                if (!element.attr(href)) {
                  event.preventDefault();
                }
              });
            };
          }
        }
      });
      var ngAttributeAliasDirectives = {};
      forEach(BOOLEAN_ATTR, function(propName, attrName) {
        if (propName == "multiple")
          return;
        function defaultLinkFn(scope, element, attr) {
          scope.$watch(attr[normalized], function ngBooleanAttrWatchAction(value) {
            attr.$set(attrName, !!value);
          });
        }
        var normalized = directiveNormalize('ng-' + attrName);
        var linkFn = defaultLinkFn;
        if (propName === 'checked') {
          linkFn = function(scope, element, attr) {
            if (attr.ngModel !== attr[normalized]) {
              defaultLinkFn(scope, element, attr);
            }
          };
        }
        ngAttributeAliasDirectives[normalized] = function() {
          return {
            restrict: 'A',
            priority: 100,
            link: linkFn
          };
        };
      });
      forEach(ALIASED_ATTR, function(htmlAttr, ngAttr) {
        ngAttributeAliasDirectives[ngAttr] = function() {
          return {
            priority: 100,
            link: function(scope, element, attr) {
              if (ngAttr === "ngPattern" && attr.ngPattern.charAt(0) == "/") {
                var match = attr.ngPattern.match(REGEX_STRING_REGEXP);
                if (match) {
                  attr.$set("ngPattern", new RegExp(match[1], match[2]));
                  return;
                }
              }
              scope.$watch(attr[ngAttr], function ngAttrAliasWatchAction(value) {
                attr.$set(ngAttr, value);
              });
            }
          };
        };
      });
      forEach(['src', 'srcset', 'href'], function(attrName) {
        var normalized = directiveNormalize('ng-' + attrName);
        ngAttributeAliasDirectives[normalized] = function() {
          return {
            priority: 99,
            link: function(scope, element, attr) {
              var propName = attrName,
                  name = attrName;
              if (attrName === 'href' && toString.call(element.prop('href')) === '[object SVGAnimatedString]') {
                name = 'xlinkHref';
                attr.$attr[name] = 'xlink:href';
                propName = null;
              }
              attr.$observe(normalized, function(value) {
                if (!value) {
                  if (attrName === 'href') {
                    attr.$set(name, null);
                  }
                  return;
                }
                attr.$set(name, value);
                if (msie && propName)
                  element.prop(propName, attr[name]);
              });
            }
          };
        };
      });
      var nullFormCtrl = {
        $addControl: noop,
        $$renameControl: nullFormRenameControl,
        $removeControl: noop,
        $setValidity: noop,
        $setDirty: noop,
        $setPristine: noop,
        $setSubmitted: noop
      },
          SUBMITTED_CLASS = 'ng-submitted';
      function nullFormRenameControl(control, name) {
        control.$name = name;
      }
      FormController.$inject = ['$element', '$attrs', '$scope', '$animate', '$interpolate'];
      function FormController(element, attrs, $scope, $animate, $interpolate) {
        var form = this,
            controls = [];
        form.$error = {};
        form.$$success = {};
        form.$pending = undefined;
        form.$name = $interpolate(attrs.name || attrs.ngForm || '')($scope);
        form.$dirty = false;
        form.$pristine = true;
        form.$valid = true;
        form.$invalid = false;
        form.$submitted = false;
        form.$$parentForm = nullFormCtrl;
        form.$rollbackViewValue = function() {
          forEach(controls, function(control) {
            control.$rollbackViewValue();
          });
        };
        form.$commitViewValue = function() {
          forEach(controls, function(control) {
            control.$commitViewValue();
          });
        };
        form.$addControl = function(control) {
          assertNotHasOwnProperty(control.$name, 'input');
          controls.push(control);
          if (control.$name) {
            form[control.$name] = control;
          }
          control.$$parentForm = form;
        };
        form.$$renameControl = function(control, newName) {
          var oldName = control.$name;
          if (form[oldName] === control) {
            delete form[oldName];
          }
          form[newName] = control;
          control.$name = newName;
        };
        form.$removeControl = function(control) {
          if (control.$name && form[control.$name] === control) {
            delete form[control.$name];
          }
          forEach(form.$pending, function(value, name) {
            form.$setValidity(name, null, control);
          });
          forEach(form.$error, function(value, name) {
            form.$setValidity(name, null, control);
          });
          forEach(form.$$success, function(value, name) {
            form.$setValidity(name, null, control);
          });
          arrayRemove(controls, control);
          control.$$parentForm = nullFormCtrl;
        };
        addSetValidityMethod({
          ctrl: this,
          $element: element,
          set: function(object, property, controller) {
            var list = object[property];
            if (!list) {
              object[property] = [controller];
            } else {
              var index = list.indexOf(controller);
              if (index === -1) {
                list.push(controller);
              }
            }
          },
          unset: function(object, property, controller) {
            var list = object[property];
            if (!list) {
              return;
            }
            arrayRemove(list, controller);
            if (list.length === 0) {
              delete object[property];
            }
          },
          $animate: $animate
        });
        form.$setDirty = function() {
          $animate.removeClass(element, PRISTINE_CLASS);
          $animate.addClass(element, DIRTY_CLASS);
          form.$dirty = true;
          form.$pristine = false;
          form.$$parentForm.$setDirty();
        };
        form.$setPristine = function() {
          $animate.setClass(element, PRISTINE_CLASS, DIRTY_CLASS + ' ' + SUBMITTED_CLASS);
          form.$dirty = false;
          form.$pristine = true;
          form.$submitted = false;
          forEach(controls, function(control) {
            control.$setPristine();
          });
        };
        form.$setUntouched = function() {
          forEach(controls, function(control) {
            control.$setUntouched();
          });
        };
        form.$setSubmitted = function() {
          $animate.addClass(element, SUBMITTED_CLASS);
          form.$submitted = true;
          form.$$parentForm.$setSubmitted();
        };
      }
      var formDirectiveFactory = function(isNgForm) {
        return ['$timeout', '$parse', function($timeout, $parse) {
          var formDirective = {
            name: 'form',
            restrict: isNgForm ? 'EAC' : 'E',
            require: ['form', '^^?form'],
            controller: FormController,
            compile: function ngFormCompile(formElement, attr) {
              formElement.addClass(PRISTINE_CLASS).addClass(VALID_CLASS);
              var nameAttr = attr.name ? 'name' : (isNgForm && attr.ngForm ? 'ngForm' : false);
              return {pre: function ngFormPreLink(scope, formElement, attr, ctrls) {
                  var controller = ctrls[0];
                  if (!('action' in attr)) {
                    var handleFormSubmission = function(event) {
                      scope.$apply(function() {
                        controller.$commitViewValue();
                        controller.$setSubmitted();
                      });
                      event.preventDefault();
                    };
                    addEventListenerFn(formElement[0], 'submit', handleFormSubmission);
                    formElement.on('$destroy', function() {
                      $timeout(function() {
                        removeEventListenerFn(formElement[0], 'submit', handleFormSubmission);
                      }, 0, false);
                    });
                  }
                  var parentFormCtrl = ctrls[1] || controller.$$parentForm;
                  parentFormCtrl.$addControl(controller);
                  var setter = nameAttr ? getSetter(controller.$name) : noop;
                  if (nameAttr) {
                    setter(scope, controller);
                    attr.$observe(nameAttr, function(newValue) {
                      if (controller.$name === newValue)
                        return;
                      setter(scope, undefined);
                      controller.$$parentForm.$$renameControl(controller, newValue);
                      setter = getSetter(controller.$name);
                      setter(scope, controller);
                    });
                  }
                  formElement.on('$destroy', function() {
                    controller.$$parentForm.$removeControl(controller);
                    setter(scope, undefined);
                    extend(controller, nullFormCtrl);
                  });
                }};
            }
          };
          return formDirective;
          function getSetter(expression) {
            if (expression === '') {
              return $parse('this[""]').assign;
            }
            return $parse(expression).assign || noop;
          }
        }];
      };
      var formDirective = formDirectiveFactory();
      var ngFormDirective = formDirectiveFactory(true);
      var ISO_DATE_REGEXP = /^\d{4,}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+(?:[+-][0-2]\d:[0-5]\d|Z)$/;
      var URL_REGEXP = /^[a-z][a-z\d.+-]*:\/*(?:[^:@]+(?::[^@]+)?@)?(?:[^\s:/?#]+|\[[a-f\d:]+\])(?::\d+)?(?:\/[^?#]*)?(?:\?[^#]*)?(?:#.*)?$/i;
      var EMAIL_REGEXP = /^(?=.{1,254}$)(?=.{1,64}@)[-!#$%&'*+\/0-9=?A-Z^_`a-z{|}~]+(\.[-!#$%&'*+\/0-9=?A-Z^_`a-z{|}~]+)*@[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?(\.[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?)*$/;
      var NUMBER_REGEXP = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))([eE][+-]?\d+)?\s*$/;
      var DATE_REGEXP = /^(\d{4,})-(\d{2})-(\d{2})$/;
      var DATETIMELOCAL_REGEXP = /^(\d{4,})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
      var WEEK_REGEXP = /^(\d{4,})-W(\d\d)$/;
      var MONTH_REGEXP = /^(\d{4,})-(\d\d)$/;
      var TIME_REGEXP = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
      var PARTIAL_VALIDATION_EVENTS = 'keydown wheel mousedown';
      var PARTIAL_VALIDATION_TYPES = createMap();
      forEach('date,datetime-local,month,time,week'.split(','), function(type) {
        PARTIAL_VALIDATION_TYPES[type] = true;
      });
      var inputType = {
        'text': textInputType,
        'date': createDateInputType('date', DATE_REGEXP, createDateParser(DATE_REGEXP, ['yyyy', 'MM', 'dd']), 'yyyy-MM-dd'),
        'datetime-local': createDateInputType('datetimelocal', DATETIMELOCAL_REGEXP, createDateParser(DATETIMELOCAL_REGEXP, ['yyyy', 'MM', 'dd', 'HH', 'mm', 'ss', 'sss']), 'yyyy-MM-ddTHH:mm:ss.sss'),
        'time': createDateInputType('time', TIME_REGEXP, createDateParser(TIME_REGEXP, ['HH', 'mm', 'ss', 'sss']), 'HH:mm:ss.sss'),
        'week': createDateInputType('week', WEEK_REGEXP, weekParser, 'yyyy-Www'),
        'month': createDateInputType('month', MONTH_REGEXP, createDateParser(MONTH_REGEXP, ['yyyy', 'MM']), 'yyyy-MM'),
        'number': numberInputType,
        'url': urlInputType,
        'email': emailInputType,
        'radio': radioInputType,
        'checkbox': checkboxInputType,
        'hidden': noop,
        'button': noop,
        'submit': noop,
        'reset': noop,
        'file': noop
      };
      function stringBasedInputType(ctrl) {
        ctrl.$formatters.push(function(value) {
          return ctrl.$isEmpty(value) ? value : value.toString();
        });
      }
      function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        stringBasedInputType(ctrl);
      }
      function baseInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        var type = lowercase(element[0].type);
        if (!$sniffer.android) {
          var composing = false;
          element.on('compositionstart', function() {
            composing = true;
          });
          element.on('compositionend', function() {
            composing = false;
            listener();
          });
        }
        var timeout;
        var listener = function(ev) {
          if (timeout) {
            $browser.defer.cancel(timeout);
            timeout = null;
          }
          if (composing)
            return;
          var value = element.val(),
              event = ev && ev.type;
          if (type !== 'password' && (!attr.ngTrim || attr.ngTrim !== 'false')) {
            value = trim(value);
          }
          if (ctrl.$viewValue !== value || (value === '' && ctrl.$$hasNativeValidators)) {
            ctrl.$setViewValue(value, event);
          }
        };
        if ($sniffer.hasEvent('input')) {
          element.on('input', listener);
        } else {
          var deferListener = function(ev, input, origValue) {
            if (!timeout) {
              timeout = $browser.defer(function() {
                timeout = null;
                if (!input || input.value !== origValue) {
                  listener(ev);
                }
              });
            }
          };
          element.on('keydown', function(event) {
            var key = event.keyCode;
            if (key === 91 || (15 < key && key < 19) || (37 <= key && key <= 40))
              return;
            deferListener(event, this, this.value);
          });
          if ($sniffer.hasEvent('paste')) {
            element.on('paste cut', deferListener);
          }
        }
        element.on('change', listener);
        if (PARTIAL_VALIDATION_TYPES[type] && ctrl.$$hasNativeValidators && type === attr.type) {
          element.on(PARTIAL_VALIDATION_EVENTS, function(ev) {
            if (!timeout) {
              var validity = this[VALIDITY_STATE_PROPERTY];
              var origBadInput = validity.badInput;
              var origTypeMismatch = validity.typeMismatch;
              timeout = $browser.defer(function() {
                timeout = null;
                if (validity.badInput !== origBadInput || validity.typeMismatch !== origTypeMismatch) {
                  listener(ev);
                }
              });
            }
          });
        }
        ctrl.$render = function() {
          var value = ctrl.$isEmpty(ctrl.$viewValue) ? '' : ctrl.$viewValue;
          if (element.val() !== value) {
            element.val(value);
          }
        };
      }
      function weekParser(isoWeek, existingDate) {
        if (isDate(isoWeek)) {
          return isoWeek;
        }
        if (isString(isoWeek)) {
          WEEK_REGEXP.lastIndex = 0;
          var parts = WEEK_REGEXP.exec(isoWeek);
          if (parts) {
            var year = +parts[1],
                week = +parts[2],
                hours = 0,
                minutes = 0,
                seconds = 0,
                milliseconds = 0,
                firstThurs = getFirstThursdayOfYear(year),
                addDays = (week - 1) * 7;
            if (existingDate) {
              hours = existingDate.getHours();
              minutes = existingDate.getMinutes();
              seconds = existingDate.getSeconds();
              milliseconds = existingDate.getMilliseconds();
            }
            return new Date(year, 0, firstThurs.getDate() + addDays, hours, minutes, seconds, milliseconds);
          }
        }
        return NaN;
      }
      function createDateParser(regexp, mapping) {
        return function(iso, date) {
          var parts,
              map;
          if (isDate(iso)) {
            return iso;
          }
          if (isString(iso)) {
            if (iso.charAt(0) == '"' && iso.charAt(iso.length - 1) == '"') {
              iso = iso.substring(1, iso.length - 1);
            }
            if (ISO_DATE_REGEXP.test(iso)) {
              return new Date(iso);
            }
            regexp.lastIndex = 0;
            parts = regexp.exec(iso);
            if (parts) {
              parts.shift();
              if (date) {
                map = {
                  yyyy: date.getFullYear(),
                  MM: date.getMonth() + 1,
                  dd: date.getDate(),
                  HH: date.getHours(),
                  mm: date.getMinutes(),
                  ss: date.getSeconds(),
                  sss: date.getMilliseconds() / 1000
                };
              } else {
                map = {
                  yyyy: 1970,
                  MM: 1,
                  dd: 1,
                  HH: 0,
                  mm: 0,
                  ss: 0,
                  sss: 0
                };
              }
              forEach(parts, function(part, index) {
                if (index < mapping.length) {
                  map[mapping[index]] = +part;
                }
              });
              return new Date(map.yyyy, map.MM - 1, map.dd, map.HH, map.mm, map.ss || 0, map.sss * 1000 || 0);
            }
          }
          return NaN;
        };
      }
      function createDateInputType(type, regexp, parseDate, format) {
        return function dynamicDateInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter) {
          badInputChecker(scope, element, attr, ctrl);
          baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
          var timezone = ctrl && ctrl.$options && ctrl.$options.timezone;
          var previousDate;
          ctrl.$$parserName = type;
          ctrl.$parsers.push(function(value) {
            if (ctrl.$isEmpty(value))
              return null;
            if (regexp.test(value)) {
              var parsedDate = parseDate(value, previousDate);
              if (timezone) {
                parsedDate = convertTimezoneToLocal(parsedDate, timezone);
              }
              return parsedDate;
            }
            return undefined;
          });
          ctrl.$formatters.push(function(value) {
            if (value && !isDate(value)) {
              throw ngModelMinErr('datefmt', 'Expected `{0}` to be a date', value);
            }
            if (isValidDate(value)) {
              previousDate = value;
              if (previousDate && timezone) {
                previousDate = convertTimezoneToLocal(previousDate, timezone, true);
              }
              return $filter('date')(value, format, timezone);
            } else {
              previousDate = null;
              return '';
            }
          });
          if (isDefined(attr.min) || attr.ngMin) {
            var minVal;
            ctrl.$validators.min = function(value) {
              return !isValidDate(value) || isUndefined(minVal) || parseDate(value) >= minVal;
            };
            attr.$observe('min', function(val) {
              minVal = parseObservedDateValue(val);
              ctrl.$validate();
            });
          }
          if (isDefined(attr.max) || attr.ngMax) {
            var maxVal;
            ctrl.$validators.max = function(value) {
              return !isValidDate(value) || isUndefined(maxVal) || parseDate(value) <= maxVal;
            };
            attr.$observe('max', function(val) {
              maxVal = parseObservedDateValue(val);
              ctrl.$validate();
            });
          }
          function isValidDate(value) {
            return value && !(value.getTime && value.getTime() !== value.getTime());
          }
          function parseObservedDateValue(val) {
            return isDefined(val) && !isDate(val) ? parseDate(val) || undefined : val;
          }
        };
      }
      function badInputChecker(scope, element, attr, ctrl) {
        var node = element[0];
        var nativeValidation = ctrl.$$hasNativeValidators = isObject(node.validity);
        if (nativeValidation) {
          ctrl.$parsers.push(function(value) {
            var validity = element.prop(VALIDITY_STATE_PROPERTY) || {};
            return validity.badInput || validity.typeMismatch ? undefined : value;
          });
        }
      }
      function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        badInputChecker(scope, element, attr, ctrl);
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        ctrl.$$parserName = 'number';
        ctrl.$parsers.push(function(value) {
          if (ctrl.$isEmpty(value))
            return null;
          if (NUMBER_REGEXP.test(value))
            return parseFloat(value);
          return undefined;
        });
        ctrl.$formatters.push(function(value) {
          if (!ctrl.$isEmpty(value)) {
            if (!isNumber(value)) {
              throw ngModelMinErr('numfmt', 'Expected `{0}` to be a number', value);
            }
            value = value.toString();
          }
          return value;
        });
        if (isDefined(attr.min) || attr.ngMin) {
          var minVal;
          ctrl.$validators.min = function(value) {
            return ctrl.$isEmpty(value) || isUndefined(minVal) || value >= minVal;
          };
          attr.$observe('min', function(val) {
            if (isDefined(val) && !isNumber(val)) {
              val = parseFloat(val, 10);
            }
            minVal = isNumber(val) && !isNaN(val) ? val : undefined;
            ctrl.$validate();
          });
        }
        if (isDefined(attr.max) || attr.ngMax) {
          var maxVal;
          ctrl.$validators.max = function(value) {
            return ctrl.$isEmpty(value) || isUndefined(maxVal) || value <= maxVal;
          };
          attr.$observe('max', function(val) {
            if (isDefined(val) && !isNumber(val)) {
              val = parseFloat(val, 10);
            }
            maxVal = isNumber(val) && !isNaN(val) ? val : undefined;
            ctrl.$validate();
          });
        }
      }
      function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        stringBasedInputType(ctrl);
        ctrl.$$parserName = 'url';
        ctrl.$validators.url = function(modelValue, viewValue) {
          var value = modelValue || viewValue;
          return ctrl.$isEmpty(value) || URL_REGEXP.test(value);
        };
      }
      function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        stringBasedInputType(ctrl);
        ctrl.$$parserName = 'email';
        ctrl.$validators.email = function(modelValue, viewValue) {
          var value = modelValue || viewValue;
          return ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value);
        };
      }
      function radioInputType(scope, element, attr, ctrl) {
        if (isUndefined(attr.name)) {
          element.attr('name', nextUid());
        }
        var listener = function(ev) {
          if (element[0].checked) {
            ctrl.$setViewValue(attr.value, ev && ev.type);
          }
        };
        element.on('click', listener);
        ctrl.$render = function() {
          var value = attr.value;
          element[0].checked = (value == ctrl.$viewValue);
        };
        attr.$observe('value', ctrl.$render);
      }
      function parseConstantExpr($parse, context, name, expression, fallback) {
        var parseFn;
        if (isDefined(expression)) {
          parseFn = $parse(expression);
          if (!parseFn.constant) {
            throw ngModelMinErr('constexpr', 'Expected constant expression for `{0}`, but saw ' + '`{1}`.', name, expression);
          }
          return parseFn(context);
        }
        return fallback;
      }
      function checkboxInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) {
        var trueValue = parseConstantExpr($parse, scope, 'ngTrueValue', attr.ngTrueValue, true);
        var falseValue = parseConstantExpr($parse, scope, 'ngFalseValue', attr.ngFalseValue, false);
        var listener = function(ev) {
          ctrl.$setViewValue(element[0].checked, ev && ev.type);
        };
        element.on('click', listener);
        ctrl.$render = function() {
          element[0].checked = ctrl.$viewValue;
        };
        ctrl.$isEmpty = function(value) {
          return value === false;
        };
        ctrl.$formatters.push(function(value) {
          return equals(value, trueValue);
        });
        ctrl.$parsers.push(function(value) {
          return value ? trueValue : falseValue;
        });
      }
      var inputDirective = ['$browser', '$sniffer', '$filter', '$parse', function($browser, $sniffer, $filter, $parse) {
        return {
          restrict: 'E',
          require: ['?ngModel'],
          link: {pre: function(scope, element, attr, ctrls) {
              if (ctrls[0]) {
                (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrls[0], $sniffer, $browser, $filter, $parse);
              }
            }}
        };
      }];
      var CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/;
      var ngValueDirective = function() {
        return {
          restrict: 'A',
          priority: 100,
          compile: function(tpl, tplAttr) {
            if (CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue)) {
              return function ngValueConstantLink(scope, elm, attr) {
                attr.$set('value', scope.$eval(attr.ngValue));
              };
            } else {
              return function ngValueLink(scope, elm, attr) {
                scope.$watch(attr.ngValue, function valueWatchAction(value) {
                  attr.$set('value', value);
                });
              };
            }
          }
        };
      };
      var ngBindDirective = ['$compile', function($compile) {
        return {
          restrict: 'AC',
          compile: function ngBindCompile(templateElement) {
            $compile.$$addBindingClass(templateElement);
            return function ngBindLink(scope, element, attr) {
              $compile.$$addBindingInfo(element, attr.ngBind);
              element = element[0];
              scope.$watch(attr.ngBind, function ngBindWatchAction(value) {
                element.textContent = isUndefined(value) ? '' : value;
              });
            };
          }
        };
      }];
      var ngBindTemplateDirective = ['$interpolate', '$compile', function($interpolate, $compile) {
        return {compile: function ngBindTemplateCompile(templateElement) {
            $compile.$$addBindingClass(templateElement);
            return function ngBindTemplateLink(scope, element, attr) {
              var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
              $compile.$$addBindingInfo(element, interpolateFn.expressions);
              element = element[0];
              attr.$observe('ngBindTemplate', function(value) {
                element.textContent = isUndefined(value) ? '' : value;
              });
            };
          }};
      }];
      var ngBindHtmlDirective = ['$sce', '$parse', '$compile', function($sce, $parse, $compile) {
        return {
          restrict: 'A',
          compile: function ngBindHtmlCompile(tElement, tAttrs) {
            var ngBindHtmlGetter = $parse(tAttrs.ngBindHtml);
            var ngBindHtmlWatch = $parse(tAttrs.ngBindHtml, function sceValueOf(val) {
              return $sce.valueOf(val);
            });
            $compile.$$addBindingClass(tElement);
            return function ngBindHtmlLink(scope, element, attr) {
              $compile.$$addBindingInfo(element, attr.ngBindHtml);
              scope.$watch(ngBindHtmlWatch, function ngBindHtmlWatchAction() {
                var value = ngBindHtmlGetter(scope);
                element.html($sce.getTrustedHtml(value) || '');
              });
            };
          }
        };
      }];
      var ngChangeDirective = valueFn({
        restrict: 'A',
        require: 'ngModel',
        link: function(scope, element, attr, ctrl) {
          ctrl.$viewChangeListeners.push(function() {
            scope.$eval(attr.ngChange);
          });
        }
      });
      function classDirective(name, selector) {
        name = 'ngClass' + name;
        return ['$animate', function($animate) {
          return {
            restrict: 'AC',
            link: function(scope, element, attr) {
              var oldVal;
              scope.$watch(attr[name], ngClassWatchAction, true);
              attr.$observe('class', function(value) {
                ngClassWatchAction(scope.$eval(attr[name]));
              });
              if (name !== 'ngClass') {
                scope.$watch('$index', function($index, old$index) {
                  var mod = $index & 1;
                  if (mod !== (old$index & 1)) {
                    var classes = arrayClasses(scope.$eval(attr[name]));
                    mod === selector ? addClasses(classes) : removeClasses(classes);
                  }
                });
              }
              function addClasses(classes) {
                var newClasses = digestClassCounts(classes, 1);
                attr.$addClass(newClasses);
              }
              function removeClasses(classes) {
                var newClasses = digestClassCounts(classes, -1);
                attr.$removeClass(newClasses);
              }
              function digestClassCounts(classes, count) {
                var classCounts = element.data('$classCounts') || createMap();
                var classesToUpdate = [];
                forEach(classes, function(className) {
                  if (count > 0 || classCounts[className]) {
                    classCounts[className] = (classCounts[className] || 0) + count;
                    if (classCounts[className] === +(count > 0)) {
                      classesToUpdate.push(className);
                    }
                  }
                });
                element.data('$classCounts', classCounts);
                return classesToUpdate.join(' ');
              }
              function updateClasses(oldClasses, newClasses) {
                var toAdd = arrayDifference(newClasses, oldClasses);
                var toRemove = arrayDifference(oldClasses, newClasses);
                toAdd = digestClassCounts(toAdd, 1);
                toRemove = digestClassCounts(toRemove, -1);
                if (toAdd && toAdd.length) {
                  $animate.addClass(element, toAdd);
                }
                if (toRemove && toRemove.length) {
                  $animate.removeClass(element, toRemove);
                }
              }
              function ngClassWatchAction(newVal) {
                if (selector === true || (scope.$index & 1) === selector) {
                  var newClasses = arrayClasses(newVal || []);
                  if (!oldVal) {
                    addClasses(newClasses);
                  } else if (!equals(newVal, oldVal)) {
                    var oldClasses = arrayClasses(oldVal);
                    updateClasses(oldClasses, newClasses);
                  }
                }
                if (isArray(newVal)) {
                  oldVal = newVal.map(function(v) {
                    return shallowCopy(v);
                  });
                } else {
                  oldVal = shallowCopy(newVal);
                }
              }
            }
          };
          function arrayDifference(tokens1, tokens2) {
            var values = [];
            outer: for (var i = 0; i < tokens1.length; i++) {
              var token = tokens1[i];
              for (var j = 0; j < tokens2.length; j++) {
                if (token == tokens2[j])
                  continue outer;
              }
              values.push(token);
            }
            return values;
          }
          function arrayClasses(classVal) {
            var classes = [];
            if (isArray(classVal)) {
              forEach(classVal, function(v) {
                classes = classes.concat(arrayClasses(v));
              });
              return classes;
            } else if (isString(classVal)) {
              return classVal.split(' ');
            } else if (isObject(classVal)) {
              forEach(classVal, function(v, k) {
                if (v) {
                  classes = classes.concat(k.split(' '));
                }
              });
              return classes;
            }
            return classVal;
          }
        }];
      }
      var ngClassDirective = classDirective('', true);
      var ngClassOddDirective = classDirective('Odd', 0);
      var ngClassEvenDirective = classDirective('Even', 1);
      var ngCloakDirective = ngDirective({compile: function(element, attr) {
          attr.$set('ngCloak', undefined);
          element.removeClass('ng-cloak');
        }});
      var ngControllerDirective = [function() {
        return {
          restrict: 'A',
          scope: true,
          controller: '@',
          priority: 500
        };
      }];
      var ngEventDirectives = {};
      var forceAsyncEvents = {
        'blur': true,
        'focus': true
      };
      forEach('click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste'.split(' '), function(eventName) {
        var directiveName = directiveNormalize('ng-' + eventName);
        ngEventDirectives[directiveName] = ['$parse', '$rootScope', function($parse, $rootScope) {
          return {
            restrict: 'A',
            compile: function($element, attr) {
              var fn = $parse(attr[directiveName], null, true);
              return function ngEventHandler(scope, element) {
                element.on(eventName, function(event) {
                  var callback = function() {
                    fn(scope, {$event: event});
                  };
                  if (forceAsyncEvents[eventName] && $rootScope.$$phase) {
                    scope.$evalAsync(callback);
                  } else {
                    scope.$apply(callback);
                  }
                });
              };
            }
          };
        }];
      });
      var ngIfDirective = ['$animate', '$compile', function($animate, $compile) {
        return {
          multiElement: true,
          transclude: 'element',
          priority: 600,
          terminal: true,
          restrict: 'A',
          $$tlb: true,
          link: function($scope, $element, $attr, ctrl, $transclude) {
            var block,
                childScope,
                previousElements;
            $scope.$watch($attr.ngIf, function ngIfWatchAction(value) {
              if (value) {
                if (!childScope) {
                  $transclude(function(clone, newScope) {
                    childScope = newScope;
                    clone[clone.length++] = $compile.$$createComment('end ngIf', $attr.ngIf);
                    block = {clone: clone};
                    $animate.enter(clone, $element.parent(), $element);
                  });
                }
              } else {
                if (previousElements) {
                  previousElements.remove();
                  previousElements = null;
                }
                if (childScope) {
                  childScope.$destroy();
                  childScope = null;
                }
                if (block) {
                  previousElements = getBlockNodes(block.clone);
                  $animate.leave(previousElements).then(function() {
                    previousElements = null;
                  });
                  block = null;
                }
              }
            });
          }
        };
      }];
      var ngIncludeDirective = ['$templateRequest', '$anchorScroll', '$animate', function($templateRequest, $anchorScroll, $animate) {
        return {
          restrict: 'ECA',
          priority: 400,
          terminal: true,
          transclude: 'element',
          controller: angular.noop,
          compile: function(element, attr) {
            var srcExp = attr.ngInclude || attr.src,
                onloadExp = attr.onload || '',
                autoScrollExp = attr.autoscroll;
            return function(scope, $element, $attr, ctrl, $transclude) {
              var changeCounter = 0,
                  currentScope,
                  previousElement,
                  currentElement;
              var cleanupLastIncludeContent = function() {
                if (previousElement) {
                  previousElement.remove();
                  previousElement = null;
                }
                if (currentScope) {
                  currentScope.$destroy();
                  currentScope = null;
                }
                if (currentElement) {
                  $animate.leave(currentElement).then(function() {
                    previousElement = null;
                  });
                  previousElement = currentElement;
                  currentElement = null;
                }
              };
              scope.$watch(srcExp, function ngIncludeWatchAction(src) {
                var afterAnimation = function() {
                  if (isDefined(autoScrollExp) && (!autoScrollExp || scope.$eval(autoScrollExp))) {
                    $anchorScroll();
                  }
                };
                var thisChangeId = ++changeCounter;
                if (src) {
                  $templateRequest(src, true).then(function(response) {
                    if (scope.$$destroyed)
                      return;
                    if (thisChangeId !== changeCounter)
                      return;
                    var newScope = scope.$new();
                    ctrl.template = response;
                    var clone = $transclude(newScope, function(clone) {
                      cleanupLastIncludeContent();
                      $animate.enter(clone, null, $element).then(afterAnimation);
                    });
                    currentScope = newScope;
                    currentElement = clone;
                    currentScope.$emit('$includeContentLoaded', src);
                    scope.$eval(onloadExp);
                  }, function() {
                    if (scope.$$destroyed)
                      return;
                    if (thisChangeId === changeCounter) {
                      cleanupLastIncludeContent();
                      scope.$emit('$includeContentError', src);
                    }
                  });
                  scope.$emit('$includeContentRequested', src);
                } else {
                  cleanupLastIncludeContent();
                  ctrl.template = null;
                }
              });
            };
          }
        };
      }];
      var ngIncludeFillContentDirective = ['$compile', function($compile) {
        return {
          restrict: 'ECA',
          priority: -400,
          require: 'ngInclude',
          link: function(scope, $element, $attr, ctrl) {
            if (toString.call($element[0]).match(/SVG/)) {
              $element.empty();
              $compile(jqLiteBuildFragment(ctrl.template, window.document).childNodes)(scope, function namespaceAdaptedClone(clone) {
                $element.append(clone);
              }, {futureParentElement: $element});
              return;
            }
            $element.html(ctrl.template);
            $compile($element.contents())(scope);
          }
        };
      }];
      var ngInitDirective = ngDirective({
        priority: 450,
        compile: function() {
          return {pre: function(scope, element, attrs) {
              scope.$eval(attrs.ngInit);
            }};
        }
      });
      var ngListDirective = function() {
        return {
          restrict: 'A',
          priority: 100,
          require: 'ngModel',
          link: function(scope, element, attr, ctrl) {
            var ngList = element.attr(attr.$attr.ngList) || ', ';
            var trimValues = attr.ngTrim !== 'false';
            var separator = trimValues ? trim(ngList) : ngList;
            var parse = function(viewValue) {
              if (isUndefined(viewValue))
                return;
              var list = [];
              if (viewValue) {
                forEach(viewValue.split(separator), function(value) {
                  if (value)
                    list.push(trimValues ? trim(value) : value);
                });
              }
              return list;
            };
            ctrl.$parsers.push(parse);
            ctrl.$formatters.push(function(value) {
              if (isArray(value)) {
                return value.join(ngList);
              }
              return undefined;
            });
            ctrl.$isEmpty = function(value) {
              return !value || !value.length;
            };
          }
        };
      };
      var VALID_CLASS = 'ng-valid',
          INVALID_CLASS = 'ng-invalid',
          PRISTINE_CLASS = 'ng-pristine',
          DIRTY_CLASS = 'ng-dirty',
          UNTOUCHED_CLASS = 'ng-untouched',
          TOUCHED_CLASS = 'ng-touched',
          PENDING_CLASS = 'ng-pending',
          EMPTY_CLASS = 'ng-empty',
          NOT_EMPTY_CLASS = 'ng-not-empty';
      var ngModelMinErr = minErr('ngModel');
      var NgModelController = ['$scope', '$exceptionHandler', '$attrs', '$element', '$parse', '$animate', '$timeout', '$rootScope', '$q', '$interpolate', function($scope, $exceptionHandler, $attr, $element, $parse, $animate, $timeout, $rootScope, $q, $interpolate) {
        this.$viewValue = Number.NaN;
        this.$modelValue = Number.NaN;
        this.$$rawModelValue = undefined;
        this.$validators = {};
        this.$asyncValidators = {};
        this.$parsers = [];
        this.$formatters = [];
        this.$viewChangeListeners = [];
        this.$untouched = true;
        this.$touched = false;
        this.$pristine = true;
        this.$dirty = false;
        this.$valid = true;
        this.$invalid = false;
        this.$error = {};
        this.$$success = {};
        this.$pending = undefined;
        this.$name = $interpolate($attr.name || '', false)($scope);
        this.$$parentForm = nullFormCtrl;
        var parsedNgModel = $parse($attr.ngModel),
            parsedNgModelAssign = parsedNgModel.assign,
            ngModelGet = parsedNgModel,
            ngModelSet = parsedNgModelAssign,
            pendingDebounce = null,
            parserValid,
            ctrl = this;
        this.$$setOptions = function(options) {
          ctrl.$options = options;
          if (options && options.getterSetter) {
            var invokeModelGetter = $parse($attr.ngModel + '()'),
                invokeModelSetter = $parse($attr.ngModel + '($$$p)');
            ngModelGet = function($scope) {
              var modelValue = parsedNgModel($scope);
              if (isFunction(modelValue)) {
                modelValue = invokeModelGetter($scope);
              }
              return modelValue;
            };
            ngModelSet = function($scope, newValue) {
              if (isFunction(parsedNgModel($scope))) {
                invokeModelSetter($scope, {$$$p: newValue});
              } else {
                parsedNgModelAssign($scope, newValue);
              }
            };
          } else if (!parsedNgModel.assign) {
            throw ngModelMinErr('nonassign', "Expression '{0}' is non-assignable. Element: {1}", $attr.ngModel, startingTag($element));
          }
        };
        this.$render = noop;
        this.$isEmpty = function(value) {
          return isUndefined(value) || value === '' || value === null || value !== value;
        };
        this.$$updateEmptyClasses = function(value) {
          if (ctrl.$isEmpty(value)) {
            $animate.removeClass($element, NOT_EMPTY_CLASS);
            $animate.addClass($element, EMPTY_CLASS);
          } else {
            $animate.removeClass($element, EMPTY_CLASS);
            $animate.addClass($element, NOT_EMPTY_CLASS);
          }
        };
        var currentValidationRunId = 0;
        addSetValidityMethod({
          ctrl: this,
          $element: $element,
          set: function(object, property) {
            object[property] = true;
          },
          unset: function(object, property) {
            delete object[property];
          },
          $animate: $animate
        });
        this.$setPristine = function() {
          ctrl.$dirty = false;
          ctrl.$pristine = true;
          $animate.removeClass($element, DIRTY_CLASS);
          $animate.addClass($element, PRISTINE_CLASS);
        };
        this.$setDirty = function() {
          ctrl.$dirty = true;
          ctrl.$pristine = false;
          $animate.removeClass($element, PRISTINE_CLASS);
          $animate.addClass($element, DIRTY_CLASS);
          ctrl.$$parentForm.$setDirty();
        };
        this.$setUntouched = function() {
          ctrl.$touched = false;
          ctrl.$untouched = true;
          $animate.setClass($element, UNTOUCHED_CLASS, TOUCHED_CLASS);
        };
        this.$setTouched = function() {
          ctrl.$touched = true;
          ctrl.$untouched = false;
          $animate.setClass($element, TOUCHED_CLASS, UNTOUCHED_CLASS);
        };
        this.$rollbackViewValue = function() {
          $timeout.cancel(pendingDebounce);
          ctrl.$viewValue = ctrl.$$lastCommittedViewValue;
          ctrl.$render();
        };
        this.$validate = function() {
          if (isNumber(ctrl.$modelValue) && isNaN(ctrl.$modelValue)) {
            return;
          }
          var viewValue = ctrl.$$lastCommittedViewValue;
          var modelValue = ctrl.$$rawModelValue;
          var prevValid = ctrl.$valid;
          var prevModelValue = ctrl.$modelValue;
          var allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
          ctrl.$$runValidators(modelValue, viewValue, function(allValid) {
            if (!allowInvalid && prevValid !== allValid) {
              ctrl.$modelValue = allValid ? modelValue : undefined;
              if (ctrl.$modelValue !== prevModelValue) {
                ctrl.$$writeModelToScope();
              }
            }
          });
        };
        this.$$runValidators = function(modelValue, viewValue, doneCallback) {
          currentValidationRunId++;
          var localValidationRunId = currentValidationRunId;
          if (!processParseErrors()) {
            validationDone(false);
            return;
          }
          if (!processSyncValidators()) {
            validationDone(false);
            return;
          }
          processAsyncValidators();
          function processParseErrors() {
            var errorKey = ctrl.$$parserName || 'parse';
            if (isUndefined(parserValid)) {
              setValidity(errorKey, null);
            } else {
              if (!parserValid) {
                forEach(ctrl.$validators, function(v, name) {
                  setValidity(name, null);
                });
                forEach(ctrl.$asyncValidators, function(v, name) {
                  setValidity(name, null);
                });
              }
              setValidity(errorKey, parserValid);
              return parserValid;
            }
            return true;
          }
          function processSyncValidators() {
            var syncValidatorsValid = true;
            forEach(ctrl.$validators, function(validator, name) {
              var result = validator(modelValue, viewValue);
              syncValidatorsValid = syncValidatorsValid && result;
              setValidity(name, result);
            });
            if (!syncValidatorsValid) {
              forEach(ctrl.$asyncValidators, function(v, name) {
                setValidity(name, null);
              });
              return false;
            }
            return true;
          }
          function processAsyncValidators() {
            var validatorPromises = [];
            var allValid = true;
            forEach(ctrl.$asyncValidators, function(validator, name) {
              var promise = validator(modelValue, viewValue);
              if (!isPromiseLike(promise)) {
                throw ngModelMinErr('nopromise', "Expected asynchronous validator to return a promise but got '{0}' instead.", promise);
              }
              setValidity(name, undefined);
              validatorPromises.push(promise.then(function() {
                setValidity(name, true);
              }, function() {
                allValid = false;
                setValidity(name, false);
              }));
            });
            if (!validatorPromises.length) {
              validationDone(true);
            } else {
              $q.all(validatorPromises).then(function() {
                validationDone(allValid);
              }, noop);
            }
          }
          function setValidity(name, isValid) {
            if (localValidationRunId === currentValidationRunId) {
              ctrl.$setValidity(name, isValid);
            }
          }
          function validationDone(allValid) {
            if (localValidationRunId === currentValidationRunId) {
              doneCallback(allValid);
            }
          }
        };
        this.$commitViewValue = function() {
          var viewValue = ctrl.$viewValue;
          $timeout.cancel(pendingDebounce);
          if (ctrl.$$lastCommittedViewValue === viewValue && (viewValue !== '' || !ctrl.$$hasNativeValidators)) {
            return;
          }
          ctrl.$$updateEmptyClasses(viewValue);
          ctrl.$$lastCommittedViewValue = viewValue;
          if (ctrl.$pristine) {
            this.$setDirty();
          }
          this.$$parseAndValidate();
        };
        this.$$parseAndValidate = function() {
          var viewValue = ctrl.$$lastCommittedViewValue;
          var modelValue = viewValue;
          parserValid = isUndefined(modelValue) ? undefined : true;
          if (parserValid) {
            for (var i = 0; i < ctrl.$parsers.length; i++) {
              modelValue = ctrl.$parsers[i](modelValue);
              if (isUndefined(modelValue)) {
                parserValid = false;
                break;
              }
            }
          }
          if (isNumber(ctrl.$modelValue) && isNaN(ctrl.$modelValue)) {
            ctrl.$modelValue = ngModelGet($scope);
          }
          var prevModelValue = ctrl.$modelValue;
          var allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
          ctrl.$$rawModelValue = modelValue;
          if (allowInvalid) {
            ctrl.$modelValue = modelValue;
            writeToModelIfNeeded();
          }
          ctrl.$$runValidators(modelValue, ctrl.$$lastCommittedViewValue, function(allValid) {
            if (!allowInvalid) {
              ctrl.$modelValue = allValid ? modelValue : undefined;
              writeToModelIfNeeded();
            }
          });
          function writeToModelIfNeeded() {
            if (ctrl.$modelValue !== prevModelValue) {
              ctrl.$$writeModelToScope();
            }
          }
        };
        this.$$writeModelToScope = function() {
          ngModelSet($scope, ctrl.$modelValue);
          forEach(ctrl.$viewChangeListeners, function(listener) {
            try {
              listener();
            } catch (e) {
              $exceptionHandler(e);
            }
          });
        };
        this.$setViewValue = function(value, trigger) {
          ctrl.$viewValue = value;
          if (!ctrl.$options || ctrl.$options.updateOnDefault) {
            ctrl.$$debounceViewValueCommit(trigger);
          }
        };
        this.$$debounceViewValueCommit = function(trigger) {
          var debounceDelay = 0,
              options = ctrl.$options,
              debounce;
          if (options && isDefined(options.debounce)) {
            debounce = options.debounce;
            if (isNumber(debounce)) {
              debounceDelay = debounce;
            } else if (isNumber(debounce[trigger])) {
              debounceDelay = debounce[trigger];
            } else if (isNumber(debounce['default'])) {
              debounceDelay = debounce['default'];
            }
          }
          $timeout.cancel(pendingDebounce);
          if (debounceDelay) {
            pendingDebounce = $timeout(function() {
              ctrl.$commitViewValue();
            }, debounceDelay);
          } else if ($rootScope.$$phase) {
            ctrl.$commitViewValue();
          } else {
            $scope.$apply(function() {
              ctrl.$commitViewValue();
            });
          }
        };
        $scope.$watch(function ngModelWatch() {
          var modelValue = ngModelGet($scope);
          if (modelValue !== ctrl.$modelValue && (ctrl.$modelValue === ctrl.$modelValue || modelValue === modelValue)) {
            ctrl.$modelValue = ctrl.$$rawModelValue = modelValue;
            parserValid = undefined;
            var formatters = ctrl.$formatters,
                idx = formatters.length;
            var viewValue = modelValue;
            while (idx--) {
              viewValue = formatters[idx](viewValue);
            }
            if (ctrl.$viewValue !== viewValue) {
              ctrl.$$updateEmptyClasses(viewValue);
              ctrl.$viewValue = ctrl.$$lastCommittedViewValue = viewValue;
              ctrl.$render();
              ctrl.$$runValidators(modelValue, viewValue, noop);
            }
          }
          return modelValue;
        });
      }];
      var ngModelDirective = ['$rootScope', function($rootScope) {
        return {
          restrict: 'A',
          require: ['ngModel', '^?form', '^?ngModelOptions'],
          controller: NgModelController,
          priority: 1,
          compile: function ngModelCompile(element) {
            element.addClass(PRISTINE_CLASS).addClass(UNTOUCHED_CLASS).addClass(VALID_CLASS);
            return {
              pre: function ngModelPreLink(scope, element, attr, ctrls) {
                var modelCtrl = ctrls[0],
                    formCtrl = ctrls[1] || modelCtrl.$$parentForm;
                modelCtrl.$$setOptions(ctrls[2] && ctrls[2].$options);
                formCtrl.$addControl(modelCtrl);
                attr.$observe('name', function(newValue) {
                  if (modelCtrl.$name !== newValue) {
                    modelCtrl.$$parentForm.$$renameControl(modelCtrl, newValue);
                  }
                });
                scope.$on('$destroy', function() {
                  modelCtrl.$$parentForm.$removeControl(modelCtrl);
                });
              },
              post: function ngModelPostLink(scope, element, attr, ctrls) {
                var modelCtrl = ctrls[0];
                if (modelCtrl.$options && modelCtrl.$options.updateOn) {
                  element.on(modelCtrl.$options.updateOn, function(ev) {
                    modelCtrl.$$debounceViewValueCommit(ev && ev.type);
                  });
                }
                element.on('blur', function() {
                  if (modelCtrl.$touched)
                    return;
                  if ($rootScope.$$phase) {
                    scope.$evalAsync(modelCtrl.$setTouched);
                  } else {
                    scope.$apply(modelCtrl.$setTouched);
                  }
                });
              }
            };
          }
        };
      }];
      var DEFAULT_REGEXP = /(\s+|^)default(\s+|$)/;
      var ngModelOptionsDirective = function() {
        return {
          restrict: 'A',
          controller: ['$scope', '$attrs', function($scope, $attrs) {
            var that = this;
            this.$options = copy($scope.$eval($attrs.ngModelOptions));
            if (isDefined(this.$options.updateOn)) {
              this.$options.updateOnDefault = false;
              this.$options.updateOn = trim(this.$options.updateOn.replace(DEFAULT_REGEXP, function() {
                that.$options.updateOnDefault = true;
                return ' ';
              }));
            } else {
              this.$options.updateOnDefault = true;
            }
          }]
        };
      };
      function addSetValidityMethod(context) {
        var ctrl = context.ctrl,
            $element = context.$element,
            classCache = {},
            set = context.set,
            unset = context.unset,
            $animate = context.$animate;
        classCache[INVALID_CLASS] = !(classCache[VALID_CLASS] = $element.hasClass(VALID_CLASS));
        ctrl.$setValidity = setValidity;
        function setValidity(validationErrorKey, state, controller) {
          if (isUndefined(state)) {
            createAndSet('$pending', validationErrorKey, controller);
          } else {
            unsetAndCleanup('$pending', validationErrorKey, controller);
          }
          if (!isBoolean(state)) {
            unset(ctrl.$error, validationErrorKey, controller);
            unset(ctrl.$$success, validationErrorKey, controller);
          } else {
            if (state) {
              unset(ctrl.$error, validationErrorKey, controller);
              set(ctrl.$$success, validationErrorKey, controller);
            } else {
              set(ctrl.$error, validationErrorKey, controller);
              unset(ctrl.$$success, validationErrorKey, controller);
            }
          }
          if (ctrl.$pending) {
            cachedToggleClass(PENDING_CLASS, true);
            ctrl.$valid = ctrl.$invalid = undefined;
            toggleValidationCss('', null);
          } else {
            cachedToggleClass(PENDING_CLASS, false);
            ctrl.$valid = isObjectEmpty(ctrl.$error);
            ctrl.$invalid = !ctrl.$valid;
            toggleValidationCss('', ctrl.$valid);
          }
          var combinedState;
          if (ctrl.$pending && ctrl.$pending[validationErrorKey]) {
            combinedState = undefined;
          } else if (ctrl.$error[validationErrorKey]) {
            combinedState = false;
          } else if (ctrl.$$success[validationErrorKey]) {
            combinedState = true;
          } else {
            combinedState = null;
          }
          toggleValidationCss(validationErrorKey, combinedState);
          ctrl.$$parentForm.$setValidity(validationErrorKey, combinedState, ctrl);
        }
        function createAndSet(name, value, controller) {
          if (!ctrl[name]) {
            ctrl[name] = {};
          }
          set(ctrl[name], value, controller);
        }
        function unsetAndCleanup(name, value, controller) {
          if (ctrl[name]) {
            unset(ctrl[name], value, controller);
          }
          if (isObjectEmpty(ctrl[name])) {
            ctrl[name] = undefined;
          }
        }
        function cachedToggleClass(className, switchValue) {
          if (switchValue && !classCache[className]) {
            $animate.addClass($element, className);
            classCache[className] = true;
          } else if (!switchValue && classCache[className]) {
            $animate.removeClass($element, className);
            classCache[className] = false;
          }
        }
        function toggleValidationCss(validationErrorKey, isValid) {
          validationErrorKey = validationErrorKey ? '-' + snake_case(validationErrorKey, '-') : '';
          cachedToggleClass(VALID_CLASS + validationErrorKey, isValid === true);
          cachedToggleClass(INVALID_CLASS + validationErrorKey, isValid === false);
        }
      }
      function isObjectEmpty(obj) {
        if (obj) {
          for (var prop in obj) {
            if (obj.hasOwnProperty(prop)) {
              return false;
            }
          }
        }
        return true;
      }
      var ngNonBindableDirective = ngDirective({
        terminal: true,
        priority: 1000
      });
      var ngOptionsMinErr = minErr('ngOptions');
      var NG_OPTIONS_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/;
      var ngOptionsDirective = ['$compile', '$document', '$parse', function($compile, $document, $parse) {
        function parseOptionsExpression(optionsExp, selectElement, scope) {
          var match = optionsExp.match(NG_OPTIONS_REGEXP);
          if (!(match)) {
            throw ngOptionsMinErr('iexp', "Expected expression in form of " + "'_select_ (as _label_)? for (_key_,)?_value_ in _collection_'" + " but got '{0}'. Element: {1}", optionsExp, startingTag(selectElement));
          }
          var valueName = match[5] || match[7];
          var keyName = match[6];
          var selectAs = / as /.test(match[0]) && match[1];
          var trackBy = match[9];
          var valueFn = $parse(match[2] ? match[1] : valueName);
          var selectAsFn = selectAs && $parse(selectAs);
          var viewValueFn = selectAsFn || valueFn;
          var trackByFn = trackBy && $parse(trackBy);
          var getTrackByValueFn = trackBy ? function(value, locals) {
            return trackByFn(scope, locals);
          } : function getHashOfValue(value) {
            return hashKey(value);
          };
          var getTrackByValue = function(value, key) {
            return getTrackByValueFn(value, getLocals(value, key));
          };
          var displayFn = $parse(match[2] || match[1]);
          var groupByFn = $parse(match[3] || '');
          var disableWhenFn = $parse(match[4] || '');
          var valuesFn = $parse(match[8]);
          var locals = {};
          var getLocals = keyName ? function(value, key) {
            locals[keyName] = key;
            locals[valueName] = value;
            return locals;
          } : function(value) {
            locals[valueName] = value;
            return locals;
          };
          function Option(selectValue, viewValue, label, group, disabled) {
            this.selectValue = selectValue;
            this.viewValue = viewValue;
            this.label = label;
            this.group = group;
            this.disabled = disabled;
          }
          function getOptionValuesKeys(optionValues) {
            var optionValuesKeys;
            if (!keyName && isArrayLike(optionValues)) {
              optionValuesKeys = optionValues;
            } else {
              optionValuesKeys = [];
              for (var itemKey in optionValues) {
                if (optionValues.hasOwnProperty(itemKey) && itemKey.charAt(0) !== '$') {
                  optionValuesKeys.push(itemKey);
                }
              }
            }
            return optionValuesKeys;
          }
          return {
            trackBy: trackBy,
            getTrackByValue: getTrackByValue,
            getWatchables: $parse(valuesFn, function(optionValues) {
              var watchedArray = [];
              optionValues = optionValues || [];
              var optionValuesKeys = getOptionValuesKeys(optionValues);
              var optionValuesLength = optionValuesKeys.length;
              for (var index = 0; index < optionValuesLength; index++) {
                var key = (optionValues === optionValuesKeys) ? index : optionValuesKeys[index];
                var value = optionValues[key];
                var locals = getLocals(value, key);
                var selectValue = getTrackByValueFn(value, locals);
                watchedArray.push(selectValue);
                if (match[2] || match[1]) {
                  var label = displayFn(scope, locals);
                  watchedArray.push(label);
                }
                if (match[4]) {
                  var disableWhen = disableWhenFn(scope, locals);
                  watchedArray.push(disableWhen);
                }
              }
              return watchedArray;
            }),
            getOptions: function() {
              var optionItems = [];
              var selectValueMap = {};
              var optionValues = valuesFn(scope) || [];
              var optionValuesKeys = getOptionValuesKeys(optionValues);
              var optionValuesLength = optionValuesKeys.length;
              for (var index = 0; index < optionValuesLength; index++) {
                var key = (optionValues === optionValuesKeys) ? index : optionValuesKeys[index];
                var value = optionValues[key];
                var locals = getLocals(value, key);
                var viewValue = viewValueFn(scope, locals);
                var selectValue = getTrackByValueFn(viewValue, locals);
                var label = displayFn(scope, locals);
                var group = groupByFn(scope, locals);
                var disabled = disableWhenFn(scope, locals);
                var optionItem = new Option(selectValue, viewValue, label, group, disabled);
                optionItems.push(optionItem);
                selectValueMap[selectValue] = optionItem;
              }
              return {
                items: optionItems,
                selectValueMap: selectValueMap,
                getOptionFromViewValue: function(value) {
                  return selectValueMap[getTrackByValue(value)];
                },
                getViewValueFromOption: function(option) {
                  return trackBy ? angular.copy(option.viewValue) : option.viewValue;
                }
              };
            }
          };
        }
        var optionTemplate = window.document.createElement('option'),
            optGroupTemplate = window.document.createElement('optgroup');
        function ngOptionsPostLink(scope, selectElement, attr, ctrls) {
          var selectCtrl = ctrls[0];
          var ngModelCtrl = ctrls[1];
          var multiple = attr.multiple;
          var emptyOption;
          for (var i = 0,
              children = selectElement.children(),
              ii = children.length; i < ii; i++) {
            if (children[i].value === '') {
              emptyOption = children.eq(i);
              break;
            }
          }
          var providedEmptyOption = !!emptyOption;
          var unknownOption = jqLite(optionTemplate.cloneNode(false));
          unknownOption.val('?');
          var options;
          var ngOptions = parseOptionsExpression(attr.ngOptions, selectElement, scope);
          var listFragment = $document[0].createDocumentFragment();
          var renderEmptyOption = function() {
            if (!providedEmptyOption) {
              selectElement.prepend(emptyOption);
            }
            selectElement.val('');
            emptyOption.prop('selected', true);
            emptyOption.attr('selected', true);
          };
          var removeEmptyOption = function() {
            if (!providedEmptyOption) {
              emptyOption.remove();
            }
          };
          var renderUnknownOption = function() {
            selectElement.prepend(unknownOption);
            selectElement.val('?');
            unknownOption.prop('selected', true);
            unknownOption.attr('selected', true);
          };
          var removeUnknownOption = function() {
            unknownOption.remove();
          };
          if (!multiple) {
            selectCtrl.writeValue = function writeNgOptionsValue(value) {
              var option = options.getOptionFromViewValue(value);
              if (option) {
                if (selectElement[0].value !== option.selectValue) {
                  removeUnknownOption();
                  removeEmptyOption();
                  selectElement[0].value = option.selectValue;
                  option.element.selected = true;
                }
                option.element.setAttribute('selected', 'selected');
              } else {
                if (value === null || providedEmptyOption) {
                  removeUnknownOption();
                  renderEmptyOption();
                } else {
                  removeEmptyOption();
                  renderUnknownOption();
                }
              }
            };
            selectCtrl.readValue = function readNgOptionsValue() {
              var selectedOption = options.selectValueMap[selectElement.val()];
              if (selectedOption && !selectedOption.disabled) {
                removeEmptyOption();
                removeUnknownOption();
                return options.getViewValueFromOption(selectedOption);
              }
              return null;
            };
            if (ngOptions.trackBy) {
              scope.$watch(function() {
                return ngOptions.getTrackByValue(ngModelCtrl.$viewValue);
              }, function() {
                ngModelCtrl.$render();
              });
            }
          } else {
            ngModelCtrl.$isEmpty = function(value) {
              return !value || value.length === 0;
            };
            selectCtrl.writeValue = function writeNgOptionsMultiple(value) {
              options.items.forEach(function(option) {
                option.element.selected = false;
              });
              if (value) {
                value.forEach(function(item) {
                  var option = options.getOptionFromViewValue(item);
                  if (option)
                    option.element.selected = true;
                });
              }
            };
            selectCtrl.readValue = function readNgOptionsMultiple() {
              var selectedValues = selectElement.val() || [],
                  selections = [];
              forEach(selectedValues, function(value) {
                var option = options.selectValueMap[value];
                if (option && !option.disabled)
                  selections.push(options.getViewValueFromOption(option));
              });
              return selections;
            };
            if (ngOptions.trackBy) {
              scope.$watchCollection(function() {
                if (isArray(ngModelCtrl.$viewValue)) {
                  return ngModelCtrl.$viewValue.map(function(value) {
                    return ngOptions.getTrackByValue(value);
                  });
                }
              }, function() {
                ngModelCtrl.$render();
              });
            }
          }
          if (providedEmptyOption) {
            emptyOption.remove();
            $compile(emptyOption)(scope);
            emptyOption.removeClass('ng-scope');
          } else {
            emptyOption = jqLite(optionTemplate.cloneNode(false));
          }
          selectElement.empty();
          updateOptions();
          scope.$watchCollection(ngOptions.getWatchables, updateOptions);
          function addOptionElement(option, parent) {
            var optionElement = optionTemplate.cloneNode(false);
            parent.appendChild(optionElement);
            updateOptionElement(option, optionElement);
          }
          function updateOptionElement(option, element) {
            option.element = element;
            element.disabled = option.disabled;
            if (option.label !== element.label) {
              element.label = option.label;
              element.textContent = option.label;
            }
            if (option.value !== element.value)
              element.value = option.selectValue;
          }
          function updateOptions() {
            var previousValue = options && selectCtrl.readValue();
            if (options) {
              for (var i = options.items.length - 1; i >= 0; i--) {
                var option = options.items[i];
                if (option.group) {
                  jqLiteRemove(option.element.parentNode);
                } else {
                  jqLiteRemove(option.element);
                }
              }
            }
            options = ngOptions.getOptions();
            var groupElementMap = {};
            if (providedEmptyOption) {
              selectElement.prepend(emptyOption);
            }
            options.items.forEach(function addOption(option) {
              var groupElement;
              if (isDefined(option.group)) {
                groupElement = groupElementMap[option.group];
                if (!groupElement) {
                  groupElement = optGroupTemplate.cloneNode(false);
                  listFragment.appendChild(groupElement);
                  groupElement.label = option.group;
                  groupElementMap[option.group] = groupElement;
                }
                addOptionElement(option, groupElement);
              } else {
                addOptionElement(option, listFragment);
              }
            });
            selectElement[0].appendChild(listFragment);
            ngModelCtrl.$render();
            if (!ngModelCtrl.$isEmpty(previousValue)) {
              var nextValue = selectCtrl.readValue();
              var isNotPrimitive = ngOptions.trackBy || multiple;
              if (isNotPrimitive ? !equals(previousValue, nextValue) : previousValue !== nextValue) {
                ngModelCtrl.$setViewValue(nextValue);
                ngModelCtrl.$render();
              }
            }
          }
        }
        return {
          restrict: 'A',
          terminal: true,
          require: ['select', 'ngModel'],
          link: {
            pre: function ngOptionsPreLink(scope, selectElement, attr, ctrls) {
              ctrls[0].registerOption = noop;
            },
            post: ngOptionsPostLink
          }
        };
      }];
      var ngPluralizeDirective = ['$locale', '$interpolate', '$log', function($locale, $interpolate, $log) {
        var BRACE = /{}/g,
            IS_WHEN = /^when(Minus)?(.+)$/;
        return {link: function(scope, element, attr) {
            var numberExp = attr.count,
                whenExp = attr.$attr.when && element.attr(attr.$attr.when),
                offset = attr.offset || 0,
                whens = scope.$eval(whenExp) || {},
                whensExpFns = {},
                startSymbol = $interpolate.startSymbol(),
                endSymbol = $interpolate.endSymbol(),
                braceReplacement = startSymbol + numberExp + '-' + offset + endSymbol,
                watchRemover = angular.noop,
                lastCount;
            forEach(attr, function(expression, attributeName) {
              var tmpMatch = IS_WHEN.exec(attributeName);
              if (tmpMatch) {
                var whenKey = (tmpMatch[1] ? '-' : '') + lowercase(tmpMatch[2]);
                whens[whenKey] = element.attr(attr.$attr[attributeName]);
              }
            });
            forEach(whens, function(expression, key) {
              whensExpFns[key] = $interpolate(expression.replace(BRACE, braceReplacement));
            });
            scope.$watch(numberExp, function ngPluralizeWatchAction(newVal) {
              var count = parseFloat(newVal);
              var countIsNaN = isNaN(count);
              if (!countIsNaN && !(count in whens)) {
                count = $locale.pluralCat(count - offset);
              }
              if ((count !== lastCount) && !(countIsNaN && isNumber(lastCount) && isNaN(lastCount))) {
                watchRemover();
                var whenExpFn = whensExpFns[count];
                if (isUndefined(whenExpFn)) {
                  if (newVal != null) {
                    $log.debug("ngPluralize: no rule defined for '" + count + "' in " + whenExp);
                  }
                  watchRemover = noop;
                  updateElementText();
                } else {
                  watchRemover = scope.$watch(whenExpFn, updateElementText);
                }
                lastCount = count;
              }
            });
            function updateElementText(newText) {
              element.text(newText || '');
            }
          }};
      }];
      var ngRepeatDirective = ['$parse', '$animate', '$compile', function($parse, $animate, $compile) {
        var NG_REMOVED = '$$NG_REMOVED';
        var ngRepeatMinErr = minErr('ngRepeat');
        var updateScope = function(scope, index, valueIdentifier, value, keyIdentifier, key, arrayLength) {
          scope[valueIdentifier] = value;
          if (keyIdentifier)
            scope[keyIdentifier] = key;
          scope.$index = index;
          scope.$first = (index === 0);
          scope.$last = (index === (arrayLength - 1));
          scope.$middle = !(scope.$first || scope.$last);
          scope.$odd = !(scope.$even = (index & 1) === 0);
        };
        var getBlockStart = function(block) {
          return block.clone[0];
        };
        var getBlockEnd = function(block) {
          return block.clone[block.clone.length - 1];
        };
        return {
          restrict: 'A',
          multiElement: true,
          transclude: 'element',
          priority: 1000,
          terminal: true,
          $$tlb: true,
          compile: function ngRepeatCompile($element, $attr) {
            var expression = $attr.ngRepeat;
            var ngRepeatEndComment = $compile.$$createComment('end ngRepeat', expression);
            var match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);
            if (!match) {
              throw ngRepeatMinErr('iexp', "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.", expression);
            }
            var lhs = match[1];
            var rhs = match[2];
            var aliasAs = match[3];
            var trackByExp = match[4];
            match = lhs.match(/^(?:(\s*[\$\w]+)|\(\s*([\$\w]+)\s*,\s*([\$\w]+)\s*\))$/);
            if (!match) {
              throw ngRepeatMinErr('iidexp', "'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.", lhs);
            }
            var valueIdentifier = match[3] || match[1];
            var keyIdentifier = match[2];
            if (aliasAs && (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(aliasAs) || /^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(aliasAs))) {
              throw ngRepeatMinErr('badident', "alias '{0}' is invalid --- must be a valid JS identifier which is not a reserved name.", aliasAs);
            }
            var trackByExpGetter,
                trackByIdExpFn,
                trackByIdArrayFn,
                trackByIdObjFn;
            var hashFnLocals = {$id: hashKey};
            if (trackByExp) {
              trackByExpGetter = $parse(trackByExp);
            } else {
              trackByIdArrayFn = function(key, value) {
                return hashKey(value);
              };
              trackByIdObjFn = function(key) {
                return key;
              };
            }
            return function ngRepeatLink($scope, $element, $attr, ctrl, $transclude) {
              if (trackByExpGetter) {
                trackByIdExpFn = function(key, value, index) {
                  if (keyIdentifier)
                    hashFnLocals[keyIdentifier] = key;
                  hashFnLocals[valueIdentifier] = value;
                  hashFnLocals.$index = index;
                  return trackByExpGetter($scope, hashFnLocals);
                };
              }
              var lastBlockMap = createMap();
              $scope.$watchCollection(rhs, function ngRepeatAction(collection) {
                var index,
                    length,
                    previousNode = $element[0],
                    nextNode,
                    nextBlockMap = createMap(),
                    collectionLength,
                    key,
                    value,
                    trackById,
                    trackByIdFn,
                    collectionKeys,
                    block,
                    nextBlockOrder,
                    elementsToRemove;
                if (aliasAs) {
                  $scope[aliasAs] = collection;
                }
                if (isArrayLike(collection)) {
                  collectionKeys = collection;
                  trackByIdFn = trackByIdExpFn || trackByIdArrayFn;
                } else {
                  trackByIdFn = trackByIdExpFn || trackByIdObjFn;
                  collectionKeys = [];
                  for (var itemKey in collection) {
                    if (hasOwnProperty.call(collection, itemKey) && itemKey.charAt(0) !== '$') {
                      collectionKeys.push(itemKey);
                    }
                  }
                }
                collectionLength = collectionKeys.length;
                nextBlockOrder = new Array(collectionLength);
                for (index = 0; index < collectionLength; index++) {
                  key = (collection === collectionKeys) ? index : collectionKeys[index];
                  value = collection[key];
                  trackById = trackByIdFn(key, value, index);
                  if (lastBlockMap[trackById]) {
                    block = lastBlockMap[trackById];
                    delete lastBlockMap[trackById];
                    nextBlockMap[trackById] = block;
                    nextBlockOrder[index] = block;
                  } else if (nextBlockMap[trackById]) {
                    forEach(nextBlockOrder, function(block) {
                      if (block && block.scope)
                        lastBlockMap[block.id] = block;
                    });
                    throw ngRepeatMinErr('dupes', "Duplicates in a repeater are not allowed. Use 'track by' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}, Duplicate value: {2}", expression, trackById, value);
                  } else {
                    nextBlockOrder[index] = {
                      id: trackById,
                      scope: undefined,
                      clone: undefined
                    };
                    nextBlockMap[trackById] = true;
                  }
                }
                for (var blockKey in lastBlockMap) {
                  block = lastBlockMap[blockKey];
                  elementsToRemove = getBlockNodes(block.clone);
                  $animate.leave(elementsToRemove);
                  if (elementsToRemove[0].parentNode) {
                    for (index = 0, length = elementsToRemove.length; index < length; index++) {
                      elementsToRemove[index][NG_REMOVED] = true;
                    }
                  }
                  block.scope.$destroy();
                }
                for (index = 0; index < collectionLength; index++) {
                  key = (collection === collectionKeys) ? index : collectionKeys[index];
                  value = collection[key];
                  block = nextBlockOrder[index];
                  if (block.scope) {
                    nextNode = previousNode;
                    do {
                      nextNode = nextNode.nextSibling;
                    } while (nextNode && nextNode[NG_REMOVED]);
                    if (getBlockStart(block) != nextNode) {
                      $animate.move(getBlockNodes(block.clone), null, previousNode);
                    }
                    previousNode = getBlockEnd(block);
                    updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                  } else {
                    $transclude(function ngRepeatTransclude(clone, scope) {
                      block.scope = scope;
                      var endNode = ngRepeatEndComment.cloneNode(false);
                      clone[clone.length++] = endNode;
                      $animate.enter(clone, null, previousNode);
                      previousNode = endNode;
                      block.clone = clone;
                      nextBlockMap[block.id] = block;
                      updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                    });
                  }
                }
                lastBlockMap = nextBlockMap;
              });
            };
          }
        };
      }];
      var NG_HIDE_CLASS = 'ng-hide';
      var NG_HIDE_IN_PROGRESS_CLASS = 'ng-hide-animate';
      var ngShowDirective = ['$animate', function($animate) {
        return {
          restrict: 'A',
          multiElement: true,
          link: function(scope, element, attr) {
            scope.$watch(attr.ngShow, function ngShowWatchAction(value) {
              $animate[value ? 'removeClass' : 'addClass'](element, NG_HIDE_CLASS, {tempClasses: NG_HIDE_IN_PROGRESS_CLASS});
            });
          }
        };
      }];
      var ngHideDirective = ['$animate', function($animate) {
        return {
          restrict: 'A',
          multiElement: true,
          link: function(scope, element, attr) {
            scope.$watch(attr.ngHide, function ngHideWatchAction(value) {
              $animate[value ? 'addClass' : 'removeClass'](element, NG_HIDE_CLASS, {tempClasses: NG_HIDE_IN_PROGRESS_CLASS});
            });
          }
        };
      }];
      var ngStyleDirective = ngDirective(function(scope, element, attr) {
        scope.$watch(attr.ngStyle, function ngStyleWatchAction(newStyles, oldStyles) {
          if (oldStyles && (newStyles !== oldStyles)) {
            forEach(oldStyles, function(val, style) {
              element.css(style, '');
            });
          }
          if (newStyles)
            element.css(newStyles);
        }, true);
      });
      var ngSwitchDirective = ['$animate', '$compile', function($animate, $compile) {
        return {
          require: 'ngSwitch',
          controller: ['$scope', function ngSwitchController() {
            this.cases = {};
          }],
          link: function(scope, element, attr, ngSwitchController) {
            var watchExpr = attr.ngSwitch || attr.on,
                selectedTranscludes = [],
                selectedElements = [],
                previousLeaveAnimations = [],
                selectedScopes = [];
            var spliceFactory = function(array, index) {
              return function() {
                array.splice(index, 1);
              };
            };
            scope.$watch(watchExpr, function ngSwitchWatchAction(value) {
              var i,
                  ii;
              for (i = 0, ii = previousLeaveAnimations.length; i < ii; ++i) {
                $animate.cancel(previousLeaveAnimations[i]);
              }
              previousLeaveAnimations.length = 0;
              for (i = 0, ii = selectedScopes.length; i < ii; ++i) {
                var selected = getBlockNodes(selectedElements[i].clone);
                selectedScopes[i].$destroy();
                var promise = previousLeaveAnimations[i] = $animate.leave(selected);
                promise.then(spliceFactory(previousLeaveAnimations, i));
              }
              selectedElements.length = 0;
              selectedScopes.length = 0;
              if ((selectedTranscludes = ngSwitchController.cases['!' + value] || ngSwitchController.cases['?'])) {
                forEach(selectedTranscludes, function(selectedTransclude) {
                  selectedTransclude.transclude(function(caseElement, selectedScope) {
                    selectedScopes.push(selectedScope);
                    var anchor = selectedTransclude.element;
                    caseElement[caseElement.length++] = $compile.$$createComment('end ngSwitchWhen');
                    var block = {clone: caseElement};
                    selectedElements.push(block);
                    $animate.enter(caseElement, anchor.parent(), anchor);
                  });
                });
              }
            });
          }
        };
      }];
      var ngSwitchWhenDirective = ngDirective({
        transclude: 'element',
        priority: 1200,
        require: '^ngSwitch',
        multiElement: true,
        link: function(scope, element, attrs, ctrl, $transclude) {
          ctrl.cases['!' + attrs.ngSwitchWhen] = (ctrl.cases['!' + attrs.ngSwitchWhen] || []);
          ctrl.cases['!' + attrs.ngSwitchWhen].push({
            transclude: $transclude,
            element: element
          });
        }
      });
      var ngSwitchDefaultDirective = ngDirective({
        transclude: 'element',
        priority: 1200,
        require: '^ngSwitch',
        multiElement: true,
        link: function(scope, element, attr, ctrl, $transclude) {
          ctrl.cases['?'] = (ctrl.cases['?'] || []);
          ctrl.cases['?'].push({
            transclude: $transclude,
            element: element
          });
        }
      });
      var ngTranscludeMinErr = minErr('ngTransclude');
      var ngTranscludeDirective = ngDirective({
        restrict: 'EAC',
        link: function($scope, $element, $attrs, controller, $transclude) {
          if ($attrs.ngTransclude === $attrs.$attr.ngTransclude) {
            $attrs.ngTransclude = '';
          }
          function ngTranscludeCloneAttachFn(clone) {
            if (clone.length) {
              $element.empty();
              $element.append(clone);
            }
          }
          if (!$transclude) {
            throw ngTranscludeMinErr('orphan', 'Illegal use of ngTransclude directive in the template! ' + 'No parent directive that requires a transclusion found. ' + 'Element: {0}', startingTag($element));
          }
          var slotName = $attrs.ngTransclude || $attrs.ngTranscludeSlot;
          $transclude(ngTranscludeCloneAttachFn, null, slotName);
        }
      });
      var scriptDirective = ['$templateCache', function($templateCache) {
        return {
          restrict: 'E',
          terminal: true,
          compile: function(element, attr) {
            if (attr.type == 'text/ng-template') {
              var templateUrl = attr.id,
                  text = element[0].text;
              $templateCache.put(templateUrl, text);
            }
          }
        };
      }];
      var noopNgModelController = {
        $setViewValue: noop,
        $render: noop
      };
      function chromeHack(optionElement) {
        if (optionElement[0].hasAttribute('selected')) {
          optionElement[0].selected = true;
        }
      }
      var SelectController = ['$element', '$scope', function($element, $scope) {
        var self = this,
            optionsMap = new HashMap();
        self.ngModelCtrl = noopNgModelController;
        self.unknownOption = jqLite(window.document.createElement('option'));
        self.renderUnknownOption = function(val) {
          var unknownVal = '? ' + hashKey(val) + ' ?';
          self.unknownOption.val(unknownVal);
          $element.prepend(self.unknownOption);
          $element.val(unknownVal);
        };
        $scope.$on('$destroy', function() {
          self.renderUnknownOption = noop;
        });
        self.removeUnknownOption = function() {
          if (self.unknownOption.parent())
            self.unknownOption.remove();
        };
        self.readValue = function readSingleValue() {
          self.removeUnknownOption();
          return $element.val();
        };
        self.writeValue = function writeSingleValue(value) {
          if (self.hasOption(value)) {
            self.removeUnknownOption();
            $element.val(value);
            if (value === '')
              self.emptyOption.prop('selected', true);
          } else {
            if (value == null && self.emptyOption) {
              self.removeUnknownOption();
              $element.val('');
            } else {
              self.renderUnknownOption(value);
            }
          }
        };
        self.addOption = function(value, element) {
          if (element[0].nodeType === NODE_TYPE_COMMENT)
            return;
          assertNotHasOwnProperty(value, '"option value"');
          if (value === '') {
            self.emptyOption = element;
          }
          var count = optionsMap.get(value) || 0;
          optionsMap.put(value, count + 1);
          self.ngModelCtrl.$render();
          chromeHack(element);
        };
        self.removeOption = function(value) {
          var count = optionsMap.get(value);
          if (count) {
            if (count === 1) {
              optionsMap.remove(value);
              if (value === '') {
                self.emptyOption = undefined;
              }
            } else {
              optionsMap.put(value, count - 1);
            }
          }
        };
        self.hasOption = function(value) {
          return !!optionsMap.get(value);
        };
        self.registerOption = function(optionScope, optionElement, optionAttrs, interpolateValueFn, interpolateTextFn) {
          if (interpolateValueFn) {
            var oldVal;
            optionAttrs.$observe('value', function valueAttributeObserveAction(newVal) {
              if (isDefined(oldVal)) {
                self.removeOption(oldVal);
              }
              oldVal = newVal;
              self.addOption(newVal, optionElement);
            });
          } else if (interpolateTextFn) {
            optionScope.$watch(interpolateTextFn, function interpolateWatchAction(newVal, oldVal) {
              optionAttrs.$set('value', newVal);
              if (oldVal !== newVal) {
                self.removeOption(oldVal);
              }
              self.addOption(newVal, optionElement);
            });
          } else {
            self.addOption(optionAttrs.value, optionElement);
          }
          optionElement.on('$destroy', function() {
            self.removeOption(optionAttrs.value);
            self.ngModelCtrl.$render();
          });
        };
      }];
      var selectDirective = function() {
        return {
          restrict: 'E',
          require: ['select', '?ngModel'],
          controller: SelectController,
          priority: 1,
          link: {
            pre: selectPreLink,
            post: selectPostLink
          }
        };
        function selectPreLink(scope, element, attr, ctrls) {
          var ngModelCtrl = ctrls[1];
          if (!ngModelCtrl)
            return;
          var selectCtrl = ctrls[0];
          selectCtrl.ngModelCtrl = ngModelCtrl;
          element.on('change', function() {
            scope.$apply(function() {
              ngModelCtrl.$setViewValue(selectCtrl.readValue());
            });
          });
          if (attr.multiple) {
            selectCtrl.readValue = function readMultipleValue() {
              var array = [];
              forEach(element.find('option'), function(option) {
                if (option.selected) {
                  array.push(option.value);
                }
              });
              return array;
            };
            selectCtrl.writeValue = function writeMultipleValue(value) {
              var items = new HashMap(value);
              forEach(element.find('option'), function(option) {
                option.selected = isDefined(items.get(option.value));
              });
            };
            var lastView,
                lastViewRef = NaN;
            scope.$watch(function selectMultipleWatch() {
              if (lastViewRef === ngModelCtrl.$viewValue && !equals(lastView, ngModelCtrl.$viewValue)) {
                lastView = shallowCopy(ngModelCtrl.$viewValue);
                ngModelCtrl.$render();
              }
              lastViewRef = ngModelCtrl.$viewValue;
            });
            ngModelCtrl.$isEmpty = function(value) {
              return !value || value.length === 0;
            };
          }
        }
        function selectPostLink(scope, element, attrs, ctrls) {
          var ngModelCtrl = ctrls[1];
          if (!ngModelCtrl)
            return;
          var selectCtrl = ctrls[0];
          ngModelCtrl.$render = function() {
            selectCtrl.writeValue(ngModelCtrl.$viewValue);
          };
        }
      };
      var optionDirective = ['$interpolate', function($interpolate) {
        return {
          restrict: 'E',
          priority: 100,
          compile: function(element, attr) {
            if (isDefined(attr.value)) {
              var interpolateValueFn = $interpolate(attr.value, true);
            } else {
              var interpolateTextFn = $interpolate(element.text(), true);
              if (!interpolateTextFn) {
                attr.$set('value', element.text());
              }
            }
            return function(scope, element, attr) {
              var selectCtrlName = '$selectController',
                  parent = element.parent(),
                  selectCtrl = parent.data(selectCtrlName) || parent.parent().data(selectCtrlName);
              if (selectCtrl) {
                selectCtrl.registerOption(scope, element, attr, interpolateValueFn, interpolateTextFn);
              }
            };
          }
        };
      }];
      var styleDirective = valueFn({
        restrict: 'E',
        terminal: false
      });
      var requiredDirective = function() {
        return {
          restrict: 'A',
          require: '?ngModel',
          link: function(scope, elm, attr, ctrl) {
            if (!ctrl)
              return;
            attr.required = true;
            ctrl.$validators.required = function(modelValue, viewValue) {
              return !attr.required || !ctrl.$isEmpty(viewValue);
            };
            attr.$observe('required', function() {
              ctrl.$validate();
            });
          }
        };
      };
      var patternDirective = function() {
        return {
          restrict: 'A',
          require: '?ngModel',
          link: function(scope, elm, attr, ctrl) {
            if (!ctrl)
              return;
            var regexp,
                patternExp = attr.ngPattern || attr.pattern;
            attr.$observe('pattern', function(regex) {
              if (isString(regex) && regex.length > 0) {
                regex = new RegExp('^' + regex + '$');
              }
              if (regex && !regex.test) {
                throw minErr('ngPattern')('noregexp', 'Expected {0} to be a RegExp but was {1}. Element: {2}', patternExp, regex, startingTag(elm));
              }
              regexp = regex || undefined;
              ctrl.$validate();
            });
            ctrl.$validators.pattern = function(modelValue, viewValue) {
              return ctrl.$isEmpty(viewValue) || isUndefined(regexp) || regexp.test(viewValue);
            };
          }
        };
      };
      var maxlengthDirective = function() {
        return {
          restrict: 'A',
          require: '?ngModel',
          link: function(scope, elm, attr, ctrl) {
            if (!ctrl)
              return;
            var maxlength = -1;
            attr.$observe('maxlength', function(value) {
              var intVal = toInt(value);
              maxlength = isNaN(intVal) ? -1 : intVal;
              ctrl.$validate();
            });
            ctrl.$validators.maxlength = function(modelValue, viewValue) {
              return (maxlength < 0) || ctrl.$isEmpty(viewValue) || (viewValue.length <= maxlength);
            };
          }
        };
      };
      var minlengthDirective = function() {
        return {
          restrict: 'A',
          require: '?ngModel',
          link: function(scope, elm, attr, ctrl) {
            if (!ctrl)
              return;
            var minlength = 0;
            attr.$observe('minlength', function(value) {
              minlength = toInt(value) || 0;
              ctrl.$validate();
            });
            ctrl.$validators.minlength = function(modelValue, viewValue) {
              return ctrl.$isEmpty(viewValue) || viewValue.length >= minlength;
            };
          }
        };
      };
      if (window.angular.bootstrap) {
        if (window.console) {
          console.log('WARNING: Tried to load angular more than once.');
        }
        return;
      }
      bindJQuery();
      publishExternalAPI(angular);
      angular.module("ngLocale", [], ["$provide", function($provide) {
        var PLURAL_CATEGORY = {
          ZERO: "zero",
          ONE: "one",
          TWO: "two",
          FEW: "few",
          MANY: "many",
          OTHER: "other"
        };
        function getDecimals(n) {
          n = n + '';
          var i = n.indexOf('.');
          return (i == -1) ? 0 : n.length - i - 1;
        }
        function getVF(n, opt_precision) {
          var v = opt_precision;
          if (undefined === v) {
            v = Math.min(getDecimals(n), 3);
          }
          var base = Math.pow(10, v);
          var f = ((n * base) | 0) % base;
          return {
            v: v,
            f: f
          };
        }
        $provide.value("$locale", {
          "DATETIME_FORMATS": {
            "AMPMS": ["AM", "PM"],
            "DAY": ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
            "ERANAMES": ["Before Christ", "Anno Domini"],
            "ERAS": ["BC", "AD"],
            "FIRSTDAYOFWEEK": 6,
            "MONTH": ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
            "SHORTDAY": ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            "SHORTMONTH": ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
            "STANDALONEMONTH": ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
            "WEEKENDRANGE": [5, 6],
            "fullDate": "EEEE, MMMM d, y",
            "longDate": "MMMM d, y",
            "medium": "MMM d, y h:mm:ss a",
            "mediumDate": "MMM d, y",
            "mediumTime": "h:mm:ss a",
            "short": "M/d/yy h:mm a",
            "shortDate": "M/d/yy",
            "shortTime": "h:mm a"
          },
          "NUMBER_FORMATS": {
            "CURRENCY_SYM": "$",
            "DECIMAL_SEP": ".",
            "GROUP_SEP": ",",
            "PATTERNS": [{
              "gSize": 3,
              "lgSize": 3,
              "maxFrac": 3,
              "minFrac": 0,
              "minInt": 1,
              "negPre": "-",
              "negSuf": "",
              "posPre": "",
              "posSuf": ""
            }, {
              "gSize": 3,
              "lgSize": 3,
              "maxFrac": 2,
              "minFrac": 2,
              "minInt": 1,
              "negPre": "-\u00a4",
              "negSuf": "",
              "posPre": "\u00a4",
              "posSuf": ""
            }]
          },
          "id": "en-us",
          "localeID": "en_US",
          "pluralCat": function(n, opt_precision) {
            var i = n | 0;
            var vf = getVF(n, opt_precision);
            if (i == 1 && vf.v == 0) {
              return PLURAL_CATEGORY.ONE;
            }
            return PLURAL_CATEGORY.OTHER;
          }
        });
      }]);
      jqLite(window.document).ready(function() {
        angularInit(window.document, bootstrap);
      });
    })(window);
    !window.angular.$$csp().noInlineStyle && window.angular.element(document.head).prepend('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\:form{display:block;}.ng-animate-shim{visibility:hidden;}.ng-anchor{position:absolute;}</style>');
  })();
  return _retrieveGlobal();
});

$__System.registerDynamic("5", ["7"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('7');
  return module.exports;
});

$__System.registerDynamic("8", ["5"], false, function($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);
  (function() {
    "format global";
    "deps angular";
    (function(window, angular) {
      'use strict';
      var ngAriaModule = angular.module('ngAria', ['ng']).provider('$aria', $AriaProvider);
      var nodeBlackList = ['BUTTON', 'A', 'INPUT', 'TEXTAREA', 'SELECT', 'DETAILS', 'SUMMARY'];
      var isNodeOneOf = function(elem, nodeTypeArray) {
        if (nodeTypeArray.indexOf(elem[0].nodeName) !== -1) {
          return true;
        }
      };
      function $AriaProvider() {
        var config = {
          ariaHidden: true,
          ariaChecked: true,
          ariaReadonly: true,
          ariaDisabled: true,
          ariaRequired: true,
          ariaInvalid: true,
          ariaValue: true,
          tabindex: true,
          bindKeypress: true,
          bindRoleForClick: true
        };
        this.config = function(newConfig) {
          config = angular.extend(config, newConfig);
        };
        function watchExpr(attrName, ariaAttr, nodeBlackList, negate) {
          return function(scope, elem, attr) {
            var ariaCamelName = attr.$normalize(ariaAttr);
            if (config[ariaCamelName] && !isNodeOneOf(elem, nodeBlackList) && !attr[ariaCamelName]) {
              scope.$watch(attr[attrName], function(boolVal) {
                boolVal = negate ? !boolVal : !!boolVal;
                elem.attr(ariaAttr, boolVal);
              });
            }
          };
        }
        this.$get = function() {
          return {
            config: function(key) {
              return config[key];
            },
            $$watchExpr: watchExpr
          };
        };
      }
      ngAriaModule.directive('ngShow', ['$aria', function($aria) {
        return $aria.$$watchExpr('ngShow', 'aria-hidden', [], true);
      }]).directive('ngHide', ['$aria', function($aria) {
        return $aria.$$watchExpr('ngHide', 'aria-hidden', [], false);
      }]).directive('ngValue', ['$aria', function($aria) {
        return $aria.$$watchExpr('ngValue', 'aria-checked', nodeBlackList, false);
      }]).directive('ngChecked', ['$aria', function($aria) {
        return $aria.$$watchExpr('ngChecked', 'aria-checked', nodeBlackList, false);
      }]).directive('ngReadonly', ['$aria', function($aria) {
        return $aria.$$watchExpr('ngReadonly', 'aria-readonly', nodeBlackList, false);
      }]).directive('ngRequired', ['$aria', function($aria) {
        return $aria.$$watchExpr('ngRequired', 'aria-required', nodeBlackList, false);
      }]).directive('ngModel', ['$aria', function($aria) {
        function shouldAttachAttr(attr, normalizedAttr, elem, allowBlacklistEls) {
          return $aria.config(normalizedAttr) && !elem.attr(attr) && (allowBlacklistEls || !isNodeOneOf(elem, nodeBlackList));
        }
        function shouldAttachRole(role, elem) {
          return !elem.attr('role') && (elem.attr('type') === role) && (elem[0].nodeName !== 'INPUT');
        }
        function getShape(attr, elem) {
          var type = attr.type,
              role = attr.role;
          return ((type || role) === 'checkbox' || role === 'menuitemcheckbox') ? 'checkbox' : ((type || role) === 'radio' || role === 'menuitemradio') ? 'radio' : (type === 'range' || role === 'progressbar' || role === 'slider') ? 'range' : '';
        }
        return {
          restrict: 'A',
          require: 'ngModel',
          priority: 200,
          compile: function(elem, attr) {
            var shape = getShape(attr, elem);
            return {
              pre: function(scope, elem, attr, ngModel) {
                if (shape === 'checkbox') {
                  ngModel.$isEmpty = function(value) {
                    return value === false;
                  };
                }
              },
              post: function(scope, elem, attr, ngModel) {
                var needsTabIndex = shouldAttachAttr('tabindex', 'tabindex', elem, false);
                function ngAriaWatchModelValue() {
                  return ngModel.$modelValue;
                }
                function getRadioReaction(newVal) {
                  var boolVal = (attr.value == ngModel.$viewValue);
                  elem.attr('aria-checked', boolVal);
                }
                function getCheckboxReaction() {
                  elem.attr('aria-checked', !ngModel.$isEmpty(ngModel.$viewValue));
                }
                switch (shape) {
                  case 'radio':
                  case 'checkbox':
                    if (shouldAttachRole(shape, elem)) {
                      elem.attr('role', shape);
                    }
                    if (shouldAttachAttr('aria-checked', 'ariaChecked', elem, false)) {
                      scope.$watch(ngAriaWatchModelValue, shape === 'radio' ? getRadioReaction : getCheckboxReaction);
                    }
                    if (needsTabIndex) {
                      elem.attr('tabindex', 0);
                    }
                    break;
                  case 'range':
                    if (shouldAttachRole(shape, elem)) {
                      elem.attr('role', 'slider');
                    }
                    if ($aria.config('ariaValue')) {
                      var needsAriaValuemin = !elem.attr('aria-valuemin') && (attr.hasOwnProperty('min') || attr.hasOwnProperty('ngMin'));
                      var needsAriaValuemax = !elem.attr('aria-valuemax') && (attr.hasOwnProperty('max') || attr.hasOwnProperty('ngMax'));
                      var needsAriaValuenow = !elem.attr('aria-valuenow');
                      if (needsAriaValuemin) {
                        attr.$observe('min', function ngAriaValueMinReaction(newVal) {
                          elem.attr('aria-valuemin', newVal);
                        });
                      }
                      if (needsAriaValuemax) {
                        attr.$observe('max', function ngAriaValueMinReaction(newVal) {
                          elem.attr('aria-valuemax', newVal);
                        });
                      }
                      if (needsAriaValuenow) {
                        scope.$watch(ngAriaWatchModelValue, function ngAriaValueNowReaction(newVal) {
                          elem.attr('aria-valuenow', newVal);
                        });
                      }
                    }
                    if (needsTabIndex) {
                      elem.attr('tabindex', 0);
                    }
                    break;
                }
                if (!attr.hasOwnProperty('ngRequired') && ngModel.$validators.required && shouldAttachAttr('aria-required', 'ariaRequired', elem, false)) {
                  attr.$observe('required', function() {
                    elem.attr('aria-required', !!attr['required']);
                  });
                }
                if (shouldAttachAttr('aria-invalid', 'ariaInvalid', elem, true)) {
                  scope.$watch(function ngAriaInvalidWatch() {
                    return ngModel.$invalid;
                  }, function ngAriaInvalidReaction(newVal) {
                    elem.attr('aria-invalid', !!newVal);
                  });
                }
              }
            };
          }
        };
      }]).directive('ngDisabled', ['$aria', function($aria) {
        return $aria.$$watchExpr('ngDisabled', 'aria-disabled', nodeBlackList, false);
      }]).directive('ngMessages', function() {
        return {
          restrict: 'A',
          require: '?ngMessages',
          link: function(scope, elem, attr, ngMessages) {
            if (!elem.attr('aria-live')) {
              elem.attr('aria-live', 'assertive');
            }
          }
        };
      }).directive('ngClick', ['$aria', '$parse', function($aria, $parse) {
        return {
          restrict: 'A',
          compile: function(elem, attr) {
            var fn = $parse(attr.ngClick, null, true);
            return function(scope, elem, attr) {
              if (!isNodeOneOf(elem, nodeBlackList)) {
                if ($aria.config('bindRoleForClick') && !elem.attr('role')) {
                  elem.attr('role', 'button');
                }
                if ($aria.config('tabindex') && !elem.attr('tabindex')) {
                  elem.attr('tabindex', 0);
                }
                if ($aria.config('bindKeypress') && !attr.ngKeypress) {
                  elem.on('keypress', function(event) {
                    var keyCode = event.which || event.keyCode;
                    if (keyCode === 32 || keyCode === 13) {
                      scope.$apply(callback);
                    }
                    function callback() {
                      fn(scope, {$event: event});
                    }
                  });
                }
              }
            };
          }
        };
      }]).directive('ngDblclick', ['$aria', function($aria) {
        return function(scope, elem, attr) {
          if ($aria.config('tabindex') && !elem.attr('tabindex') && !isNodeOneOf(elem, nodeBlackList)) {
            elem.attr('tabindex', 0);
          }
        };
      }]);
    })(window, window.angular);
  })();
  return _retrieveGlobal();
});

$__System.registerDynamic("9", ["8"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('8');
  return module.exports;
});

$__System.registerDynamic("a", [], false, function($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);
  (function() {
    "format global";
    (function(window, angular, undefined) {
      "use strict";
      (function() {
        "use strict";
        angular.module('ngMaterial', ["ng", "ngAnimate", "ngAria", "material.core", "material.core.gestures", "material.core.layout", "material.core.theming.palette", "material.core.theming", "material.core.animate", "material.components.autocomplete", "material.components.backdrop", "material.components.bottomSheet", "material.components.card", "material.components.button", "material.components.checkbox", "material.components.chips", "material.components.colors", "material.components.content", "material.components.datepicker", "material.components.dialog", "material.components.divider", "material.components.fabActions", "material.components.fabShared", "material.components.fabSpeedDial", "material.components.fabToolbar", "material.components.gridList", "material.components.icon", "material.components.input", "material.components.list", "material.components.menu", "material.components.menuBar", "material.components.navBar", "material.components.panel", "material.components.progressCircular", "material.components.progressLinear", "material.components.radioButton", "material.components.select", "material.components.showHide", "material.components.sidenav", "material.components.slider", "material.components.sticky", "material.components.subheader", "material.components.swipe", "material.components.switch", "material.components.tabs", "material.components.toast", "material.components.toolbar", "material.components.tooltip", "material.components.virtualRepeat", "material.components.whiteframe"]);
      })();
      (function() {
        "use strict";
        angular.module('material.core', ['ngAnimate', 'material.core.animate', 'material.core.layout', 'material.core.gestures', 'material.core.theming']).config(MdCoreConfigure).run(DetectNgTouch);
        function DetectNgTouch($log, $injector) {
          if ($injector.has('$swipe')) {
            var msg = "" + "You are using the ngTouch module. \n" + "Angular Material already has mobile click, tap, and swipe support... \n" + "ngTouch is not supported with Angular Material!";
            $log.warn(msg);
          }
        }
        DetectNgTouch.$inject = ["$log", "$injector"];
        function MdCoreConfigure($provide, $mdThemingProvider) {
          $provide.decorator('$$rAF', ["$delegate", rAFDecorator]);
          $mdThemingProvider.theme('default').primaryPalette('indigo').accentPalette('pink').warnPalette('deep-orange').backgroundPalette('grey');
        }
        MdCoreConfigure.$inject = ["$provide", "$mdThemingProvider"];
        function rAFDecorator($delegate) {
          $delegate.throttle = function(cb) {
            var queuedArgs,
                alreadyQueued,
                queueCb,
                context;
            return function debounced() {
              queuedArgs = arguments;
              context = this;
              queueCb = cb;
              if (!alreadyQueued) {
                alreadyQueued = true;
                $delegate(function() {
                  queueCb.apply(context, Array.prototype.slice.call(queuedArgs));
                  alreadyQueued = false;
                });
              }
            };
          };
          return $delegate;
        }
        rAFDecorator.$inject = ["$delegate"];
      })();
      (function() {
        "use strict";
        angular.module('material.core').directive('mdAutofocus', MdAutofocusDirective).directive('mdAutoFocus', MdAutofocusDirective).directive('mdSidenavFocus', MdAutofocusDirective);
        function MdAutofocusDirective() {
          return {
            restrict: 'A',
            link: postLink
          };
        }
        function postLink(scope, element, attrs) {
          var attr = attrs.mdAutoFocus || attrs.mdAutofocus || attrs.mdSidenavFocus;
          scope.$watch(attr, function(canAutofocus) {
            element.toggleClass('_md-autofocus', canAutofocus);
          });
        }
      })();
      (function() {
        "use strict";
        angular.module('material.core').factory('$mdColorUtil', ColorUtilFactory);
        function ColorUtilFactory() {
          function hexToRgba(color) {
            var hex = color[0] === '#' ? color.substr(1) : color,
                dig = hex.length / 3,
                red = hex.substr(0, dig),
                green = hex.substr(dig, dig),
                blue = hex.substr(dig * 2);
            if (dig === 1) {
              red += red;
              green += green;
              blue += blue;
            }
            return 'rgba(' + parseInt(red, 16) + ',' + parseInt(green, 16) + ',' + parseInt(blue, 16) + ',0.1)';
          }
          function rgbaToHex(color) {
            color = color.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i);
            var hex = (color && color.length === 4) ? "#" + ("0" + parseInt(color[1], 10).toString(16)).slice(-2) + ("0" + parseInt(color[2], 10).toString(16)).slice(-2) + ("0" + parseInt(color[3], 10).toString(16)).slice(-2) : '';
            return hex.toUpperCase();
          }
          function rgbToRgba(color) {
            return color.replace(')', ', 0.1)').replace('(', 'a(');
          }
          function rgbaToRgb(color) {
            return color ? color.replace('rgba', 'rgb').replace(/,[^\),]+\)/, ')') : 'rgb(0,0,0)';
          }
          return {
            rgbaToHex: rgbaToHex,
            hexToRgba: hexToRgba,
            rgbToRgba: rgbToRgba,
            rgbaToRgb: rgbaToRgb
          };
        }
      })();
      (function() {
        "use strict";
        angular.module('material.core').factory('$mdConstant', MdConstantFactory);
        function MdConstantFactory($sniffer, $window, $document) {
          var vendorPrefix = $sniffer.vendorPrefix;
          var isWebkit = /webkit/i.test(vendorPrefix);
          var SPECIAL_CHARS_REGEXP = /([:\-_]+(.))/g;
          var prefixTestEl = document.createElement('div');
          function vendorProperty(name) {
            var prefixedName = vendorPrefix + '-' + name;
            var ucPrefix = camelCase(prefixedName);
            var lcPrefix = ucPrefix.charAt(0).toLowerCase() + ucPrefix.substring(1);
            return hasStyleProperty(name) ? name : hasStyleProperty(ucPrefix) ? ucPrefix : hasStyleProperty(lcPrefix) ? lcPrefix : name;
          }
          function hasStyleProperty(property) {
            return angular.isDefined(prefixTestEl.style[property]);
          }
          function camelCase(input) {
            return input.replace(SPECIAL_CHARS_REGEXP, function(matches, separator, letter, offset) {
              return offset ? letter.toUpperCase() : letter;
            });
          }
          return {
            KEY_CODE: {
              COMMA: 188,
              SEMICOLON: 186,
              ENTER: 13,
              ESCAPE: 27,
              SPACE: 32,
              PAGE_UP: 33,
              PAGE_DOWN: 34,
              END: 35,
              HOME: 36,
              LEFT_ARROW: 37,
              UP_ARROW: 38,
              RIGHT_ARROW: 39,
              DOWN_ARROW: 40,
              TAB: 9,
              BACKSPACE: 8,
              DELETE: 46
            },
            CSS: {
              TRANSITIONEND: 'transitionend' + (isWebkit ? ' webkitTransitionEnd' : ''),
              ANIMATIONEND: 'animationend' + (isWebkit ? ' webkitAnimationEnd' : ''),
              TRANSFORM: vendorProperty('transform'),
              TRANSFORM_ORIGIN: vendorProperty('transformOrigin'),
              TRANSITION: vendorProperty('transition'),
              TRANSITION_DURATION: vendorProperty('transitionDuration'),
              ANIMATION_PLAY_STATE: vendorProperty('animationPlayState'),
              ANIMATION_DURATION: vendorProperty('animationDuration'),
              ANIMATION_NAME: vendorProperty('animationName'),
              ANIMATION_TIMING: vendorProperty('animationTimingFunction'),
              ANIMATION_DIRECTION: vendorProperty('animationDirection')
            },
            MEDIA: {
              'xs': '(max-width: 599px)',
              'gt-xs': '(min-width: 600px)',
              'sm': '(min-width: 600px) and (max-width: 959px)',
              'gt-sm': '(min-width: 960px)',
              'md': '(min-width: 960px) and (max-width: 1279px)',
              'gt-md': '(min-width: 1280px)',
              'lg': '(min-width: 1280px) and (max-width: 1919px)',
              'gt-lg': '(min-width: 1920px)',
              'xl': '(min-width: 1920px)',
              'landscape': '(orientation: landscape)',
              'portrait': '(orientation: portrait)',
              'print': 'print'
            },
            MEDIA_PRIORITY: ['xl', 'gt-lg', 'lg', 'gt-md', 'md', 'gt-sm', 'sm', 'gt-xs', 'xs', 'landscape', 'portrait', 'print']
          };
        }
        MdConstantFactory.$inject = ["$sniffer", "$window", "$document"];
      })();
      (function() {
        "use strict";
        angular.module('material.core').config(["$provide", function($provide) {
          $provide.decorator('$mdUtil', ['$delegate', function($delegate) {
            $delegate.iterator = MdIterator;
            return $delegate;
          }]);
        }]);
        function MdIterator(items, reloop) {
          var trueFn = function() {
            return true;
          };
          if (items && !angular.isArray(items)) {
            items = Array.prototype.slice.call(items);
          }
          reloop = !!reloop;
          var _items = items || [];
          return {
            items: getItems,
            count: count,
            inRange: inRange,
            contains: contains,
            indexOf: indexOf,
            itemAt: itemAt,
            findBy: findBy,
            add: add,
            remove: remove,
            first: first,
            last: last,
            next: angular.bind(null, findSubsequentItem, false),
            previous: angular.bind(null, findSubsequentItem, true),
            hasPrevious: hasPrevious,
            hasNext: hasNext
          };
          function getItems() {
            return [].concat(_items);
          }
          function count() {
            return _items.length;
          }
          function inRange(index) {
            return _items.length && (index > -1) && (index < _items.length);
          }
          function hasNext(item) {
            return item ? inRange(indexOf(item) + 1) : false;
          }
          function hasPrevious(item) {
            return item ? inRange(indexOf(item) - 1) : false;
          }
          function itemAt(index) {
            return inRange(index) ? _items[index] : null;
          }
          function findBy(key, val) {
            return _items.filter(function(item) {
              return item[key] === val;
            });
          }
          function add(item, index) {
            if (!item)
              return -1;
            if (!angular.isNumber(index)) {
              index = _items.length;
            }
            _items.splice(index, 0, item);
            return indexOf(item);
          }
          function remove(item) {
            if (contains(item)) {
              _items.splice(indexOf(item), 1);
            }
          }
          function indexOf(item) {
            return _items.indexOf(item);
          }
          function contains(item) {
            return item && (indexOf(item) > -1);
          }
          function first() {
            return _items.length ? _items[0] : null;
          }
          function last() {
            return _items.length ? _items[_items.length - 1] : null;
          }
          function findSubsequentItem(backwards, item, validate, limit) {
            validate = validate || trueFn;
            var curIndex = indexOf(item);
            while (true) {
              if (!inRange(curIndex))
                return null;
              var nextIndex = curIndex + (backwards ? -1 : 1);
              var foundItem = null;
              if (inRange(nextIndex)) {
                foundItem = _items[nextIndex];
              } else if (reloop) {
                foundItem = backwards ? last() : first();
                nextIndex = indexOf(foundItem);
              }
              if ((foundItem === null) || (nextIndex === limit))
                return null;
              if (validate(foundItem))
                return foundItem;
              if (angular.isUndefined(limit))
                limit = nextIndex;
              curIndex = nextIndex;
            }
          }
        }
      })();
      (function() {
        "use strict";
        angular.module('material.core').factory('$mdMedia', mdMediaFactory);
        function mdMediaFactory($mdConstant, $rootScope, $window) {
          var queries = {};
          var mqls = {};
          var results = {};
          var normalizeCache = {};
          $mdMedia.getResponsiveAttribute = getResponsiveAttribute;
          $mdMedia.getQuery = getQuery;
          $mdMedia.watchResponsiveAttributes = watchResponsiveAttributes;
          return $mdMedia;
          function $mdMedia(query) {
            var validated = queries[query];
            if (angular.isUndefined(validated)) {
              validated = queries[query] = validate(query);
            }
            var result = results[validated];
            if (angular.isUndefined(result)) {
              result = add(validated);
            }
            return result;
          }
          function validate(query) {
            return $mdConstant.MEDIA[query] || ((query.charAt(0) !== '(') ? ('(' + query + ')') : query);
          }
          function add(query) {
            var result = mqls[query];
            if (!result) {
              result = mqls[query] = $window.matchMedia(query);
            }
            result.addListener(onQueryChange);
            return (results[result.media] = !!result.matches);
          }
          function onQueryChange(query) {
            $rootScope.$evalAsync(function() {
              results[query.media] = !!query.matches;
            });
          }
          function getQuery(name) {
            return mqls[name];
          }
          function getResponsiveAttribute(attrs, attrName) {
            for (var i = 0; i < $mdConstant.MEDIA_PRIORITY.length; i++) {
              var mediaName = $mdConstant.MEDIA_PRIORITY[i];
              if (!mqls[queries[mediaName]].matches) {
                continue;
              }
              var normalizedName = getNormalizedName(attrs, attrName + '-' + mediaName);
              if (attrs[normalizedName]) {
                return attrs[normalizedName];
              }
            }
            return attrs[getNormalizedName(attrs, attrName)];
          }
          function watchResponsiveAttributes(attrNames, attrs, watchFn) {
            var unwatchFns = [];
            attrNames.forEach(function(attrName) {
              var normalizedName = getNormalizedName(attrs, attrName);
              if (angular.isDefined(attrs[normalizedName])) {
                unwatchFns.push(attrs.$observe(normalizedName, angular.bind(void 0, watchFn, null)));
              }
              for (var mediaName in $mdConstant.MEDIA) {
                normalizedName = getNormalizedName(attrs, attrName + '-' + mediaName);
                if (angular.isDefined(attrs[normalizedName])) {
                  unwatchFns.push(attrs.$observe(normalizedName, angular.bind(void 0, watchFn, mediaName)));
                }
              }
            });
            return function unwatch() {
              unwatchFns.forEach(function(fn) {
                fn();
              });
            };
          }
          function getNormalizedName(attrs, attrName) {
            return normalizeCache[attrName] || (normalizeCache[attrName] = attrs.$normalize(attrName));
          }
        }
        mdMediaFactory.$inject = ["$mdConstant", "$rootScope", "$window"];
      })();
      (function() {
        "use strict";
        angular.module('material.core').config(["$provide", function($provide) {
          $provide.decorator('$mdUtil', ['$delegate', function($delegate) {
            $delegate.prefixer = MdPrefixer;
            return $delegate;
          }]);
        }]);
        function MdPrefixer(initialAttributes, buildSelector) {
          var PREFIXES = ['data', 'x'];
          if (initialAttributes) {
            return buildSelector ? _buildSelector(initialAttributes) : _buildList(initialAttributes);
          }
          return {
            buildList: _buildList,
            buildSelector: _buildSelector,
            hasAttribute: _hasAttribute
          };
          function _buildList(attributes) {
            attributes = angular.isArray(attributes) ? attributes : [attributes];
            attributes.forEach(function(item) {
              PREFIXES.forEach(function(prefix) {
                attributes.push(prefix + '-' + item);
              });
            });
            return attributes;
          }
          function _buildSelector(attributes) {
            attributes = angular.isArray(attributes) ? attributes : [attributes];
            return _buildList(attributes).map(function(item) {
              return '[' + item + ']';
            }).join(',');
          }
          function _hasAttribute(element, attribute) {
            element = element[0] || element;
            var prefixedAttrs = _buildList(attribute);
            for (var i = 0; i < prefixedAttrs.length; i++) {
              if (element.hasAttribute(prefixedAttrs[i])) {
                return true;
              }
            }
            return false;
          }
        }
      })();
      (function() {
        "use strict";
        var nextUniqueId = 0;
        angular.module('material.core').factory('$mdUtil', UtilFactory);
        function UtilFactory($document, $timeout, $compile, $rootScope, $$mdAnimate, $interpolate, $log, $rootElement, $window) {
          var startSymbol = $interpolate.startSymbol(),
              endSymbol = $interpolate.endSymbol(),
              usesStandardSymbols = ((startSymbol === '{{') && (endSymbol === '}}'));
          var hasComputedStyle = function(target, key, expectedVal) {
            var hasValue = false;
            if (target && target.length) {
              var computedStyles = $window.getComputedStyle(target[0]);
              hasValue = angular.isDefined(computedStyles[key]) && (expectedVal ? computedStyles[key] == expectedVal : true);
            }
            return hasValue;
          };
          function validateCssValue(value) {
            return !value ? '0' : hasPx(value) || hasPercent(value) ? value : value + 'px';
          }
          function hasPx(value) {
            return String(value).indexOf('px') > -1;
          }
          function hasPercent(value) {
            return String(value).indexOf('%') > -1;
          }
          var $mdUtil = {
            dom: {},
            now: window.performance ? angular.bind(window.performance, window.performance.now) : Date.now || function() {
              return new Date().getTime();
            },
            bidi: function(element, property, lValue, rValue) {
              var ltr = !($document[0].dir == 'rtl' || $document[0].body.dir == 'rtl');
              if (arguments.length == 0)
                return ltr ? 'ltr' : 'rtl';
              var elem = angular.element(element);
              if (ltr && angular.isDefined(lValue)) {
                elem.css(property, validateCssValue(lValue));
              } else if (!ltr && angular.isDefined(rValue)) {
                elem.css(property, validateCssValue(rValue));
              }
            },
            bidiProperty: function(element, lProperty, rProperty, value) {
              var ltr = !($document[0].dir == 'rtl' || $document[0].body.dir == 'rtl');
              var elem = angular.element(element);
              if (ltr && angular.isDefined(lProperty)) {
                elem.css(lProperty, validateCssValue(value));
                elem.css(rProperty, '');
              } else if (!ltr && angular.isDefined(rProperty)) {
                elem.css(rProperty, validateCssValue(value));
                elem.css(lProperty, '');
              }
            },
            clientRect: function(element, offsetParent, isOffsetRect) {
              var node = getNode(element);
              offsetParent = getNode(offsetParent || node.offsetParent || document.body);
              var nodeRect = node.getBoundingClientRect();
              var offsetRect = isOffsetRect ? offsetParent.getBoundingClientRect() : {
                left: 0,
                top: 0,
                width: 0,
                height: 0
              };
              return {
                left: nodeRect.left - offsetRect.left,
                top: nodeRect.top - offsetRect.top,
                width: nodeRect.width,
                height: nodeRect.height
              };
            },
            offsetRect: function(element, offsetParent) {
              return $mdUtil.clientRect(element, offsetParent, true);
            },
            nodesToArray: function(nodes) {
              nodes = nodes || [];
              var results = [];
              for (var i = 0; i < nodes.length; ++i) {
                results.push(nodes.item(i));
              }
              return results;
            },
            scrollTop: function(element) {
              element = angular.element(element || $document[0].body);
              var body = (element[0] == $document[0].body) ? $document[0].body : undefined;
              var scrollTop = body ? body.scrollTop + body.parentElement.scrollTop : 0;
              return scrollTop || Math.abs(element[0].getBoundingClientRect().top);
            },
            findFocusTarget: function(containerEl, attributeVal) {
              var AUTO_FOCUS = this.prefixer('md-autofocus', true);
              var elToFocus;
              elToFocus = scanForFocusable(containerEl, attributeVal || AUTO_FOCUS);
              if (!elToFocus && attributeVal != AUTO_FOCUS) {
                elToFocus = scanForFocusable(containerEl, this.prefixer('md-auto-focus', true));
                if (!elToFocus) {
                  elToFocus = scanForFocusable(containerEl, AUTO_FOCUS);
                }
              }
              return elToFocus;
              function scanForFocusable(target, selector) {
                var elFound,
                    items = target[0].querySelectorAll(selector);
                if (items && items.length) {
                  items.length && angular.forEach(items, function(it) {
                    it = angular.element(it);
                    var isFocusable = it.hasClass('_md-autofocus');
                    if (isFocusable)
                      elFound = it;
                  });
                }
                return elFound;
              }
            },
            disableScrollAround: function(element, parent) {
              $mdUtil.disableScrollAround._count = $mdUtil.disableScrollAround._count || 0;
              ++$mdUtil.disableScrollAround._count;
              if ($mdUtil.disableScrollAround._enableScrolling)
                return $mdUtil.disableScrollAround._enableScrolling;
              var body = $document[0].body,
                  restoreBody = disableBodyScroll(),
                  restoreElement = disableElementScroll(parent);
              return $mdUtil.disableScrollAround._enableScrolling = function() {
                if (!--$mdUtil.disableScrollAround._count) {
                  restoreBody();
                  restoreElement();
                  delete $mdUtil.disableScrollAround._enableScrolling;
                }
              };
              function disableElementScroll(element) {
                element = angular.element(element || body)[0];
                var scrollMask = angular.element('<div class="md-scroll-mask">' + '  <div class="md-scroll-mask-bar"></div>' + '</div>');
                element.appendChild(scrollMask[0]);
                scrollMask.on('wheel', preventDefault);
                scrollMask.on('touchmove', preventDefault);
                return function restoreScroll() {
                  scrollMask.off('wheel');
                  scrollMask.off('touchmove');
                  scrollMask[0].parentNode.removeChild(scrollMask[0]);
                  delete $mdUtil.disableScrollAround._enableScrolling;
                };
                function preventDefault(e) {
                  e.preventDefault();
                }
              }
              function disableBodyScroll() {
                var htmlNode = body.parentNode;
                var restoreHtmlStyle = htmlNode.style.cssText || '';
                var restoreBodyStyle = body.style.cssText || '';
                var scrollOffset = $mdUtil.scrollTop(body);
                var clientWidth = body.clientWidth;
                if (body.scrollHeight > body.clientHeight + 1) {
                  applyStyles(body, {
                    position: 'fixed',
                    width: '100%',
                    top: -scrollOffset + 'px'
                  });
                  htmlNode.style.overflowY = 'scroll';
                }
                if (body.clientWidth < clientWidth)
                  applyStyles(body, {overflow: 'hidden'});
                return function restoreScroll() {
                  body.style.cssText = restoreBodyStyle;
                  htmlNode.style.cssText = restoreHtmlStyle;
                  body.scrollTop = scrollOffset;
                  htmlNode.scrollTop = scrollOffset;
                };
              }
              function applyStyles(el, styles) {
                for (var key in styles) {
                  el.style[key] = styles[key];
                }
              }
            },
            enableScrolling: function() {
              var method = this.disableScrollAround._enableScrolling;
              method && method();
            },
            floatingScrollbars: function() {
              if (this.floatingScrollbars.cached === undefined) {
                var tempNode = angular.element('<div><div></div></div>').css({
                  width: '100%',
                  'z-index': -1,
                  position: 'absolute',
                  height: '35px',
                  'overflow-y': 'scroll'
                });
                tempNode.children().css('height', '60px');
                $document[0].body.appendChild(tempNode[0]);
                this.floatingScrollbars.cached = (tempNode[0].offsetWidth == tempNode[0].childNodes[0].offsetWidth);
                tempNode.remove();
              }
              return this.floatingScrollbars.cached;
            },
            forceFocus: function(element) {
              var node = element[0] || element;
              document.addEventListener('click', function focusOnClick(ev) {
                if (ev.target === node && ev.$focus) {
                  node.focus();
                  ev.stopImmediatePropagation();
                  ev.preventDefault();
                  node.removeEventListener('click', focusOnClick);
                }
              }, true);
              var newEvent = document.createEvent('MouseEvents');
              newEvent.initMouseEvent('click', false, true, window, {}, 0, 0, 0, 0, false, false, false, false, 0, null);
              newEvent.$material = true;
              newEvent.$focus = true;
              node.dispatchEvent(newEvent);
            },
            createBackdrop: function(scope, addClass) {
              return $compile($mdUtil.supplant('<md-backdrop class="{0}">', [addClass]))(scope);
            },
            supplant: function(template, values, pattern) {
              pattern = pattern || /\{([^\{\}]*)\}/g;
              return template.replace(pattern, function(a, b) {
                var p = b.split('.'),
                    r = values;
                try {
                  for (var s in p) {
                    if (p.hasOwnProperty(s)) {
                      r = r[p[s]];
                    }
                  }
                } catch (e) {
                  r = a;
                }
                return (typeof r === 'string' || typeof r === 'number') ? r : a;
              });
            },
            fakeNgModel: function() {
              return {
                $fake: true,
                $setTouched: angular.noop,
                $setViewValue: function(value) {
                  this.$viewValue = value;
                  this.$render(value);
                  this.$viewChangeListeners.forEach(function(cb) {
                    cb();
                  });
                },
                $isEmpty: function(value) {
                  return ('' + value).length === 0;
                },
                $parsers: [],
                $formatters: [],
                $viewChangeListeners: [],
                $render: angular.noop
              };
            },
            debounce: function(func, wait, scope, invokeApply) {
              var timer;
              return function debounced() {
                var context = scope,
                    args = Array.prototype.slice.call(arguments);
                $timeout.cancel(timer);
                timer = $timeout(function() {
                  timer = undefined;
                  func.apply(context, args);
                }, wait || 10, invokeApply);
              };
            },
            throttle: function throttle(func, delay) {
              var recent;
              return function throttled() {
                var context = this;
                var args = arguments;
                var now = $mdUtil.now();
                if (!recent || (now - recent > delay)) {
                  func.apply(context, args);
                  recent = now;
                }
              };
            },
            time: function time(cb) {
              var start = $mdUtil.now();
              cb();
              return $mdUtil.now() - start;
            },
            valueOnUse: function(scope, key, getter) {
              var value = null,
                  args = Array.prototype.slice.call(arguments);
              var params = (args.length > 3) ? args.slice(3) : [];
              Object.defineProperty(scope, key, {get: function() {
                  if (value === null)
                    value = getter.apply(scope, params);
                  return value;
                }});
            },
            nextUid: function() {
              return '' + nextUniqueId++;
            },
            disconnectScope: function disconnectScope(scope) {
              if (!scope)
                return;
              if (scope.$root === scope)
                return;
              if (scope.$$destroyed)
                return;
              var parent = scope.$parent;
              scope.$$disconnected = true;
              if (parent.$$childHead === scope)
                parent.$$childHead = scope.$$nextSibling;
              if (parent.$$childTail === scope)
                parent.$$childTail = scope.$$prevSibling;
              if (scope.$$prevSibling)
                scope.$$prevSibling.$$nextSibling = scope.$$nextSibling;
              if (scope.$$nextSibling)
                scope.$$nextSibling.$$prevSibling = scope.$$prevSibling;
              scope.$$nextSibling = scope.$$prevSibling = null;
            },
            reconnectScope: function reconnectScope(scope) {
              if (!scope)
                return;
              if (scope.$root === scope)
                return;
              if (!scope.$$disconnected)
                return;
              var child = scope;
              var parent = child.$parent;
              child.$$disconnected = false;
              child.$$prevSibling = parent.$$childTail;
              if (parent.$$childHead) {
                parent.$$childTail.$$nextSibling = child;
                parent.$$childTail = child;
              } else {
                parent.$$childHead = parent.$$childTail = child;
              }
            },
            getClosest: function getClosest(el, validateWith, onlyParent) {
              if (angular.isString(validateWith)) {
                var tagName = validateWith.toUpperCase();
                validateWith = function(el) {
                  return el.nodeName === tagName;
                };
              }
              if (el instanceof angular.element)
                el = el[0];
              if (onlyParent)
                el = el.parentNode;
              if (!el)
                return null;
              do {
                if (validateWith(el)) {
                  return el;
                }
              } while (el = el.parentNode);
              return null;
            },
            elementContains: function(node, child) {
              var hasContains = (window.Node && window.Node.prototype && Node.prototype.contains);
              var findFn = hasContains ? angular.bind(node, node.contains) : angular.bind(node, function(arg) {
                return (node === child) || !!(this.compareDocumentPosition(arg) & 16);
              });
              return findFn(child);
            },
            extractElementByName: function(element, nodeName, scanDeep, warnNotFound) {
              var found = scanTree(element);
              if (!found && !!warnNotFound) {
                $log.warn($mdUtil.supplant("Unable to find node '{0}' in element '{1}'.", [nodeName, element[0].outerHTML]));
              }
              return angular.element(found || element);
              function scanTree(element) {
                return scanLevel(element) || (!!scanDeep ? scanChildren(element) : null);
              }
              function scanLevel(element) {
                if (element) {
                  for (var i = 0,
                      len = element.length; i < len; i++) {
                    if (element[i].nodeName.toLowerCase() === nodeName) {
                      return element[i];
                    }
                  }
                }
                return null;
              }
              function scanChildren(element) {
                var found;
                if (element) {
                  for (var i = 0,
                      len = element.length; i < len; i++) {
                    var target = element[i];
                    if (!found) {
                      for (var j = 0,
                          numChild = target.childNodes.length; j < numChild; j++) {
                        found = found || scanTree([target.childNodes[j]]);
                      }
                    }
                  }
                }
                return found;
              }
            },
            initOptionalProperties: function(scope, attr, defaults) {
              defaults = defaults || {};
              angular.forEach(scope.$$isolateBindings, function(binding, key) {
                if (binding.optional && angular.isUndefined(scope[key])) {
                  var attrIsDefined = angular.isDefined(attr[binding.attrName]);
                  scope[key] = angular.isDefined(defaults[key]) ? defaults[key] : attrIsDefined;
                }
              });
            },
            nextTick: function(callback, digest, scope) {
              var nextTick = $mdUtil.nextTick;
              var timeout = nextTick.timeout;
              var queue = nextTick.queue || [];
              queue.push({
                scope: scope,
                callback: callback
              });
              if (digest == null)
                digest = true;
              nextTick.digest = nextTick.digest || digest;
              nextTick.queue = queue;
              return timeout || (nextTick.timeout = $timeout(processQueue, 0, false));
              function processQueue() {
                var queue = nextTick.queue;
                var digest = nextTick.digest;
                nextTick.queue = [];
                nextTick.timeout = null;
                nextTick.digest = false;
                queue.forEach(function(queueItem) {
                  var skip = queueItem.scope && queueItem.scope.$$destroyed;
                  if (!skip) {
                    queueItem.callback();
                  }
                });
                if (digest)
                  $rootScope.$digest();
              }
            },
            processTemplate: function(template) {
              if (usesStandardSymbols) {
                return template;
              } else {
                if (!template || !angular.isString(template))
                  return template;
                return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
              }
            },
            getParentWithPointerEvents: function(element) {
              var parent = element.parent();
              while (hasComputedStyle(parent, 'pointer-events', 'none')) {
                parent = parent.parent();
              }
              return parent;
            },
            getNearestContentElement: function(element) {
              var current = element.parent()[0];
              while (current && current !== $rootElement[0] && current !== document.body && current.nodeName.toUpperCase() !== 'MD-CONTENT') {
                current = current.parentNode;
              }
              return current;
            },
            checkStickySupport: function() {
              var stickyProp;
              var testEl = angular.element('<div>');
              $document[0].body.appendChild(testEl[0]);
              var stickyProps = ['sticky', '-webkit-sticky'];
              for (var i = 0; i < stickyProps.length; ++i) {
                testEl.css({
                  position: stickyProps[i],
                  top: 0,
                  'z-index': 2
                });
                if (testEl.css('position') == stickyProps[i]) {
                  stickyProp = stickyProps[i];
                  break;
                }
              }
              testEl.remove();
              return stickyProp;
            },
            parseAttributeBoolean: function(value, negatedCheck) {
              return value === '' || !!value && (negatedCheck === false || value !== 'false' && value !== '0');
            },
            hasComputedStyle: hasComputedStyle,
            isParentFormSubmitted: function(element) {
              var parent = $mdUtil.getClosest(element, 'form');
              var form = parent ? angular.element(parent).controller('form') : null;
              return form ? form.$submitted : false;
            }
          };
          $mdUtil.dom.animator = $$mdAnimate($mdUtil);
          return $mdUtil;
          function getNode(el) {
            return el[0] || el;
          }
        }
        UtilFactory.$inject = ["$document", "$timeout", "$compile", "$rootScope", "$$mdAnimate", "$interpolate", "$log", "$rootElement", "$window"];
        angular.element.prototype.focus = angular.element.prototype.focus || function() {
          if (this.length) {
            this[0].focus();
          }
          return this;
        };
        angular.element.prototype.blur = angular.element.prototype.blur || function() {
          if (this.length) {
            this[0].blur();
          }
          return this;
        };
      })();
      (function() {
        "use strict";
        angular.module('material.core').provider('$mdAria', MdAriaProvider);
        function MdAriaProvider() {
          var self = this;
          self.showWarnings = true;
          return {
            disableWarnings: disableWarnings,
            $get: ["$$rAF", "$log", "$window", "$interpolate", function($$rAF, $log, $window, $interpolate) {
              return MdAriaService.apply(self, arguments);
            }]
          };
          function disableWarnings() {
            self.showWarnings = false;
          }
        }
        function MdAriaService($$rAF, $log, $window, $interpolate) {
          var showWarnings = this.showWarnings;
          return {
            expect: expect,
            expectAsync: expectAsync,
            expectWithText: expectWithText,
            expectWithoutText: expectWithoutText
          };
          function expect(element, attrName, defaultValue) {
            var node = angular.element(element)[0] || element;
            if (node && ((!node.hasAttribute(attrName) || node.getAttribute(attrName).length === 0) && !childHasAttribute(node, attrName))) {
              defaultValue = angular.isString(defaultValue) ? defaultValue.trim() : '';
              if (defaultValue.length) {
                element.attr(attrName, defaultValue);
              } else if (showWarnings) {
                $log.warn('ARIA: Attribute "', attrName, '", required for accessibility, is missing on node:', node);
              }
            }
          }
          function expectAsync(element, attrName, defaultValueGetter) {
            $$rAF(function() {
              expect(element, attrName, defaultValueGetter());
            });
          }
          function expectWithText(element, attrName) {
            var content = getText(element) || "";
            var hasBinding = content.indexOf($interpolate.startSymbol()) > -1;
            if (hasBinding) {
              expectAsync(element, attrName, function() {
                return getText(element);
              });
            } else {
              expect(element, attrName, content);
            }
          }
          function expectWithoutText(element, attrName) {
            var content = getText(element);
            var hasBinding = content.indexOf($interpolate.startSymbol()) > -1;
            if (!hasBinding && !content) {
              expect(element, attrName, content);
            }
          }
          function getText(element) {
            element = element[0] || element;
            var walker = document.createTreeWalker(element, NodeFilter.SHOW_TEXT, null, false);
            var text = '';
            var node;
            while (node = walker.nextNode()) {
              if (!isAriaHiddenNode(node)) {
                text += node.textContent;
              }
            }
            return text.trim() || '';
            function isAriaHiddenNode(node) {
              while (node.parentNode && (node = node.parentNode) !== element) {
                if (node.getAttribute && node.getAttribute('aria-hidden') === 'true') {
                  return true;
                }
              }
            }
          }
          function childHasAttribute(node, attrName) {
            var hasChildren = node.hasChildNodes(),
                hasAttr = false;
            function isHidden(el) {
              var style = el.currentStyle ? el.currentStyle : $window.getComputedStyle(el);
              return (style.display === 'none');
            }
            if (hasChildren) {
              var children = node.childNodes;
              for (var i = 0; i < children.length; i++) {
                var child = children[i];
                if (child.nodeType === 1 && child.hasAttribute(attrName)) {
                  if (!isHidden(child)) {
                    hasAttr = true;
                  }
                }
              }
            }
            return hasAttr;
          }
        }
        MdAriaService.$inject = ["$$rAF", "$log", "$window", "$interpolate"];
      })();
      (function() {
        "use strict";
        angular.module('material.core').service('$mdCompiler', mdCompilerService);
        function mdCompilerService($q, $templateRequest, $injector, $compile, $controller) {
          this.compile = function(options) {
            var templateUrl = options.templateUrl;
            var template = options.template || '';
            var controller = options.controller;
            var controllerAs = options.controllerAs;
            var resolve = angular.extend({}, options.resolve || {});
            var locals = angular.extend({}, options.locals || {});
            var transformTemplate = options.transformTemplate || angular.identity;
            var bindToController = options.bindToController;
            angular.forEach(resolve, function(value, key) {
              if (angular.isString(value)) {
                resolve[key] = $injector.get(value);
              } else {
                resolve[key] = $injector.invoke(value);
              }
            });
            angular.extend(resolve, locals);
            if (templateUrl) {
              resolve.$template = $templateRequest(templateUrl).then(function(response) {
                return response;
              });
            } else {
              resolve.$template = $q.when(template);
            }
            return $q.all(resolve).then(function(locals) {
              var compiledData;
              var template = transformTemplate(locals.$template, options);
              var element = options.element || angular.element('<div>').html(template.trim()).contents();
              var linkFn = $compile(element);
              return compiledData = {
                locals: locals,
                element: element,
                link: function link(scope) {
                  locals.$scope = scope;
                  if (controller) {
                    var invokeCtrl = $controller(controller, locals, true);
                    if (bindToController) {
                      angular.extend(invokeCtrl.instance, locals);
                    }
                    var ctrl = invokeCtrl();
                    element.data('$ngControllerController', ctrl);
                    element.children().data('$ngControllerController', ctrl);
                    if (controllerAs) {
                      scope[controllerAs] = ctrl;
                    }
                    compiledData.controller = ctrl;
                  }
                  return linkFn(scope);
                }
              };
            });
          };
        }
        mdCompilerService.$inject = ["$q", "$templateRequest", "$injector", "$compile", "$controller"];
      })();
      (function() {
        "use strict";
        var HANDLERS = {};
        var pointer,
            lastPointer,
            forceSkipClickHijack = false;
        var lastLabelClickPos = null;
        var isInitialized = false;
        angular.module('material.core.gestures', []).provider('$mdGesture', MdGestureProvider).factory('$$MdGestureHandler', MdGestureHandler).run(attachToDocument);
        function MdGestureProvider() {}
        MdGestureProvider.prototype = {
          skipClickHijack: function() {
            return forceSkipClickHijack = true;
          },
          $get: ["$$MdGestureHandler", "$$rAF", "$timeout", function($$MdGestureHandler, $$rAF, $timeout) {
            return new MdGesture($$MdGestureHandler, $$rAF, $timeout);
          }]
        };
        function MdGesture($$MdGestureHandler, $$rAF, $timeout) {
          var userAgent = navigator.userAgent || navigator.vendor || window.opera;
          var isIos = userAgent.match(/ipad|iphone|ipod/i);
          var isAndroid = userAgent.match(/android/i);
          var touchActionProperty = getTouchAction();
          var hasJQuery = (typeof window.jQuery !== 'undefined') && (angular.element === window.jQuery);
          var self = {
            handler: addHandler,
            register: register,
            isHijackingClicks: (isIos || isAndroid) && !hasJQuery && !forceSkipClickHijack
          };
          if (self.isHijackingClicks) {
            var maxClickDistance = 6;
            self.handler('click', {
              options: {maxDistance: maxClickDistance},
              onEnd: checkDistanceAndEmit('click')
            });
            self.handler('focus', {
              options: {maxDistance: maxClickDistance},
              onEnd: function(ev, pointer) {
                if (pointer.distance < this.state.options.maxDistance) {
                  if (canFocus(ev.target)) {
                    this.dispatchEvent(ev, 'focus', pointer);
                    ev.target.focus();
                  }
                }
                function canFocus(element) {
                  var focusableElements = ['INPUT', 'SELECT', 'BUTTON', 'TEXTAREA', 'VIDEO', 'AUDIO'];
                  return (element.getAttribute('tabindex') != '-1') && !element.hasAttribute('DISABLED') && (element.hasAttribute('tabindex') || element.hasAttribute('href') || element.isContentEditable || (focusableElements.indexOf(element.nodeName) != -1));
                }
              }
            });
            self.handler('mouseup', {
              options: {maxDistance: maxClickDistance},
              onEnd: checkDistanceAndEmit('mouseup')
            });
            self.handler('mousedown', {onStart: function(ev) {
                this.dispatchEvent(ev, 'mousedown');
              }});
          }
          function checkDistanceAndEmit(eventName) {
            return function(ev, pointer) {
              if (pointer.distance < this.state.options.maxDistance) {
                this.dispatchEvent(ev, eventName, pointer);
              }
            };
          }
          function register(element, handlerName, options) {
            var handler = HANDLERS[handlerName.replace(/^\$md./, '')];
            if (!handler) {
              throw new Error('Failed to register element with handler ' + handlerName + '. ' + 'Available handlers: ' + Object.keys(HANDLERS).join(', '));
            }
            return handler.registerElement(element, options);
          }
          function addHandler(name, definition) {
            var handler = new $$MdGestureHandler(name);
            angular.extend(handler, definition);
            HANDLERS[name] = handler;
            return self;
          }
          return self.handler('press', {
            onStart: function(ev, pointer) {
              this.dispatchEvent(ev, '$md.pressdown');
            },
            onEnd: function(ev, pointer) {
              this.dispatchEvent(ev, '$md.pressup');
            }
          }).handler('hold', {
            options: {
              maxDistance: 6,
              delay: 500
            },
            onCancel: function() {
              $timeout.cancel(this.state.timeout);
            },
            onStart: function(ev, pointer) {
              if (!this.state.registeredParent)
                return this.cancel();
              this.state.pos = {
                x: pointer.x,
                y: pointer.y
              };
              this.state.timeout = $timeout(angular.bind(this, function holdDelayFn() {
                this.dispatchEvent(ev, '$md.hold');
                this.cancel();
              }), this.state.options.delay, false);
            },
            onMove: function(ev, pointer) {
              if (!touchActionProperty && ev.type === 'touchmove')
                ev.preventDefault();
              var dx = this.state.pos.x - pointer.x;
              var dy = this.state.pos.y - pointer.y;
              if (Math.sqrt(dx * dx + dy * dy) > this.options.maxDistance) {
                this.cancel();
              }
            },
            onEnd: function() {
              this.onCancel();
            }
          }).handler('drag', {
            options: {
              minDistance: 6,
              horizontal: true,
              cancelMultiplier: 1.5
            },
            onSetup: function(element, options) {
              if (touchActionProperty) {
                this.oldTouchAction = element[0].style[touchActionProperty];
                element[0].style[touchActionProperty] = options.horizontal === false ? 'pan-y' : 'pan-x';
              }
            },
            onCleanup: function(element) {
              if (this.oldTouchAction) {
                element[0].style[touchActionProperty] = this.oldTouchAction;
              }
            },
            onStart: function(ev) {
              if (!this.state.registeredParent)
                this.cancel();
            },
            onMove: function(ev, pointer) {
              var shouldStartDrag,
                  shouldCancel;
              if (!touchActionProperty && ev.type === 'touchmove')
                ev.preventDefault();
              if (!this.state.dragPointer) {
                if (this.state.options.horizontal) {
                  shouldStartDrag = Math.abs(pointer.distanceX) > this.state.options.minDistance;
                  shouldCancel = Math.abs(pointer.distanceY) > this.state.options.minDistance * this.state.options.cancelMultiplier;
                } else {
                  shouldStartDrag = Math.abs(pointer.distanceY) > this.state.options.minDistance;
                  shouldCancel = Math.abs(pointer.distanceX) > this.state.options.minDistance * this.state.options.cancelMultiplier;
                }
                if (shouldStartDrag) {
                  this.state.dragPointer = makeStartPointer(ev);
                  updatePointerState(ev, this.state.dragPointer);
                  this.dispatchEvent(ev, '$md.dragstart', this.state.dragPointer);
                } else if (shouldCancel) {
                  this.cancel();
                }
              } else {
                this.dispatchDragMove(ev);
              }
            },
            dispatchDragMove: $$rAF.throttle(function(ev) {
              if (this.state.isRunning) {
                updatePointerState(ev, this.state.dragPointer);
                this.dispatchEvent(ev, '$md.drag', this.state.dragPointer);
              }
            }),
            onEnd: function(ev, pointer) {
              if (this.state.dragPointer) {
                updatePointerState(ev, this.state.dragPointer);
                this.dispatchEvent(ev, '$md.dragend', this.state.dragPointer);
              }
            }
          }).handler('swipe', {
            options: {
              minVelocity: 0.65,
              minDistance: 10
            },
            onEnd: function(ev, pointer) {
              var eventType;
              if (Math.abs(pointer.velocityX) > this.state.options.minVelocity && Math.abs(pointer.distanceX) > this.state.options.minDistance) {
                eventType = pointer.directionX == 'left' ? '$md.swipeleft' : '$md.swiperight';
                this.dispatchEvent(ev, eventType);
              } else if (Math.abs(pointer.velocityY) > this.state.options.minVelocity && Math.abs(pointer.distanceY) > this.state.options.minDistance) {
                eventType = pointer.directionY == 'up' ? '$md.swipeup' : '$md.swipedown';
                this.dispatchEvent(ev, eventType);
              }
            }
          });
          function getTouchAction() {
            var testEl = document.createElement('div');
            var vendorPrefixes = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];
            for (var i = 0; i < vendorPrefixes.length; i++) {
              var prefix = vendorPrefixes[i];
              var property = prefix ? prefix + 'TouchAction' : 'touchAction';
              if (angular.isDefined(testEl.style[property])) {
                return property;
              }
            }
          }
        }
        MdGesture.$inject = ["$$MdGestureHandler", "$$rAF", "$timeout"];
        function GestureHandler(name) {
          this.name = name;
          this.state = {};
        }
        function MdGestureHandler() {
          var hasJQuery = (typeof window.jQuery !== 'undefined') && (angular.element === window.jQuery);
          GestureHandler.prototype = {
            options: {},
            dispatchEvent: hasJQuery ? jQueryDispatchEvent : nativeDispatchEvent,
            onSetup: angular.noop,
            onCleanup: angular.noop,
            onStart: angular.noop,
            onMove: angular.noop,
            onEnd: angular.noop,
            onCancel: angular.noop,
            start: function(ev, pointer) {
              if (this.state.isRunning)
                return;
              var parentTarget = this.getNearestParent(ev.target);
              var parentTargetOptions = parentTarget && parentTarget.$mdGesture[this.name] || {};
              this.state = {
                isRunning: true,
                options: angular.extend({}, this.options, parentTargetOptions),
                registeredParent: parentTarget
              };
              this.onStart(ev, pointer);
            },
            move: function(ev, pointer) {
              if (!this.state.isRunning)
                return;
              this.onMove(ev, pointer);
            },
            end: function(ev, pointer) {
              if (!this.state.isRunning)
                return;
              this.onEnd(ev, pointer);
              this.state.isRunning = false;
            },
            cancel: function(ev, pointer) {
              this.onCancel(ev, pointer);
              this.state = {};
            },
            getNearestParent: function(node) {
              var current = node;
              while (current) {
                if ((current.$mdGesture || {})[this.name]) {
                  return current;
                }
                current = current.parentNode;
              }
              return null;
            },
            registerElement: function(element, options) {
              var self = this;
              element[0].$mdGesture = element[0].$mdGesture || {};
              element[0].$mdGesture[this.name] = options || {};
              element.on('$destroy', onDestroy);
              self.onSetup(element, options || {});
              return onDestroy;
              function onDestroy() {
                delete element[0].$mdGesture[self.name];
                element.off('$destroy', onDestroy);
                self.onCleanup(element, options || {});
              }
            }
          };
          return GestureHandler;
          function jQueryDispatchEvent(srcEvent, eventType, eventPointer) {
            eventPointer = eventPointer || pointer;
            var eventObj = new angular.element.Event(eventType);
            eventObj.$material = true;
            eventObj.pointer = eventPointer;
            eventObj.srcEvent = srcEvent;
            angular.extend(eventObj, {
              clientX: eventPointer.x,
              clientY: eventPointer.y,
              screenX: eventPointer.x,
              screenY: eventPointer.y,
              pageX: eventPointer.x,
              pageY: eventPointer.y,
              ctrlKey: srcEvent.ctrlKey,
              altKey: srcEvent.altKey,
              shiftKey: srcEvent.shiftKey,
              metaKey: srcEvent.metaKey
            });
            angular.element(eventPointer.target).trigger(eventObj);
          }
          function nativeDispatchEvent(srcEvent, eventType, eventPointer) {
            eventPointer = eventPointer || pointer;
            var eventObj;
            if (eventType === 'click' || eventType == 'mouseup' || eventType == 'mousedown') {
              eventObj = document.createEvent('MouseEvents');
              eventObj.initMouseEvent(eventType, true, true, window, srcEvent.detail, eventPointer.x, eventPointer.y, eventPointer.x, eventPointer.y, srcEvent.ctrlKey, srcEvent.altKey, srcEvent.shiftKey, srcEvent.metaKey, srcEvent.button, srcEvent.relatedTarget || null);
            } else {
              eventObj = document.createEvent('CustomEvent');
              eventObj.initCustomEvent(eventType, true, true, {});
            }
            eventObj.$material = true;
            eventObj.pointer = eventPointer;
            eventObj.srcEvent = srcEvent;
            eventPointer.target.dispatchEvent(eventObj);
          }
        }
        function attachToDocument($mdGesture, $$MdGestureHandler) {
          document.contains || (document.contains = function(node) {
            return document.body.contains(node);
          });
          if (!isInitialized && $mdGesture.isHijackingClicks) {
            document.addEventListener('click', clickHijacker, true);
            document.addEventListener('mouseup', mouseInputHijacker, true);
            document.addEventListener('mousedown', mouseInputHijacker, true);
            document.addEventListener('focus', mouseInputHijacker, true);
            isInitialized = true;
          }
          function mouseInputHijacker(ev) {
            var isKeyClick = !ev.clientX && !ev.clientY;
            if (!isKeyClick && !ev.$material && !ev.isIonicTap && !isInputEventFromLabelClick(ev)) {
              ev.preventDefault();
              ev.stopPropagation();
            }
          }
          function clickHijacker(ev) {
            var isKeyClick = ev.clientX === 0 && ev.clientY === 0;
            if (!isKeyClick && !ev.$material && !ev.isIonicTap && !isInputEventFromLabelClick(ev)) {
              ev.preventDefault();
              ev.stopPropagation();
              lastLabelClickPos = null;
            } else {
              lastLabelClickPos = null;
              if (ev.target.tagName.toLowerCase() == 'label') {
                lastLabelClickPos = {
                  x: ev.x,
                  y: ev.y
                };
              }
            }
          }
          var START_EVENTS = 'mousedown touchstart pointerdown';
          var MOVE_EVENTS = 'mousemove touchmove pointermove';
          var END_EVENTS = 'mouseup mouseleave touchend touchcancel pointerup pointercancel';
          angular.element(document).on(START_EVENTS, gestureStart).on(MOVE_EVENTS, gestureMove).on(END_EVENTS, gestureEnd).on('$$mdGestureReset', function gestureClearCache() {
            lastPointer = pointer = null;
          });
          function runHandlers(handlerEvent, event) {
            var handler;
            for (var name in HANDLERS) {
              handler = HANDLERS[name];
              if (handler instanceof $$MdGestureHandler) {
                if (handlerEvent === 'start') {
                  handler.cancel();
                }
                handler[handlerEvent](event, pointer);
              }
            }
          }
          function gestureStart(ev) {
            if (pointer)
              return;
            var now = +Date.now();
            if (lastPointer && !typesMatch(ev, lastPointer) && (now - lastPointer.endTime < 1500)) {
              return;
            }
            pointer = makeStartPointer(ev);
            runHandlers('start', ev);
          }
          function gestureMove(ev) {
            if (!pointer || !typesMatch(ev, pointer))
              return;
            updatePointerState(ev, pointer);
            runHandlers('move', ev);
          }
          function gestureEnd(ev) {
            if (!pointer || !typesMatch(ev, pointer))
              return;
            updatePointerState(ev, pointer);
            pointer.endTime = +Date.now();
            runHandlers('end', ev);
            lastPointer = pointer;
            pointer = null;
          }
        }
        attachToDocument.$inject = ["$mdGesture", "$$MdGestureHandler"];
        function makeStartPointer(ev) {
          var point = getEventPoint(ev);
          var startPointer = {
            startTime: +Date.now(),
            target: ev.target,
            type: ev.type.charAt(0)
          };
          startPointer.startX = startPointer.x = point.pageX;
          startPointer.startY = startPointer.y = point.pageY;
          return startPointer;
        }
        function typesMatch(ev, pointer) {
          return ev && pointer && ev.type.charAt(0) === pointer.type;
        }
        function isInputEventFromLabelClick(event) {
          return lastLabelClickPos && lastLabelClickPos.x == event.x && lastLabelClickPos.y == event.y;
        }
        function updatePointerState(ev, pointer) {
          var point = getEventPoint(ev);
          var x = pointer.x = point.pageX;
          var y = pointer.y = point.pageY;
          pointer.distanceX = x - pointer.startX;
          pointer.distanceY = y - pointer.startY;
          pointer.distance = Math.sqrt(pointer.distanceX * pointer.distanceX + pointer.distanceY * pointer.distanceY);
          pointer.directionX = pointer.distanceX > 0 ? 'right' : pointer.distanceX < 0 ? 'left' : '';
          pointer.directionY = pointer.distanceY > 0 ? 'down' : pointer.distanceY < 0 ? 'up' : '';
          pointer.duration = +Date.now() - pointer.startTime;
          pointer.velocityX = pointer.distanceX / pointer.duration;
          pointer.velocityY = pointer.distanceY / pointer.duration;
        }
        function getEventPoint(ev) {
          ev = ev.originalEvent || ev;
          return (ev.touches && ev.touches[0]) || (ev.changedTouches && ev.changedTouches[0]) || ev;
        }
      })();
      (function() {
        "use strict";
        angular.module('material.core').provider('$$interimElement', InterimElementProvider);
        function InterimElementProvider() {
          createInterimElementProvider.$get = InterimElementFactory;
          InterimElementFactory.$inject = ["$document", "$q", "$$q", "$rootScope", "$timeout", "$rootElement", "$animate", "$mdUtil", "$mdCompiler", "$mdTheming", "$injector"];
          return createInterimElementProvider;
          function createInterimElementProvider(interimFactoryName) {
            var EXPOSED_METHODS = ['onHide', 'onShow', 'onRemove'];
            var customMethods = {};
            var providerConfig = {presets: {}};
            var provider = {
              setDefaults: setDefaults,
              addPreset: addPreset,
              addMethod: addMethod,
              $get: factory
            };
            provider.addPreset('build', {methods: ['controller', 'controllerAs', 'resolve', 'template', 'templateUrl', 'themable', 'transformTemplate', 'parent']});
            factory.$inject = ["$$interimElement", "$injector"];
            return provider;
            function setDefaults(definition) {
              providerConfig.optionsFactory = definition.options;
              providerConfig.methods = (definition.methods || []).concat(EXPOSED_METHODS);
              return provider;
            }
            function addMethod(name, fn) {
              customMethods[name] = fn;
              return provider;
            }
            function addPreset(name, definition) {
              definition = definition || {};
              definition.methods = definition.methods || [];
              definition.options = definition.options || function() {
                return {};
              };
              if (/^cancel|hide|show$/.test(name)) {
                throw new Error("Preset '" + name + "' in " + interimFactoryName + " is reserved!");
              }
              if (definition.methods.indexOf('_options') > -1) {
                throw new Error("Method '_options' in " + interimFactoryName + " is reserved!");
              }
              providerConfig.presets[name] = {
                methods: definition.methods.concat(EXPOSED_METHODS),
                optionsFactory: definition.options,
                argOption: definition.argOption
              };
              return provider;
            }
            function addPresetMethod(presetName, methodName, method) {
              providerConfig.presets[presetName][methodName] = method;
            }
            function factory($$interimElement, $injector) {
              var defaultMethods;
              var defaultOptions;
              var interimElementService = $$interimElement();
              var publicService = {
                hide: interimElementService.hide,
                cancel: interimElementService.cancel,
                show: showInterimElement,
                destroy: destroyInterimElement
              };
              defaultMethods = providerConfig.methods || [];
              defaultOptions = invokeFactory(providerConfig.optionsFactory, {});
              angular.forEach(customMethods, function(fn, name) {
                publicService[name] = fn;
              });
              angular.forEach(providerConfig.presets, function(definition, name) {
                var presetDefaults = invokeFactory(definition.optionsFactory, {});
                var presetMethods = (definition.methods || []).concat(defaultMethods);
                angular.extend(presetDefaults, {$type: name});
                function Preset(opts) {
                  this._options = angular.extend({}, presetDefaults, opts);
                }
                angular.forEach(presetMethods, function(name) {
                  Preset.prototype[name] = function(value) {
                    this._options[name] = value;
                    return this;
                  };
                });
                if (definition.argOption) {
                  var methodName = 'show' + name.charAt(0).toUpperCase() + name.slice(1);
                  publicService[methodName] = function(arg) {
                    var config = publicService[name](arg);
                    return publicService.show(config);
                  };
                }
                publicService[name] = function(arg) {
                  if (arguments.length && definition.argOption && !angular.isObject(arg) && !angular.isArray(arg)) {
                    return (new Preset())[definition.argOption](arg);
                  } else {
                    return new Preset(arg);
                  }
                };
              });
              return publicService;
              function showInterimElement(opts) {
                opts = opts || {};
                if (opts._options)
                  opts = opts._options;
                return interimElementService.show(angular.extend({}, defaultOptions, opts));
              }
              function destroyInterimElement(opts) {
                return interimElementService.destroy(opts);
              }
              function invokeFactory(factory, defaultVal) {
                var locals = {};
                locals[interimFactoryName] = publicService;
                return $injector.invoke(factory || function() {
                  return defaultVal;
                }, {}, locals);
              }
            }
          }
          function InterimElementFactory($document, $q, $$q, $rootScope, $timeout, $rootElement, $animate, $mdUtil, $mdCompiler, $mdTheming, $injector) {
            return function createInterimElementService() {
              var SHOW_CANCELLED = false;
              var service,
                  stack = [];
              return service = {
                show: show,
                hide: hide,
                cancel: cancel,
                destroy: destroy,
                $injector_: $injector
              };
              function show(options) {
                options = options || {};
                var interimElement = new InterimElement(options || {});
                var hideExisting = !options.skipHide && stack.length ? service.cancel() : $q.when(true);
                hideExisting.finally(function() {
                  stack.push(interimElement);
                  interimElement.show().catch(function(reason) {
                    return reason;
                  });
                });
                return interimElement.deferred.promise;
              }
              function hide(reason, options) {
                if (!stack.length)
                  return $q.when(reason);
                options = options || {};
                if (options.closeAll) {
                  var promise = $q.all(stack.reverse().map(closeElement));
                  stack = [];
                  return promise;
                } else if (options.closeTo !== undefined) {
                  return $q.all(stack.splice(options.closeTo).map(closeElement));
                } else {
                  var interim = stack.pop();
                  return closeElement(interim);
                }
                function closeElement(interim) {
                  interim.remove(reason, false, options || {}).catch(function(reason) {
                    return reason;
                  });
                  return interim.deferred.promise;
                }
              }
              function cancel(reason, options) {
                var interim = stack.pop();
                if (!interim)
                  return $q.when(reason);
                interim.remove(reason, true, options || {}).catch(function(reason) {
                  return reason;
                });
                return interim.deferred.promise.catch(angular.noop);
              }
              function destroy(target) {
                var interim = !target ? stack.shift() : null;
                var cntr = angular.element(target).length ? angular.element(target)[0].parentNode : null;
                if (cntr) {
                  var filtered = stack.filter(function(entry) {
                    var currNode = entry.options.element[0];
                    return (currNode === cntr);
                  });
                  if (filtered.length > 0) {
                    interim = filtered[0];
                    stack.splice(stack.indexOf(interim), 1);
                  }
                }
                return interim ? interim.remove(SHOW_CANCELLED, false, {'$destroy': true}) : $q.when(SHOW_CANCELLED);
              }
              function InterimElement(options) {
                var self,
                    element,
                    showAction = $q.when(true);
                options = configureScopeAndTransitions(options);
                return self = {
                  options: options,
                  deferred: $q.defer(),
                  show: createAndTransitionIn,
                  remove: transitionOutAndRemove
                };
                function createAndTransitionIn() {
                  return $q(function(resolve, reject) {
                    options.onCompiling && options.onCompiling(options);
                    compileElement(options).then(function(compiledData) {
                      element = linkElement(compiledData, options);
                      showAction = showElement(element, options, compiledData.controller).then(resolve, rejectAll);
                    }, rejectAll);
                    function rejectAll(fault) {
                      self.deferred.reject(fault);
                      reject(fault);
                    }
                  });
                }
                function transitionOutAndRemove(response, isCancelled, opts) {
                  if (!element)
                    return $q.when(false);
                  options = angular.extend(options || {}, opts || {});
                  options.cancelAutoHide && options.cancelAutoHide();
                  options.element.triggerHandler('$mdInterimElementRemove');
                  if (options.$destroy === true) {
                    return hideElement(options.element, options).then(function() {
                      (isCancelled && rejectAll(response)) || resolveAll(response);
                    });
                  } else {
                    $q.when(showAction).finally(function() {
                      hideElement(options.element, options).then(function() {
                        (isCancelled && rejectAll(response)) || resolveAll(response);
                      }, rejectAll);
                    });
                    return self.deferred.promise;
                  }
                  function resolveAll(response) {
                    self.deferred.resolve(response);
                  }
                  function rejectAll(fault) {
                    self.deferred.reject(fault);
                  }
                }
                function configureScopeAndTransitions(options) {
                  options = options || {};
                  if (options.template) {
                    options.template = $mdUtil.processTemplate(options.template);
                  }
                  return angular.extend({
                    preserveScope: false,
                    cancelAutoHide: angular.noop,
                    scope: options.scope || $rootScope.$new(options.isolateScope),
                    onShow: function transitionIn(scope, element, options) {
                      return $animate.enter(element, options.parent);
                    },
                    onRemove: function transitionOut(scope, element) {
                      return element && $animate.leave(element) || $q.when();
                    }
                  }, options);
                }
                function compileElement(options) {
                  var compiled = !options.skipCompile ? $mdCompiler.compile(options) : null;
                  return compiled || $q(function(resolve) {
                    resolve({
                      locals: {},
                      link: function() {
                        return options.element;
                      }
                    });
                  });
                }
                function linkElement(compileData, options) {
                  angular.extend(compileData.locals, options);
                  var element = compileData.link(options.scope);
                  options.element = element;
                  options.parent = findParent(element, options);
                  if (options.themable)
                    $mdTheming(element);
                  return element;
                }
                function findParent(element, options) {
                  var parent = options.parent;
                  if (angular.isFunction(parent)) {
                    parent = parent(options.scope, element, options);
                  } else if (angular.isString(parent)) {
                    parent = angular.element($document[0].querySelector(parent));
                  } else {
                    parent = angular.element(parent);
                  }
                  if (!(parent || {}).length) {
                    var el;
                    if ($rootElement[0] && $rootElement[0].querySelector) {
                      el = $rootElement[0].querySelector(':not(svg) > body');
                    }
                    if (!el)
                      el = $rootElement[0];
                    if (el.nodeName == '#comment') {
                      el = $document[0].body;
                    }
                    return angular.element(el);
                  }
                  return parent;
                }
                function startAutoHide() {
                  var autoHideTimer,
                      cancelAutoHide = angular.noop;
                  if (options.hideDelay) {
                    autoHideTimer = $timeout(service.hide, options.hideDelay);
                    cancelAutoHide = function() {
                      $timeout.cancel(autoHideTimer);
                    };
                  }
                  options.cancelAutoHide = function() {
                    cancelAutoHide();
                    options.cancelAutoHide = undefined;
                  };
                }
                function showElement(element, options, controller) {
                  var notifyShowing = options.onShowing || angular.noop;
                  var notifyComplete = options.onComplete || angular.noop;
                  notifyShowing(options.scope, element, options, controller);
                  return $q(function(resolve, reject) {
                    try {
                      $q.when(options.onShow(options.scope, element, options, controller)).then(function() {
                        notifyComplete(options.scope, element, options);
                        startAutoHide();
                        resolve(element);
                      }, reject);
                    } catch (e) {
                      reject(e.message);
                    }
                  });
                }
                function hideElement(element, options) {
                  var announceRemoving = options.onRemoving || angular.noop;
                  return $$q(function(resolve, reject) {
                    try {
                      var action = $$q.when(options.onRemove(options.scope, element, options) || true);
                      announceRemoving(element, action);
                      if (options.$destroy == true) {
                        resolve(element);
                      } else {
                        action.then(function() {
                          if (!options.preserveScope && options.scope) {
                            options.scope.$destroy();
                          }
                          resolve(element);
                        }, reject);
                      }
                    } catch (e) {
                      reject(e);
                    }
                  });
                }
              }
            };
          }
        }
      })();
      (function() {
        "use strict";
        (function() {
          'use strict';
          var $mdUtil,
              $interpolate,
              $log;
          var SUFFIXES = /(-gt)?-(sm|md|lg|print)/g;
          var WHITESPACE = /\s+/g;
          var FLEX_OPTIONS = ['grow', 'initial', 'auto', 'none', 'noshrink', 'nogrow'];
          var LAYOUT_OPTIONS = ['row', 'column'];
          var ALIGNMENT_MAIN_AXIS = ["", "start", "center", "end", "stretch", "space-around", "space-between"];
          var ALIGNMENT_CROSS_AXIS = ["", "start", "center", "end", "stretch"];
          var config = {
            enabled: true,
            breakpoints: []
          };
          registerLayoutAPI(angular.module('material.core.layout', ['ng']));
          function registerLayoutAPI(module) {
            var PREFIX_REGEXP = /^((?:x|data)[\:\-_])/i;
            var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
            var BREAKPOINTS = ["", "xs", "gt-xs", "sm", "gt-sm", "md", "gt-md", "lg", "gt-lg", "xl", "print"];
            var API_WITH_VALUES = ["layout", "flex", "flex-order", "flex-offset", "layout-align"];
            var API_NO_VALUES = ["show", "hide", "layout-padding", "layout-margin"];
            angular.forEach(BREAKPOINTS, function(mqb) {
              angular.forEach(API_WITH_VALUES, function(name) {
                var fullName = mqb ? name + "-" + mqb : name;
                module.directive(directiveNormalize(fullName), attributeWithObserve(fullName));
              });
              angular.forEach(API_NO_VALUES, function(name) {
                var fullName = mqb ? name + "-" + mqb : name;
                module.directive(directiveNormalize(fullName), attributeWithoutValue(fullName));
              });
            });
            module.directive('mdLayoutCss', disableLayoutDirective).directive('ngCloak', buildCloakInterceptor('ng-cloak')).directive('layoutWrap', attributeWithoutValue('layout-wrap')).directive('layoutNowrap', attributeWithoutValue('layout-nowrap')).directive('layoutNoWrap', attributeWithoutValue('layout-no-wrap')).directive('layoutFill', attributeWithoutValue('layout-fill')).directive('layoutLtMd', warnAttrNotSupported('layout-lt-md', true)).directive('layoutLtLg', warnAttrNotSupported('layout-lt-lg', true)).directive('flexLtMd', warnAttrNotSupported('flex-lt-md', true)).directive('flexLtLg', warnAttrNotSupported('flex-lt-lg', true)).directive('layoutAlignLtMd', warnAttrNotSupported('layout-align-lt-md')).directive('layoutAlignLtLg', warnAttrNotSupported('layout-align-lt-lg')).directive('flexOrderLtMd', warnAttrNotSupported('flex-order-lt-md')).directive('flexOrderLtLg', warnAttrNotSupported('flex-order-lt-lg')).directive('offsetLtMd', warnAttrNotSupported('flex-offset-lt-md')).directive('offsetLtLg', warnAttrNotSupported('flex-offset-lt-lg')).directive('hideLtMd', warnAttrNotSupported('hide-lt-md')).directive('hideLtLg', warnAttrNotSupported('hide-lt-lg')).directive('showLtMd', warnAttrNotSupported('show-lt-md')).directive('showLtLg', warnAttrNotSupported('show-lt-lg'));
            function directiveNormalize(name) {
              return name.replace(PREFIX_REGEXP, '').replace(SPECIAL_CHARS_REGEXP, function(_, separator, letter, offset) {
                return offset ? letter.toUpperCase() : letter;
              });
            }
          }
          function disableLayoutDirective() {
            return {
              restrict: 'A',
              priority: '900',
              compile: function(element, attr) {
                config.enabled = false;
                return angular.noop;
              }
            };
          }
          function buildCloakInterceptor(className) {
            return ['$timeout', function($timeout) {
              return {
                restrict: 'A',
                priority: -10,
                compile: function(element) {
                  if (!config.enabled)
                    return angular.noop;
                  element.addClass(className);
                  return function(scope, element) {
                    $timeout(function() {
                      element.removeClass(className);
                    }, 10, false);
                  };
                }
              };
            }];
          }
          function attributeWithObserve(className) {
            return ['$mdUtil', '$interpolate', "$log", function(_$mdUtil_, _$interpolate_, _$log_) {
              $mdUtil = _$mdUtil_;
              $interpolate = _$interpolate_;
              $log = _$log_;
              return {
                restrict: 'A',
                compile: function(element, attr) {
                  var linkFn;
                  if (config.enabled) {
                    validateAttributeUsage(className, attr, element, $log);
                    validateAttributeValue(className, getNormalizedAttrValue(className, attr, ""), buildUpdateFn(element, className, attr));
                    linkFn = translateWithValueToCssClass;
                  }
                  return linkFn || angular.noop;
                }
              };
            }];
            function translateWithValueToCssClass(scope, element, attrs) {
              var updateFn = updateClassWithValue(element, className, attrs);
              var unwatch = attrs.$observe(attrs.$normalize(className), updateFn);
              updateFn(getNormalizedAttrValue(className, attrs, ""));
              scope.$on("$destroy", function() {
                unwatch();
              });
            }
          }
          function attributeWithoutValue(className) {
            return ['$mdUtil', '$interpolate', "$log", function(_$mdUtil_, _$interpolate_, _$log_) {
              $mdUtil = _$mdUtil_;
              $interpolate = _$interpolate_;
              $log = _$log_;
              return {
                restrict: 'A',
                compile: function(element, attr) {
                  var linkFn;
                  if (config.enabled) {
                    validateAttributeValue(className, getNormalizedAttrValue(className, attr, ""), buildUpdateFn(element, className, attr));
                    translateToCssClass(null, element);
                    linkFn = translateToCssClass;
                  }
                  return linkFn || angular.noop;
                }
              };
            }];
            function translateToCssClass(scope, element) {
              element.addClass(className);
            }
          }
          function updateClassWithValue(element, className) {
            var lastClass;
            return function updateClassFn(newValue) {
              var value = validateAttributeValue(className, newValue || "");
              if (angular.isDefined(value)) {
                if (lastClass)
                  element.removeClass(lastClass);
                lastClass = !value ? className : className + "-" + value.replace(WHITESPACE, "-");
                element.addClass(lastClass);
              }
            };
          }
          function warnAttrNotSupported(className) {
            var parts = className.split("-");
            return ["$log", function($log) {
              $log.warn(className + "has been deprecated. Please use a `" + parts[0] + "-gt-<xxx>` variant.");
              return angular.noop;
            }];
          }
          function validateAttributeUsage(className, attr, element, $log) {
            var message,
                usage,
                url;
            var nodeName = element[0].nodeName.toLowerCase();
            switch (className.replace(SUFFIXES, "")) {
              case "flex":
                if ((nodeName == "md-button") || (nodeName == "fieldset")) {
                  usage = "<" + nodeName + " " + className + "></" + nodeName + ">";
                  url = "https://github.com/philipwalton/flexbugs#9-some-html-elements-cant-be-flex-containers";
                  message = "Markup '{0}' may not work as expected in IE Browsers. Consult '{1}' for details.";
                  $log.warn($mdUtil.supplant(message, [usage, url]));
                }
            }
          }
          function validateAttributeValue(className, value, updateFn) {
            var origValue = value;
            if (!needsInterpolation(value)) {
              switch (className.replace(SUFFIXES, "")) {
                case 'layout':
                  if (!findIn(value, LAYOUT_OPTIONS)) {
                    value = LAYOUT_OPTIONS[0];
                  }
                  break;
                case 'flex':
                  if (!findIn(value, FLEX_OPTIONS)) {
                    if (isNaN(value)) {
                      value = '';
                    }
                  }
                  break;
                case 'flex-offset':
                case 'flex-order':
                  if (!value || isNaN(+value)) {
                    value = '0';
                  }
                  break;
                case 'layout-align':
                  var axis = extractAlignAxis(value);
                  value = $mdUtil.supplant("{main}-{cross}", axis);
                  break;
                case 'layout-padding':
                case 'layout-margin':
                case 'layout-fill':
                case 'layout-wrap':
                case 'layout-nowrap':
                case 'layout-nowrap':
                  value = '';
                  break;
              }
              if (value != origValue) {
                (updateFn || angular.noop)(value);
              }
            }
            return value;
          }
          function buildUpdateFn(element, className, attrs) {
            return function updateAttrValue(fallback) {
              if (!needsInterpolation(fallback)) {
                attrs[attrs.$normalize(className)] = fallback;
              }
            };
          }
          function needsInterpolation(value) {
            return (value || "").indexOf($interpolate.startSymbol()) > -1;
          }
          function getNormalizedAttrValue(className, attrs, defaultVal) {
            var normalizedAttr = attrs.$normalize(className);
            return attrs[normalizedAttr] ? attrs[normalizedAttr].replace(WHITESPACE, "-") : defaultVal || null;
          }
          function findIn(item, list, replaceWith) {
            item = replaceWith && item ? item.replace(WHITESPACE, replaceWith) : item;
            var found = false;
            if (item) {
              list.forEach(function(it) {
                it = replaceWith ? it.replace(WHITESPACE, replaceWith) : it;
                found = found || (it === item);
              });
            }
            return found;
          }
          function extractAlignAxis(attrValue) {
            var axis = {
              main: "start",
              cross: "stretch"
            },
                values;
            attrValue = (attrValue || "");
            if (attrValue.indexOf("-") == 0 || attrValue.indexOf(" ") == 0) {
              attrValue = "none" + attrValue;
            }
            values = attrValue.toLowerCase().trim().replace(WHITESPACE, "-").split("-");
            if (values.length && (values[0] === "space")) {
              values = [values[0] + "-" + values[1], values[2]];
            }
            if (values.length > 0)
              axis.main = values[0] || axis.main;
            if (values.length > 1)
              axis.cross = values[1] || axis.cross;
            if (ALIGNMENT_MAIN_AXIS.indexOf(axis.main) < 0)
              axis.main = "start";
            if (ALIGNMENT_CROSS_AXIS.indexOf(axis.cross) < 0)
              axis.cross = "stretch";
            return axis;
          }
        })();
      })();
      (function() {
        "use strict";
        angular.module('material.core').factory('$mdComponentRegistry', ComponentRegistry);
        function ComponentRegistry($log, $q) {
          var self;
          var instances = [];
          var pendings = {};
          return self = {
            notFoundError: function(handle, msgContext) {
              $log.error((msgContext || "") + 'No instance found for handle', handle);
            },
            getInstances: function() {
              return instances;
            },
            get: function(handle) {
              if (!isValidID(handle))
                return null;
              var i,
                  j,
                  instance;
              for (i = 0, j = instances.length; i < j; i++) {
                instance = instances[i];
                if (instance.$$mdHandle === handle) {
                  return instance;
                }
              }
              return null;
            },
            register: function(instance, handle) {
              if (!handle)
                return angular.noop;
              instance.$$mdHandle = handle;
              instances.push(instance);
              resolveWhen();
              return deregister;
              function deregister() {
                var index = instances.indexOf(instance);
                if (index !== -1) {
                  instances.splice(index, 1);
                }
              }
              function resolveWhen() {
                var dfd = pendings[handle];
                if (dfd) {
                  dfd.forEach(function(promise) {
                    promise.resolve(instance);
                  });
                  delete pendings[handle];
                }
              }
            },
            when: function(handle) {
              if (isValidID(handle)) {
                var deferred = $q.defer();
                var instance = self.get(handle);
                if (instance) {
                  deferred.resolve(instance);
                } else {
                  if (pendings[handle] === undefined) {
                    pendings[handle] = [];
                  }
                  pendings[handle].push(deferred);
                }
                return deferred.promise;
              }
              return $q.reject("Invalid `md-component-id` value.");
            }
          };
          function isValidID(handle) {
            return handle && (handle !== "");
          }
        }
        ComponentRegistry.$inject = ["$log", "$q"];
      })();
      (function() {
        "use strict";
        (function() {
          'use strict';
          angular.module('material.core').factory('$mdButtonInkRipple', MdButtonInkRipple);
          function MdButtonInkRipple($mdInkRipple) {
            return {attach: function attachRipple(scope, element, options) {
                options = angular.extend(optionsForElement(element), options);
                return $mdInkRipple.attach(scope, element, options);
              }};
            function optionsForElement(element) {
              if (element.hasClass('md-icon-button')) {
                return {
                  isMenuItem: element.hasClass('md-menu-item'),
                  fitRipple: true,
                  center: true
                };
              } else {
                return {
                  isMenuItem: element.hasClass('md-menu-item'),
                  dimBackground: true
                };
              }
            }
            ;
          }
          MdButtonInkRipple.$inject = ["$mdInkRipple"];
          ;
        })();
      })();
      (function() {
        "use strict";
        (function() {
          'use strict';
          angular.module('material.core').factory('$mdCheckboxInkRipple', MdCheckboxInkRipple);
          function MdCheckboxInkRipple($mdInkRipple) {
            return {attach: attach};
            function attach(scope, element, options) {
              return $mdInkRipple.attach(scope, element, angular.extend({
                center: true,
                dimBackground: false,
                fitRipple: true
              }, options));
            }
            ;
          }
          MdCheckboxInkRipple.$inject = ["$mdInkRipple"];
          ;
        })();
      })();
      (function() {
        "use strict";
        (function() {
          'use strict';
          angular.module('material.core').factory('$mdListInkRipple', MdListInkRipple);
          function MdListInkRipple($mdInkRipple) {
            return {attach: attach};
            function attach(scope, element, options) {
              return $mdInkRipple.attach(scope, element, angular.extend({
                center: false,
                dimBackground: true,
                outline: false,
                rippleSize: 'full'
              }, options));
            }
            ;
          }
          MdListInkRipple.$inject = ["$mdInkRipple"];
          ;
        })();
      })();
      (function() {
        "use strict";
        angular.module('material.core').provider('$mdInkRipple', InkRippleProvider).directive('mdInkRipple', InkRippleDirective).directive('mdNoInk', attrNoDirective).directive('mdNoBar', attrNoDirective).directive('mdNoStretch', attrNoDirective);
        var DURATION = 450;
        function InkRippleDirective($mdButtonInkRipple, $mdCheckboxInkRipple) {
          return {
            controller: angular.noop,
            link: function(scope, element, attr) {
              attr.hasOwnProperty('mdInkRippleCheckbox') ? $mdCheckboxInkRipple.attach(scope, element) : $mdButtonInkRipple.attach(scope, element);
            }
          };
        }
        InkRippleDirective.$inject = ["$mdButtonInkRipple", "$mdCheckboxInkRipple"];
        function InkRippleProvider() {
          var isDisabledGlobally = false;
          return {
            disableInkRipple: disableInkRipple,
            $get: ["$injector", function($injector) {
              return {attach: attach};
              function attach(scope, element, options) {
                if (isDisabledGlobally || element.controller('mdNoInk'))
                  return angular.noop;
                return $injector.instantiate(InkRippleCtrl, {
                  $scope: scope,
                  $element: element,
                  rippleOptions: options
                });
              }
            }]
          };
          function disableInkRipple() {
            isDisabledGlobally = true;
          }
        }
        function InkRippleCtrl($scope, $element, rippleOptions, $window, $timeout, $mdUtil, $mdColorUtil) {
          this.$window = $window;
          this.$timeout = $timeout;
          this.$mdUtil = $mdUtil;
          this.$mdColorUtil = $mdColorUtil;
          this.$scope = $scope;
          this.$element = $element;
          this.options = rippleOptions;
          this.mousedown = false;
          this.ripples = [];
          this.timeout = null;
          this.lastRipple = null;
          $mdUtil.valueOnUse(this, 'container', this.createContainer);
          this.$element.addClass('md-ink-ripple');
          ($element.controller('mdInkRipple') || {}).createRipple = angular.bind(this, this.createRipple);
          ($element.controller('mdInkRipple') || {}).setColor = angular.bind(this, this.color);
          this.bindEvents();
        }
        InkRippleCtrl.$inject = ["$scope", "$element", "rippleOptions", "$window", "$timeout", "$mdUtil", "$mdColorUtil"];
        function autoCleanup(self, cleanupFn) {
          if (self.mousedown || self.lastRipple) {
            self.mousedown = false;
            self.$mdUtil.nextTick(angular.bind(self, cleanupFn), false);
          }
        }
        InkRippleCtrl.prototype.color = function(value) {
          var self = this;
          if (angular.isDefined(value)) {
            self._color = self._parseColor(value);
          }
          return self._color || self._parseColor(self.inkRipple()) || self._parseColor(getElementColor());
          function getElementColor() {
            var items = self.options && self.options.colorElement ? self.options.colorElement : [];
            var elem = items.length ? items[0] : self.$element[0];
            return elem ? self.$window.getComputedStyle(elem).color : 'rgb(0,0,0)';
          }
        };
        InkRippleCtrl.prototype.calculateColor = function() {
          return this.color();
        };
        InkRippleCtrl.prototype._parseColor = function parseColor(color, multiplier) {
          multiplier = multiplier || 1;
          var colorUtil = this.$mdColorUtil;
          if (!color)
            return;
          if (color.indexOf('rgba') === 0)
            return color.replace(/\d?\.?\d*\s*\)\s*$/, (0.1 * multiplier).toString() + ')');
          if (color.indexOf('rgb') === 0)
            return colorUtil.rgbToRgba(color);
          if (color.indexOf('#') === 0)
            return colorUtil.hexToRgba(color);
        };
        InkRippleCtrl.prototype.bindEvents = function() {
          this.$element.on('mousedown', angular.bind(this, this.handleMousedown));
          this.$element.on('mouseup touchend', angular.bind(this, this.handleMouseup));
          this.$element.on('mouseleave', angular.bind(this, this.handleMouseup));
          this.$element.on('touchmove', angular.bind(this, this.handleTouchmove));
        };
        InkRippleCtrl.prototype.handleMousedown = function(event) {
          if (this.mousedown)
            return;
          if (event.hasOwnProperty('originalEvent'))
            event = event.originalEvent;
          this.mousedown = true;
          if (this.options.center) {
            this.createRipple(this.container.prop('clientWidth') / 2, this.container.prop('clientWidth') / 2);
          } else {
            if (event.srcElement !== this.$element[0]) {
              var layerRect = this.$element[0].getBoundingClientRect();
              var layerX = event.clientX - layerRect.left;
              var layerY = event.clientY - layerRect.top;
              this.createRipple(layerX, layerY);
            } else {
              this.createRipple(event.offsetX, event.offsetY);
            }
          }
        };
        InkRippleCtrl.prototype.handleMouseup = function() {
          autoCleanup(this, this.clearRipples);
        };
        InkRippleCtrl.prototype.handleTouchmove = function() {
          autoCleanup(this, this.deleteRipples);
        };
        InkRippleCtrl.prototype.deleteRipples = function() {
          for (var i = 0; i < this.ripples.length; i++) {
            this.ripples[i].remove();
          }
        };
        InkRippleCtrl.prototype.clearRipples = function() {
          for (var i = 0; i < this.ripples.length; i++) {
            this.fadeInComplete(this.ripples[i]);
          }
        };
        InkRippleCtrl.prototype.createContainer = function() {
          var container = angular.element('<div class="md-ripple-container"></div>');
          this.$element.append(container);
          return container;
        };
        InkRippleCtrl.prototype.clearTimeout = function() {
          if (this.timeout) {
            this.$timeout.cancel(this.timeout);
            this.timeout = null;
          }
        };
        InkRippleCtrl.prototype.isRippleAllowed = function() {
          var element = this.$element[0];
          do {
            if (!element.tagName || element.tagName === 'BODY')
              break;
            if (element && angular.isFunction(element.hasAttribute)) {
              if (element.hasAttribute('disabled'))
                return false;
              if (this.inkRipple() === 'false' || this.inkRipple() === '0')
                return false;
            }
          } while (element = element.parentNode);
          return true;
        };
        InkRippleCtrl.prototype.inkRipple = function() {
          return this.$element.attr('md-ink-ripple');
        };
        InkRippleCtrl.prototype.createRipple = function(left, top) {
          if (!this.isRippleAllowed())
            return;
          var ctrl = this;
          var colorUtil = ctrl.$mdColorUtil;
          var ripple = angular.element('<div class="md-ripple"></div>');
          var width = this.$element.prop('clientWidth');
          var height = this.$element.prop('clientHeight');
          var x = Math.max(Math.abs(width - left), left) * 2;
          var y = Math.max(Math.abs(height - top), top) * 2;
          var size = getSize(this.options.fitRipple, x, y);
          var color = this.calculateColor();
          ripple.css({
            left: left + 'px',
            top: top + 'px',
            background: 'black',
            width: size + 'px',
            height: size + 'px',
            backgroundColor: colorUtil.rgbaToRgb(color),
            borderColor: colorUtil.rgbaToRgb(color)
          });
          this.lastRipple = ripple;
          this.clearTimeout();
          this.timeout = this.$timeout(function() {
            ctrl.clearTimeout();
            if (!ctrl.mousedown)
              ctrl.fadeInComplete(ripple);
          }, DURATION * 0.35, false);
          if (this.options.dimBackground)
            this.container.css({backgroundColor: color});
          this.container.append(ripple);
          this.ripples.push(ripple);
          ripple.addClass('md-ripple-placed');
          this.$mdUtil.nextTick(function() {
            ripple.addClass('md-ripple-scaled md-ripple-active');
            ctrl.$timeout(function() {
              ctrl.clearRipples();
            }, DURATION, false);
          }, false);
          function getSize(fit, x, y) {
            return fit ? Math.max(x, y) : Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
          }
        };
        InkRippleCtrl.prototype.fadeInComplete = function(ripple) {
          if (this.lastRipple === ripple) {
            if (!this.timeout && !this.mousedown) {
              this.removeRipple(ripple);
            }
          } else {
            this.removeRipple(ripple);
          }
        };
        InkRippleCtrl.prototype.removeRipple = function(ripple) {
          var ctrl = this;
          var index = this.ripples.indexOf(ripple);
          if (index < 0)
            return;
          this.ripples.splice(this.ripples.indexOf(ripple), 1);
          ripple.removeClass('md-ripple-active');
          ripple.addClass('md-ripple-remove');
          if (this.ripples.length === 0)
            this.container.css({backgroundColor: ''});
          this.$timeout(function() {
            ctrl.fadeOutComplete(ripple);
          }, DURATION, false);
        };
        InkRippleCtrl.prototype.fadeOutComplete = function(ripple) {
          ripple.remove();
          this.lastRipple = null;
        };
        function attrNoDirective() {
          return {controller: angular.noop};
        }
      })();
      (function() {
        "use strict";
        (function() {
          'use strict';
          angular.module('material.core').factory('$mdTabInkRipple', MdTabInkRipple);
          function MdTabInkRipple($mdInkRipple) {
            return {attach: attach};
            function attach(scope, element, options) {
              return $mdInkRipple.attach(scope, element, angular.extend({
                center: false,
                dimBackground: true,
                outline: false,
                rippleSize: 'full'
              }, options));
            }
            ;
          }
          MdTabInkRipple.$inject = ["$mdInkRipple"];
          ;
        })();
      })();
      (function() {
        "use strict";
        angular.module('material.core.theming.palette', []).constant('$mdColorPalette', {
          'red': {
            '50': '#ffebee',
            '100': '#ffcdd2',
            '200': '#ef9a9a',
            '300': '#e57373',
            '400': '#ef5350',
            '500': '#f44336',
            '600': '#e53935',
            '700': '#d32f2f',
            '800': '#c62828',
            '900': '#b71c1c',
            'A100': '#ff8a80',
            'A200': '#ff5252',
            'A400': '#ff1744',
            'A700': '#d50000',
            'contrastDefaultColor': 'light',
            'contrastDarkColors': '50 100 200 300 A100',
            'contrastStrongLightColors': '400 500 600 700 A200 A400 A700'
          },
          'pink': {
            '50': '#fce4ec',
            '100': '#f8bbd0',
            '200': '#f48fb1',
            '300': '#f06292',
            '400': '#ec407a',
            '500': '#e91e63',
            '600': '#d81b60',
            '700': '#c2185b',
            '800': '#ad1457',
            '900': '#880e4f',
            'A100': '#ff80ab',
            'A200': '#ff4081',
            'A400': '#f50057',
            'A700': '#c51162',
            'contrastDefaultColor': 'light',
            'contrastDarkColors': '50 100 200 A100',
            'contrastStrongLightColors': '500 600 A200 A400 A700'
          },
          'purple': {
            '50': '#f3e5f5',
            '100': '#e1bee7',
            '200': '#ce93d8',
            '300': '#ba68c8',
            '400': '#ab47bc',
            '500': '#9c27b0',
            '600': '#8e24aa',
            '700': '#7b1fa2',
            '800': '#6a1b9a',
            '900': '#4a148c',
            'A100': '#ea80fc',
            'A200': '#e040fb',
            'A400': '#d500f9',
            'A700': '#aa00ff',
            'contrastDefaultColor': 'light',
            'contrastDarkColors': '50 100 200 A100',
            'contrastStrongLightColors': '300 400 A200 A400 A700'
          },
          'deep-purple': {
            '50': '#ede7f6',
            '100': '#d1c4e9',
            '200': '#b39ddb',
            '300': '#9575cd',
            '400': '#7e57c2',
            '500': '#673ab7',
            '600': '#5e35b1',
            '700': '#512da8',
            '800': '#4527a0',
            '900': '#311b92',
            'A100': '#b388ff',
            'A200': '#7c4dff',
            'A400': '#651fff',
            'A700': '#6200ea',
            'contrastDefaultColor': 'light',
            'contrastDarkColors': '50 100 200 A100',
            'contrastStrongLightColors': '300 400 A200'
          },
          'indigo': {
            '50': '#e8eaf6',
            '100': '#c5cae9',
            '200': '#9fa8da',
            '300': '#7986cb',
            '400': '#5c6bc0',
            '500': '#3f51b5',
            '600': '#3949ab',
            '700': '#303f9f',
            '800': '#283593',
            '900': '#1a237e',
            'A100': '#8c9eff',
            'A200': '#536dfe',
            'A400': '#3d5afe',
            'A700': '#304ffe',
            'contrastDefaultColor': 'light',
            'contrastDarkColors': '50 100 200 A100',
            'contrastStrongLightColors': '300 400 A200 A400'
          },
          'blue': {
            '50': '#e3f2fd',
            '100': '#bbdefb',
            '200': '#90caf9',
            '300': '#64b5f6',
            '400': '#42a5f5',
            '500': '#2196f3',
            '600': '#1e88e5',
            '700': '#1976d2',
            '800': '#1565c0',
            '900': '#0d47a1',
            'A100': '#82b1ff',
            'A200': '#448aff',
            'A400': '#2979ff',
            'A700': '#2962ff',
            'contrastDefaultColor': 'light',
            'contrastDarkColors': '50 100 200 300 400 A100',
            'contrastStrongLightColors': '500 600 700 A200 A400 A700'
          },
          'light-blue': {
            '50': '#e1f5fe',
            '100': '#b3e5fc',
            '200': '#81d4fa',
            '300': '#4fc3f7',
            '400': '#29b6f6',
            '500': '#03a9f4',
            '600': '#039be5',
            '700': '#0288d1',
            '800': '#0277bd',
            '900': '#01579b',
            'A100': '#80d8ff',
            'A200': '#40c4ff',
            'A400': '#00b0ff',
            'A700': '#0091ea',
            'contrastDefaultColor': 'dark',
            'contrastLightColors': '600 700 800 900 A700',
            'contrastStrongLightColors': '600 700 800 A700'
          },
          'cyan': {
            '50': '#e0f7fa',
            '100': '#b2ebf2',
            '200': '#80deea',
            '300': '#4dd0e1',
            '400': '#26c6da',
            '500': '#00bcd4',
            '600': '#00acc1',
            '700': '#0097a7',
            '800': '#00838f',
            '900': '#006064',
            'A100': '#84ffff',
            'A200': '#18ffff',
            'A400': '#00e5ff',
            'A700': '#00b8d4',
            'contrastDefaultColor': 'dark',
            'contrastLightColors': '700 800 900',
            'contrastStrongLightColors': '700 800 900'
          },
          'teal': {
            '50': '#e0f2f1',
            '100': '#b2dfdb',
            '200': '#80cbc4',
            '300': '#4db6ac',
            '400': '#26a69a',
            '500': '#009688',
            '600': '#00897b',
            '700': '#00796b',
            '800': '#00695c',
            '900': '#004d40',
            'A100': '#a7ffeb',
            'A200': '#64ffda',
            'A400': '#1de9b6',
            'A700': '#00bfa5',
            'contrastDefaultColor': 'dark',
            'contrastLightColors': '500 600 700 800 900',
            'contrastStrongLightColors': '500 600 700'
          },
          'green': {
            '50': '#e8f5e9',
            '100': '#c8e6c9',
            '200': '#a5d6a7',
            '300': '#81c784',
            '400': '#66bb6a',
            '500': '#4caf50',
            '600': '#43a047',
            '700': '#388e3c',
            '800': '#2e7d32',
            '900': '#1b5e20',
            'A100': '#b9f6ca',
            'A200': '#69f0ae',
            'A400': '#00e676',
            'A700': '#00c853',
            'contrastDefaultColor': 'dark',
            'contrastLightColors': '500 600 700 800 900',
            'contrastStrongLightColors': '500 600 700'
          },
          'light-green': {
            '50': '#f1f8e9',
            '100': '#dcedc8',
            '200': '#c5e1a5',
            '300': '#aed581',
            '400': '#9ccc65',
            '500': '#8bc34a',
            '600': '#7cb342',
            '700': '#689f38',
            '800': '#558b2f',
            '900': '#33691e',
            'A100': '#ccff90',
            'A200': '#b2ff59',
            'A400': '#76ff03',
            'A700': '#64dd17',
            'contrastDefaultColor': 'dark',
            'contrastLightColors': '700 800 900',
            'contrastStrongLightColors': '700 800 900'
          },
          'lime': {
            '50': '#f9fbe7',
            '100': '#f0f4c3',
            '200': '#e6ee9c',
            '300': '#dce775',
            '400': '#d4e157',
            '500': '#cddc39',
            '600': '#c0ca33',
            '700': '#afb42b',
            '800': '#9e9d24',
            '900': '#827717',
            'A100': '#f4ff81',
            'A200': '#eeff41',
            'A400': '#c6ff00',
            'A700': '#aeea00',
            'contrastDefaultColor': 'dark',
            'contrastLightColors': '900',
            'contrastStrongLightColors': '900'
          },
          'yellow': {
            '50': '#fffde7',
            '100': '#fff9c4',
            '200': '#fff59d',
            '300': '#fff176',
            '400': '#ffee58',
            '500': '#ffeb3b',
            '600': '#fdd835',
            '700': '#fbc02d',
            '800': '#f9a825',
            '900': '#f57f17',
            'A100': '#ffff8d',
            'A200': '#ffff00',
            'A400': '#ffea00',
            'A700': '#ffd600',
            'contrastDefaultColor': 'dark'
          },
          'amber': {
            '50': '#fff8e1',
            '100': '#ffecb3',
            '200': '#ffe082',
            '300': '#ffd54f',
            '400': '#ffca28',
            '500': '#ffc107',
            '600': '#ffb300',
            '700': '#ffa000',
            '800': '#ff8f00',
            '900': '#ff6f00',
            'A100': '#ffe57f',
            'A200': '#ffd740',
            'A400': '#ffc400',
            'A700': '#ffab00',
            'contrastDefaultColor': 'dark'
          },
          'orange': {
            '50': '#fff3e0',
            '100': '#ffe0b2',
            '200': '#ffcc80',
            '300': '#ffb74d',
            '400': '#ffa726',
            '500': '#ff9800',
            '600': '#fb8c00',
            '700': '#f57c00',
            '800': '#ef6c00',
            '900': '#e65100',
            'A100': '#ffd180',
            'A200': '#ffab40',
            'A400': '#ff9100',
            'A700': '#ff6d00',
            'contrastDefaultColor': 'dark',
            'contrastLightColors': '800 900',
            'contrastStrongLightColors': '800 900'
          },
          'deep-orange': {
            '50': '#fbe9e7',
            '100': '#ffccbc',
            '200': '#ffab91',
            '300': '#ff8a65',
            '400': '#ff7043',
            '500': '#ff5722',
            '600': '#f4511e',
            '700': '#e64a19',
            '800': '#d84315',
            '900': '#bf360c',
            'A100': '#ff9e80',
            'A200': '#ff6e40',
            'A400': '#ff3d00',
            'A700': '#dd2c00',
            'contrastDefaultColor': 'light',
            'contrastDarkColors': '50 100 200 300 400 A100 A200',
            'contrastStrongLightColors': '500 600 700 800 900 A400 A700'
          },
          'brown': {
            '50': '#efebe9',
            '100': '#d7ccc8',
            '200': '#bcaaa4',
            '300': '#a1887f',
            '400': '#8d6e63',
            '500': '#795548',
            '600': '#6d4c41',
            '700': '#5d4037',
            '800': '#4e342e',
            '900': '#3e2723',
            'A100': '#d7ccc8',
            'A200': '#bcaaa4',
            'A400': '#8d6e63',
            'A700': '#5d4037',
            'contrastDefaultColor': 'light',
            'contrastDarkColors': '50 100 200 A100 A200',
            'contrastStrongLightColors': '300 400'
          },
          'grey': {
            '50': '#fafafa',
            '100': '#f5f5f5',
            '200': '#eeeeee',
            '300': '#e0e0e0',
            '400': '#bdbdbd',
            '500': '#9e9e9e',
            '600': '#757575',
            '700': '#616161',
            '800': '#424242',
            '900': '#212121',
            'A100': '#ffffff',
            'A200': '#000000',
            'A400': '#303030',
            'A700': '#616161',
            'contrastDefaultColor': 'dark',
            'contrastLightColors': '600 700 800 900 A200 A400 A700'
          },
          'blue-grey': {
            '50': '#eceff1',
            '100': '#cfd8dc',
            '200': '#b0bec5',
            '300': '#90a4ae',
            '400': '#78909c',
            '500': '#607d8b',
            '600': '#546e7a',
            '700': '#455a64',
            '800': '#37474f',
            '900': '#263238',
            'A100': '#cfd8dc',
            'A200': '#b0bec5',
            'A400': '#78909c',
            'A700': '#455a64',
            'contrastDefaultColor': 'light',
            'contrastDarkColors': '50 100 200 300 A100 A200',
            'contrastStrongLightColors': '400 500 700'
          }
        });
      })();
      (function() {
        "use strict";
        angular.module('material.core.theming', ['material.core.theming.palette']).directive('mdTheme', ThemingDirective).directive('mdThemable', ThemableDirective).provider('$mdTheming', ThemingProvider).run(generateAllThemes);
        var GENERATED = {};
        var PALETTES;
        var DARK_FOREGROUND = {
          name: 'dark',
          '1': 'rgba(0,0,0,0.87)',
          '2': 'rgba(0,0,0,0.54)',
          '3': 'rgba(0,0,0,0.38)',
          '4': 'rgba(0,0,0,0.12)'
        };
        var LIGHT_FOREGROUND = {
          name: 'light',
          '1': 'rgba(255,255,255,1.0)',
          '2': 'rgba(255,255,255,0.7)',
          '3': 'rgba(255,255,255,0.5)',
          '4': 'rgba(255,255,255,0.12)'
        };
        var DARK_SHADOW = '1px 1px 0px rgba(0,0,0,0.4), -1px -1px 0px rgba(0,0,0,0.4)';
        var LIGHT_SHADOW = '';
        var DARK_CONTRAST_COLOR = colorToRgbaArray('rgba(0,0,0,0.87)');
        var LIGHT_CONTRAST_COLOR = colorToRgbaArray('rgba(255,255,255,0.87)');
        var STRONG_LIGHT_CONTRAST_COLOR = colorToRgbaArray('rgb(255,255,255)');
        var THEME_COLOR_TYPES = ['primary', 'accent', 'warn', 'background'];
        var DEFAULT_COLOR_TYPE = 'primary';
        var LIGHT_DEFAULT_HUES = {
          'accent': {
            'default': 'A200',
            'hue-1': 'A100',
            'hue-2': 'A400',
            'hue-3': 'A700'
          },
          'background': {
            'default': '50',
            'hue-1': 'A100',
            'hue-2': '100',
            'hue-3': '300'
          }
        };
        var DARK_DEFAULT_HUES = {'background': {
            'default': 'A400',
            'hue-1': '800',
            'hue-2': '900',
            'hue-3': 'A200'
          }};
        THEME_COLOR_TYPES.forEach(function(colorType) {
          var defaultDefaultHues = {
            'default': '500',
            'hue-1': '300',
            'hue-2': '800',
            'hue-3': 'A100'
          };
          if (!LIGHT_DEFAULT_HUES[colorType])
            LIGHT_DEFAULT_HUES[colorType] = defaultDefaultHues;
          if (!DARK_DEFAULT_HUES[colorType])
            DARK_DEFAULT_HUES[colorType] = defaultDefaultHues;
        });
        var VALID_HUE_VALUES = ['50', '100', '200', '300', '400', '500', '600', '700', '800', '900', 'A100', 'A200', 'A400', 'A700'];
        var generateOnDemand = false;
        var nonce = null;
        var disableTheming = false;
        var registeredStyles = [];
        function ThemingProvider($mdColorPalette) {
          PALETTES = {};
          var THEMES = {};
          var themingProvider;
          var defaultTheme = 'default';
          var alwaysWatchTheme = false;
          angular.extend(PALETTES, $mdColorPalette);
          ThemingService.$inject = ["$rootScope", "$log"];
          return themingProvider = {
            definePalette: definePalette,
            extendPalette: extendPalette,
            theme: registerTheme,
            disableTheming: function() {
              disableTheming = true;
            },
            registerStyles: function(styles) {
              registeredStyles.push(styles);
            },
            setNonce: function(nonceValue) {
              nonce = nonceValue;
            },
            setDefaultTheme: function(theme) {
              defaultTheme = theme;
            },
            alwaysWatchTheme: function(alwaysWatch) {
              alwaysWatchTheme = alwaysWatch;
            },
            generateThemesOnDemand: function(onDemand) {
              generateOnDemand = onDemand;
            },
            $get: ThemingService,
            _LIGHT_DEFAULT_HUES: LIGHT_DEFAULT_HUES,
            _DARK_DEFAULT_HUES: DARK_DEFAULT_HUES,
            _PALETTES: PALETTES,
            _THEMES: THEMES,
            _parseRules: parseRules,
            _rgba: rgba
          };
          function definePalette(name, map) {
            map = map || {};
            PALETTES[name] = checkPaletteValid(name, map);
            return themingProvider;
          }
          function extendPalette(name, map) {
            return checkPaletteValid(name, angular.extend({}, PALETTES[name] || {}, map));
          }
          function checkPaletteValid(name, map) {
            var missingColors = VALID_HUE_VALUES.filter(function(field) {
              return !map[field];
            });
            if (missingColors.length) {
              throw new Error("Missing colors %1 in palette %2!".replace('%1', missingColors.join(', ')).replace('%2', name));
            }
            return map;
          }
          function registerTheme(name, inheritFrom) {
            if (THEMES[name])
              return THEMES[name];
            inheritFrom = inheritFrom || 'default';
            var parentTheme = typeof inheritFrom === 'string' ? THEMES[inheritFrom] : inheritFrom;
            var theme = new Theme(name);
            if (parentTheme) {
              angular.forEach(parentTheme.colors, function(color, colorType) {
                theme.colors[colorType] = {
                  name: color.name,
                  hues: angular.extend({}, color.hues)
                };
              });
            }
            THEMES[name] = theme;
            return theme;
          }
          function Theme(name) {
            var self = this;
            self.name = name;
            self.colors = {};
            self.dark = setDark;
            setDark(false);
            function setDark(isDark) {
              isDark = arguments.length === 0 ? true : !!isDark;
              if (isDark === self.isDark)
                return;
              self.isDark = isDark;
              self.foregroundPalette = self.isDark ? LIGHT_FOREGROUND : DARK_FOREGROUND;
              self.foregroundShadow = self.isDark ? DARK_SHADOW : LIGHT_SHADOW;
              var newDefaultHues = self.isDark ? DARK_DEFAULT_HUES : LIGHT_DEFAULT_HUES;
              var oldDefaultHues = self.isDark ? LIGHT_DEFAULT_HUES : DARK_DEFAULT_HUES;
              angular.forEach(newDefaultHues, function(newDefaults, colorType) {
                var color = self.colors[colorType];
                var oldDefaults = oldDefaultHues[colorType];
                if (color) {
                  for (var hueName in color.hues) {
                    if (color.hues[hueName] === oldDefaults[hueName]) {
                      color.hues[hueName] = newDefaults[hueName];
                    }
                  }
                }
              });
              return self;
            }
            THEME_COLOR_TYPES.forEach(function(colorType) {
              var defaultHues = (self.isDark ? DARK_DEFAULT_HUES : LIGHT_DEFAULT_HUES)[colorType];
              self[colorType + 'Palette'] = function setPaletteType(paletteName, hues) {
                var color = self.colors[colorType] = {
                  name: paletteName,
                  hues: angular.extend({}, defaultHues, hues)
                };
                Object.keys(color.hues).forEach(function(name) {
                  if (!defaultHues[name]) {
                    throw new Error("Invalid hue name '%1' in theme %2's %3 color %4. Available hue names: %4".replace('%1', name).replace('%2', self.name).replace('%3', paletteName).replace('%4', Object.keys(defaultHues).join(', ')));
                  }
                });
                Object.keys(color.hues).map(function(key) {
                  return color.hues[key];
                }).forEach(function(hueValue) {
                  if (VALID_HUE_VALUES.indexOf(hueValue) == -1) {
                    throw new Error("Invalid hue value '%1' in theme %2's %3 color %4. Available hue values: %5".replace('%1', hueValue).replace('%2', self.name).replace('%3', colorType).replace('%4', paletteName).replace('%5', VALID_HUE_VALUES.join(', ')));
                  }
                });
                return self;
              };
              self[colorType + 'Color'] = function() {
                var args = Array.prototype.slice.call(arguments);
                console.warn('$mdThemingProviderTheme.' + colorType + 'Color() has been deprecated. ' + 'Use $mdThemingProviderTheme.' + colorType + 'Palette() instead.');
                return self[colorType + 'Palette'].apply(self, args);
              };
            });
          }
          function ThemingService($rootScope, $log) {
            var applyTheme = function(scope, el) {
              if (el === undefined) {
                el = scope;
                scope = undefined;
              }
              if (scope === undefined) {
                scope = $rootScope;
              }
              applyTheme.inherit(el, el);
            };
            applyTheme.THEMES = angular.extend({}, THEMES);
            applyTheme.PALETTES = angular.extend({}, PALETTES);
            applyTheme.inherit = inheritTheme;
            applyTheme.registered = registered;
            applyTheme.defaultTheme = function() {
              return defaultTheme;
            };
            applyTheme.generateTheme = function(name) {
              generateTheme(THEMES[name], name, nonce);
            };
            return applyTheme;
            function registered(themeName) {
              if (themeName === undefined || themeName === '')
                return true;
              return applyTheme.THEMES[themeName] !== undefined;
            }
            function inheritTheme(el, parent) {
              var ctrl = parent.controller('mdTheme');
              var attrThemeValue = el.attr('md-theme-watch');
              var watchTheme = (alwaysWatchTheme || angular.isDefined(attrThemeValue)) && attrThemeValue != 'false';
              updateThemeClass(lookupThemeName());
              el.on('$destroy', watchTheme ? $rootScope.$watch(lookupThemeName, updateThemeClass) : angular.noop);
              function lookupThemeName() {
                ctrl = parent.controller('mdTheme') || el.data('$mdThemeController');
                return ctrl && ctrl.$mdTheme || (defaultTheme == 'default' ? '' : defaultTheme);
              }
              function updateThemeClass(theme) {
                if (!theme)
                  return;
                if (!registered(theme)) {
                  $log.warn('Attempted to use unregistered theme \'' + theme + '\'. ' + 'Register it with $mdThemingProvider.theme().');
                }
                var oldTheme = el.data('$mdThemeName');
                if (oldTheme)
                  el.removeClass('md-' + oldTheme + '-theme');
                el.addClass('md-' + theme + '-theme');
                el.data('$mdThemeName', theme);
                if (ctrl) {
                  el.data('$mdThemeController', ctrl);
                }
              }
            }
          }
        }
        ThemingProvider.$inject = ["$mdColorPalette"];
        function ThemingDirective($mdTheming, $interpolate, $log) {
          return {
            priority: 100,
            link: {pre: function(scope, el, attrs) {
                var registeredCallbacks = [];
                var ctrl = {
                  registerChanges: function(cb, context) {
                    if (context) {
                      cb = angular.bind(context, cb);
                    }
                    registeredCallbacks.push(cb);
                    return function() {
                      var index = registeredCallbacks.indexOf(cb);
                      if (index > -1) {
                        registeredCallbacks.splice(index, 1);
                      }
                    };
                  },
                  $setTheme: function(theme) {
                    if (!$mdTheming.registered(theme)) {
                      $log.warn('attempted to use unregistered theme \'' + theme + '\'');
                    }
                    ctrl.$mdTheme = theme;
                    registeredCallbacks.forEach(function(cb) {
                      cb();
                    });
                  }
                };
                el.data('$mdThemeController', ctrl);
                ctrl.$setTheme($interpolate(attrs.mdTheme)(scope));
                attrs.$observe('mdTheme', ctrl.$setTheme);
              }}
          };
        }
        ThemingDirective.$inject = ["$mdTheming", "$interpolate", "$log"];
        function ThemableDirective($mdTheming) {
          return $mdTheming;
        }
        ThemableDirective.$inject = ["$mdTheming"];
        function parseRules(theme, colorType, rules) {
          checkValidPalette(theme, colorType);
          rules = rules.replace(/THEME_NAME/g, theme.name);
          var generatedRules = [];
          var color = theme.colors[colorType];
          var themeNameRegex = new RegExp('\\.md-' + theme.name + '-theme', 'g');
          var hueRegex = new RegExp('(\'|")?{{\\s*(' + colorType + ')-(color|contrast)-?(\\d\\.?\\d*)?\\s*}}(\"|\')?', 'g');
          var simpleVariableRegex = /'?"?\{\{\s*([a-zA-Z]+)-(A?\d+|hue\-[0-3]|shadow|default)-?(\d\.?\d*)?(contrast)?\s*\}\}'?"?/g;
          var palette = PALETTES[color.name];
          rules = rules.replace(simpleVariableRegex, function(match, colorType, hue, opacity, contrast) {
            if (colorType === 'foreground') {
              if (hue == 'shadow') {
                return theme.foregroundShadow;
              } else {
                return theme.foregroundPalette[hue] || theme.foregroundPalette['1'];
              }
            }
            if (hue.indexOf('hue') === 0 || hue === 'default') {
              hue = theme.colors[colorType].hues[hue];
            }
            return rgba((PALETTES[theme.colors[colorType].name][hue] || '')[contrast ? 'contrast' : 'value'], opacity);
          });
          angular.forEach(color.hues, function(hueValue, hueName) {
            var newRule = rules.replace(hueRegex, function(match, _, colorType, hueType, opacity) {
              return rgba(palette[hueValue][hueType === 'color' ? 'value' : 'contrast'], opacity);
            });
            if (hueName !== 'default') {
              newRule = newRule.replace(themeNameRegex, '.md-' + theme.name + '-theme.md-' + hueName);
            }
            if (theme.name == 'default') {
              var themeRuleRegex = /((?:(?:(?: |>|\.|\w|-|:|\(|\)|\[|\]|"|'|=)+) )?)((?:(?:\w|\.|-)+)?)\.md-default-theme((?: |>|\.|\w|-|:|\(|\)|\[|\]|"|'|=)*)/g;
              newRule = newRule.replace(themeRuleRegex, function(match, prefix, target, suffix) {
                return match + ', ' + prefix + target + suffix;
              });
            }
            generatedRules.push(newRule);
          });
          return generatedRules;
        }
        var rulesByType = {};
        function generateAllThemes($injector, $mdTheming) {
          var head = document.head;
          var firstChild = head ? head.firstElementChild : null;
          var themeCss = !disableTheming && $injector.has('$MD_THEME_CSS') ? $injector.get('$MD_THEME_CSS') : '';
          themeCss += registeredStyles.join('');
          if (!firstChild)
            return;
          if (themeCss.length === 0)
            return;
          angular.forEach(PALETTES, sanitizePalette);
          var rules = themeCss.split(/\}(?!(\}|'|"|;))/).filter(function(rule) {
            return rule && rule.length;
          }).map(function(rule) {
            return rule.trim() + '}';
          });
          var ruleMatchRegex = new RegExp('md-(' + THEME_COLOR_TYPES.join('|') + ')', 'g');
          THEME_COLOR_TYPES.forEach(function(type) {
            rulesByType[type] = '';
          });
          rules.forEach(function(rule) {
            var match = rule.match(ruleMatchRegex);
            for (var i = 0,
                type; type = THEME_COLOR_TYPES[i]; i++) {
              if (rule.indexOf('.md-' + type) > -1) {
                return rulesByType[type] += rule;
              }
            }
            for (i = 0; type = THEME_COLOR_TYPES[i]; i++) {
              if (rule.indexOf(type) > -1) {
                return rulesByType[type] += rule;
              }
            }
            return rulesByType[DEFAULT_COLOR_TYPE] += rule;
          });
          if (generateOnDemand)
            return;
          angular.forEach($mdTheming.THEMES, function(theme) {
            if (!GENERATED[theme.name] && !($mdTheming.defaultTheme() !== 'default' && theme.name === 'default')) {
              generateTheme(theme, theme.name, nonce);
            }
          });
          function sanitizePalette(palette, name) {
            var defaultContrast = palette.contrastDefaultColor;
            var lightColors = palette.contrastLightColors || [];
            var strongLightColors = palette.contrastStrongLightColors || [];
            var darkColors = palette.contrastDarkColors || [];
            if (typeof lightColors === 'string')
              lightColors = lightColors.split(' ');
            if (typeof strongLightColors === 'string')
              strongLightColors = strongLightColors.split(' ');
            if (typeof darkColors === 'string')
              darkColors = darkColors.split(' ');
            delete palette.contrastDefaultColor;
            delete palette.contrastLightColors;
            delete palette.contrastStrongLightColors;
            delete palette.contrastDarkColors;
            angular.forEach(palette, function(hueValue, hueName) {
              if (angular.isObject(hueValue))
                return;
              var rgbValue = colorToRgbaArray(hueValue);
              if (!rgbValue) {
                throw new Error("Color %1, in palette %2's hue %3, is invalid. Hex or rgb(a) color expected.".replace('%1', hueValue).replace('%2', palette.name).replace('%3', hueName));
              }
              palette[hueName] = {
                value: rgbValue,
                contrast: getContrastColor()
              };
              function getContrastColor() {
                if (defaultContrast === 'light') {
                  if (darkColors.indexOf(hueName) > -1) {
                    return DARK_CONTRAST_COLOR;
                  } else {
                    return strongLightColors.indexOf(hueName) > -1 ? STRONG_LIGHT_CONTRAST_COLOR : LIGHT_CONTRAST_COLOR;
                  }
                } else {
                  if (lightColors.indexOf(hueName) > -1) {
                    return strongLightColors.indexOf(hueName) > -1 ? STRONG_LIGHT_CONTRAST_COLOR : LIGHT_CONTRAST_COLOR;
                  } else {
                    return DARK_CONTRAST_COLOR;
                  }
                }
              }
            });
          }
        }
        generateAllThemes.$inject = ["$injector", "$mdTheming"];
        function generateTheme(theme, name, nonce) {
          var head = document.head;
          var firstChild = head ? head.firstElementChild : null;
          if (!GENERATED[name]) {
            THEME_COLOR_TYPES.forEach(function(colorType) {
              var styleStrings = parseRules(theme, colorType, rulesByType[colorType]);
              while (styleStrings.length) {
                var styleContent = styleStrings.shift();
                if (styleContent) {
                  var style = document.createElement('style');
                  style.setAttribute('md-theme-style', '');
                  if (nonce) {
                    style.setAttribute('nonce', nonce);
                  }
                  style.appendChild(document.createTextNode(styleContent));
                  head.insertBefore(style, firstChild);
                }
              }
            });
            GENERATED[theme.name] = true;
          }
        }
        function checkValidPalette(theme, colorType) {
          if (!PALETTES[(theme.colors[colorType] || {}).name]) {
            throw new Error("You supplied an invalid color palette for theme %1's %2 palette. Available palettes: %3".replace('%1', theme.name).replace('%2', colorType).replace('%3', Object.keys(PALETTES).join(', ')));
          }
        }
        function colorToRgbaArray(clr) {
          if (angular.isArray(clr) && clr.length == 3)
            return clr;
          if (/^rgb/.test(clr)) {
            return clr.replace(/(^\s*rgba?\(|\)\s*$)/g, '').split(',').map(function(value, i) {
              return i == 3 ? parseFloat(value, 10) : parseInt(value, 10);
            });
          }
          if (clr.charAt(0) == '#')
            clr = clr.substring(1);
          if (!/^([a-fA-F0-9]{3}){1,2}$/g.test(clr))
            return;
          var dig = clr.length / 3;
          var red = clr.substr(0, dig);
          var grn = clr.substr(dig, dig);
          var blu = clr.substr(dig * 2);
          if (dig === 1) {
            red += red;
            grn += grn;
            blu += blu;
          }
          return [parseInt(red, 16), parseInt(grn, 16), parseInt(blu, 16)];
        }
        function rgba(rgbArray, opacity) {
          if (!rgbArray)
            return "rgb('0,0,0')";
          if (rgbArray.length == 4) {
            rgbArray = angular.copy(rgbArray);
            opacity ? rgbArray.pop() : opacity = rgbArray.pop();
          }
          return opacity && (typeof opacity == 'number' || (typeof opacity == 'string' && opacity.length)) ? 'rgba(' + rgbArray.join(',') + ',' + opacity + ')' : 'rgb(' + rgbArray.join(',') + ')';
        }
      })();
      (function() {
        "use strict";
        angular.module('material.core').factory('$$mdAnimate', ["$q", "$timeout", "$mdConstant", "$animateCss", function($q, $timeout, $mdConstant, $animateCss) {
          return function($mdUtil) {
            return AnimateDomUtils($mdUtil, $q, $timeout, $mdConstant, $animateCss);
          };
        }]);
        function AnimateDomUtils($mdUtil, $q, $timeout, $mdConstant, $animateCss) {
          var self;
          return self = {
            translate3d: function(target, from, to, options) {
              return $animateCss(target, {
                from: from,
                to: to,
                addClass: options.transitionInClass,
                removeClass: options.transitionOutClass
              }).start().then(function() {
                return reverseTranslate;
              });
              function reverseTranslate(newFrom) {
                return $animateCss(target, {
                  to: newFrom || from,
                  addClass: options.transitionOutClass,
                  removeClass: options.transitionInClass
                }).start();
              }
            },
            waitTransitionEnd: function(element, opts) {
              var TIMEOUT = 3000;
              return $q(function(resolve, reject) {
                opts = opts || {};
                if (noTransitionFound(opts.cachedTransitionStyles)) {
                  TIMEOUT = 0;
                }
                var timer = $timeout(finished, opts.timeout || TIMEOUT);
                element.on($mdConstant.CSS.TRANSITIONEND, finished);
                function finished(ev) {
                  if (ev && ev.target !== element[0])
                    return;
                  if (ev)
                    $timeout.cancel(timer);
                  element.off($mdConstant.CSS.TRANSITIONEND, finished);
                  resolve();
                }
                function noTransitionFound(styles) {
                  styles = styles || window.getComputedStyle(element[0]);
                  return styles.transitionDuration == '0s' || (!styles.transition && !styles.transitionProperty);
                }
              });
            },
            calculateTransformValues: function(element, originator) {
              var origin = originator.element;
              var bounds = originator.bounds;
              if (origin || bounds) {
                var originBnds = origin ? self.clientRect(origin) || currentBounds() : self.copyRect(bounds);
                var dialogRect = self.copyRect(element[0].getBoundingClientRect());
                var dialogCenterPt = self.centerPointFor(dialogRect);
                var originCenterPt = self.centerPointFor(originBnds);
                return {
                  centerX: originCenterPt.x - dialogCenterPt.x,
                  centerY: originCenterPt.y - dialogCenterPt.y,
                  scaleX: Math.round(100 * Math.min(0.5, originBnds.width / dialogRect.width)) / 100,
                  scaleY: Math.round(100 * Math.min(0.5, originBnds.height / dialogRect.height)) / 100
                };
              }
              return {
                centerX: 0,
                centerY: 0,
                scaleX: 0.5,
                scaleY: 0.5
              };
              function currentBounds() {
                var cntr = element ? element.parent() : null;
                var parent = cntr ? cntr.parent() : null;
                return parent ? self.clientRect(parent) : null;
              }
            },
            calculateZoomToOrigin: function(element, originator) {
              var zoomTemplate = "translate3d( {centerX}px, {centerY}px, 0 ) scale( {scaleX}, {scaleY} )";
              var buildZoom = angular.bind(null, $mdUtil.supplant, zoomTemplate);
              return buildZoom(self.calculateTransformValues(element, originator));
            },
            calculateSlideToOrigin: function(element, originator) {
              var slideTemplate = "translate3d( {centerX}px, {centerY}px, 0 )";
              var buildSlide = angular.bind(null, $mdUtil.supplant, slideTemplate);
              return buildSlide(self.calculateTransformValues(element, originator));
            },
            toCss: function(raw) {
              var css = {};
              var lookups = 'left top right bottom width height x y min-width min-height max-width max-height';
              angular.forEach(raw, function(value, key) {
                if (angular.isUndefined(value))
                  return;
                if (lookups.indexOf(key) >= 0) {
                  css[key] = value + 'px';
                } else {
                  switch (key) {
                    case 'transition':
                      convertToVendor(key, $mdConstant.CSS.TRANSITION, value);
                      break;
                    case 'transform':
                      convertToVendor(key, $mdConstant.CSS.TRANSFORM, value);
                      break;
                    case 'transformOrigin':
                      convertToVendor(key, $mdConstant.CSS.TRANSFORM_ORIGIN, value);
                      break;
                    case 'font-size':
                      css['font-size'] = value;
                      break;
                  }
                }
              });
              return css;
              function convertToVendor(key, vendor, value) {
                angular.forEach(vendor.split(' '), function(key) {
                  css[key] = value;
                });
              }
            },
            toTransformCss: function(transform, addTransition, transition) {
              var css = {};
              angular.forEach($mdConstant.CSS.TRANSFORM.split(' '), function(key) {
                css[key] = transform;
              });
              if (addTransition) {
                transition = transition || "all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1) !important";
                css['transition'] = transition;
              }
              return css;
            },
            copyRect: function(source, destination) {
              if (!source)
                return null;
              destination = destination || {};
              angular.forEach('left top right bottom width height'.split(' '), function(key) {
                destination[key] = Math.round(source[key]);
              });
              destination.width = destination.width || (destination.right - destination.left);
              destination.height = destination.height || (destination.bottom - destination.top);
              return destination;
            },
            clientRect: function(element) {
              var bounds = angular.element(element)[0].getBoundingClientRect();
              var isPositiveSizeClientRect = function(rect) {
                return rect && (rect.width > 0) && (rect.height > 0);
              };
              return isPositiveSizeClientRect(bounds) ? self.copyRect(bounds) : null;
            },
            centerPointFor: function(targetRect) {
              return targetRect ? {
                x: Math.round(targetRect.left + (targetRect.width / 2)),
                y: Math.round(targetRect.top + (targetRect.height / 2))
              } : {
                x: 0,
                y: 0
              };
            }
          };
        }
        ;
      })();
      (function() {
        "use strict";
        "use strict";
        if (angular.version.minor >= 4) {
          angular.module('material.core.animate', []);
        } else {
          (function() {
            var forEach = angular.forEach;
            var WEBKIT = angular.isDefined(document.documentElement.style.WebkitAppearance);
            var TRANSITION_PROP = WEBKIT ? 'WebkitTransition' : 'transition';
            var ANIMATION_PROP = WEBKIT ? 'WebkitAnimation' : 'animation';
            var PREFIX = WEBKIT ? '-webkit-' : '';
            var TRANSITION_EVENTS = (WEBKIT ? 'webkitTransitionEnd ' : '') + 'transitionend';
            var ANIMATION_EVENTS = (WEBKIT ? 'webkitAnimationEnd ' : '') + 'animationend';
            var $$ForceReflowFactory = ['$document', function($document) {
              return function() {
                return $document[0].body.clientWidth + 1;
              };
            }];
            var $$rAFMutexFactory = ['$$rAF', function($$rAF) {
              return function() {
                var passed = false;
                $$rAF(function() {
                  passed = true;
                });
                return function(fn) {
                  passed ? fn() : $$rAF(fn);
                };
              };
            }];
            var $$AnimateRunnerFactory = ['$q', '$$rAFMutex', function($q, $$rAFMutex) {
              var INITIAL_STATE = 0;
              var DONE_PENDING_STATE = 1;
              var DONE_COMPLETE_STATE = 2;
              function AnimateRunner(host) {
                this.setHost(host);
                this._doneCallbacks = [];
                this._runInAnimationFrame = $$rAFMutex();
                this._state = 0;
              }
              AnimateRunner.prototype = {
                setHost: function(host) {
                  this.host = host || {};
                },
                done: function(fn) {
                  if (this._state === DONE_COMPLETE_STATE) {
                    fn();
                  } else {
                    this._doneCallbacks.push(fn);
                  }
                },
                progress: angular.noop,
                getPromise: function() {
                  if (!this.promise) {
                    var self = this;
                    this.promise = $q(function(resolve, reject) {
                      self.done(function(status) {
                        status === false ? reject() : resolve();
                      });
                    });
                  }
                  return this.promise;
                },
                then: function(resolveHandler, rejectHandler) {
                  return this.getPromise().then(resolveHandler, rejectHandler);
                },
                'catch': function(handler) {
                  return this.getPromise()['catch'](handler);
                },
                'finally': function(handler) {
                  return this.getPromise()['finally'](handler);
                },
                pause: function() {
                  if (this.host.pause) {
                    this.host.pause();
                  }
                },
                resume: function() {
                  if (this.host.resume) {
                    this.host.resume();
                  }
                },
                end: function() {
                  if (this.host.end) {
                    this.host.end();
                  }
                  this._resolve(true);
                },
                cancel: function() {
                  if (this.host.cancel) {
                    this.host.cancel();
                  }
                  this._resolve(false);
                },
                complete: function(response) {
                  var self = this;
                  if (self._state === INITIAL_STATE) {
                    self._state = DONE_PENDING_STATE;
                    self._runInAnimationFrame(function() {
                      self._resolve(response);
                    });
                  }
                },
                _resolve: function(response) {
                  if (this._state !== DONE_COMPLETE_STATE) {
                    forEach(this._doneCallbacks, function(fn) {
                      fn(response);
                    });
                    this._doneCallbacks.length = 0;
                    this._state = DONE_COMPLETE_STATE;
                  }
                }
              };
              return AnimateRunner;
            }];
            angular.module('material.core.animate', []).factory('$$forceReflow', $$ForceReflowFactory).factory('$$AnimateRunner', $$AnimateRunnerFactory).factory('$$rAFMutex', $$rAFMutexFactory).factory('$animateCss', ['$window', '$$rAF', '$$AnimateRunner', '$$forceReflow', '$$jqLite', '$timeout', '$animate', function($window, $$rAF, $$AnimateRunner, $$forceReflow, $$jqLite, $timeout, $animate) {
              function init(element, options) {
                var temporaryStyles = [];
                var node = getDomNode(element);
                var areAnimationsAllowed = node && $animate.enabled();
                var hasCompleteStyles = false;
                var hasCompleteClasses = false;
                if (areAnimationsAllowed) {
                  if (options.transitionStyle) {
                    temporaryStyles.push([PREFIX + 'transition', options.transitionStyle]);
                  }
                  if (options.keyframeStyle) {
                    temporaryStyles.push([PREFIX + 'animation', options.keyframeStyle]);
                  }
                  if (options.delay) {
                    temporaryStyles.push([PREFIX + 'transition-delay', options.delay + 's']);
                  }
                  if (options.duration) {
                    temporaryStyles.push([PREFIX + 'transition-duration', options.duration + 's']);
                  }
                  hasCompleteStyles = options.keyframeStyle || (options.to && (options.duration > 0 || options.transitionStyle));
                  hasCompleteClasses = !!options.addClass || !!options.removeClass;
                  blockTransition(element, true);
                }
                var hasCompleteAnimation = areAnimationsAllowed && (hasCompleteStyles || hasCompleteClasses);
                applyAnimationFromStyles(element, options);
                var animationClosed = false;
                var events,
                    eventFn;
                return {
                  close: $window.close,
                  start: function() {
                    var runner = new $$AnimateRunner();
                    waitUntilQuiet(function() {
                      blockTransition(element, false);
                      if (!hasCompleteAnimation) {
                        return close();
                      }
                      forEach(temporaryStyles, function(entry) {
                        var key = entry[0];
                        var value = entry[1];
                        node.style[camelCase(key)] = value;
                      });
                      applyClasses(element, options);
                      var timings = computeTimings(element);
                      if (timings.duration === 0) {
                        return close();
                      }
                      var moreStyles = [];
                      if (options.easing) {
                        if (timings.transitionDuration) {
                          moreStyles.push([PREFIX + 'transition-timing-function', options.easing]);
                        }
                        if (timings.animationDuration) {
                          moreStyles.push([PREFIX + 'animation-timing-function', options.easing]);
                        }
                      }
                      if (options.delay && timings.animationDelay) {
                        moreStyles.push([PREFIX + 'animation-delay', options.delay + 's']);
                      }
                      if (options.duration && timings.animationDuration) {
                        moreStyles.push([PREFIX + 'animation-duration', options.duration + 's']);
                      }
                      forEach(moreStyles, function(entry) {
                        var key = entry[0];
                        var value = entry[1];
                        node.style[camelCase(key)] = value;
                        temporaryStyles.push(entry);
                      });
                      var maxDelay = timings.delay;
                      var maxDelayTime = maxDelay * 1000;
                      var maxDuration = timings.duration;
                      var maxDurationTime = maxDuration * 1000;
                      var startTime = Date.now();
                      events = [];
                      if (timings.transitionDuration) {
                        events.push(TRANSITION_EVENTS);
                      }
                      if (timings.animationDuration) {
                        events.push(ANIMATION_EVENTS);
                      }
                      events = events.join(' ');
                      eventFn = function(event) {
                        event.stopPropagation();
                        var ev = event.originalEvent || event;
                        var timeStamp = ev.timeStamp || Date.now();
                        var elapsedTime = parseFloat(ev.elapsedTime.toFixed(3));
                        if (Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration) {
                          close();
                        }
                      };
                      element.on(events, eventFn);
                      applyAnimationToStyles(element, options);
                      $timeout(close, maxDelayTime + maxDurationTime * 1.5, false);
                    });
                    return runner;
                    function close() {
                      if (animationClosed)
                        return;
                      animationClosed = true;
                      if (events && eventFn) {
                        element.off(events, eventFn);
                      }
                      applyClasses(element, options);
                      applyAnimationStyles(element, options);
                      forEach(temporaryStyles, function(entry) {
                        node.style[camelCase(entry[0])] = '';
                      });
                      runner.complete(true);
                      return runner;
                    }
                  }
                };
              }
              function applyClasses(element, options) {
                if (options.addClass) {
                  $$jqLite.addClass(element, options.addClass);
                  options.addClass = null;
                }
                if (options.removeClass) {
                  $$jqLite.removeClass(element, options.removeClass);
                  options.removeClass = null;
                }
              }
              function computeTimings(element) {
                var node = getDomNode(element);
                var cs = $window.getComputedStyle(node);
                var tdr = parseMaxTime(cs[prop('transitionDuration')]);
                var adr = parseMaxTime(cs[prop('animationDuration')]);
                var tdy = parseMaxTime(cs[prop('transitionDelay')]);
                var ady = parseMaxTime(cs[prop('animationDelay')]);
                adr *= (parseInt(cs[prop('animationIterationCount')], 10) || 1);
                var duration = Math.max(adr, tdr);
                var delay = Math.max(ady, tdy);
                return {
                  duration: duration,
                  delay: delay,
                  animationDuration: adr,
                  transitionDuration: tdr,
                  animationDelay: ady,
                  transitionDelay: tdy
                };
                function prop(key) {
                  return WEBKIT ? 'Webkit' + key.charAt(0).toUpperCase() + key.substr(1) : key;
                }
              }
              function parseMaxTime(str) {
                var maxValue = 0;
                var values = (str || "").split(/\s*,\s*/);
                forEach(values, function(value) {
                  if (value.charAt(value.length - 1) == 's') {
                    value = value.substring(0, value.length - 1);
                  }
                  value = parseFloat(value) || 0;
                  maxValue = maxValue ? Math.max(value, maxValue) : value;
                });
                return maxValue;
              }
              var cancelLastRAFRequest;
              var rafWaitQueue = [];
              function waitUntilQuiet(callback) {
                if (cancelLastRAFRequest) {
                  cancelLastRAFRequest();
                }
                rafWaitQueue.push(callback);
                cancelLastRAFRequest = $$rAF(function() {
                  cancelLastRAFRequest = null;
                  var pageWidth = $$forceReflow();
                  for (var i = 0; i < rafWaitQueue.length; i++) {
                    rafWaitQueue[i](pageWidth);
                  }
                  rafWaitQueue.length = 0;
                });
              }
              function applyAnimationStyles(element, options) {
                applyAnimationFromStyles(element, options);
                applyAnimationToStyles(element, options);
              }
              function applyAnimationFromStyles(element, options) {
                if (options.from) {
                  element.css(options.from);
                  options.from = null;
                }
              }
              function applyAnimationToStyles(element, options) {
                if (options.to) {
                  element.css(options.to);
                  options.to = null;
                }
              }
              function getDomNode(element) {
                for (var i = 0; i < element.length; i++) {
                  if (element[i].nodeType === 1)
                    return element[i];
                }
              }
              function blockTransition(element, bool) {
                var node = getDomNode(element);
                var key = camelCase(PREFIX + 'transition-delay');
                node.style[key] = bool ? '-9999s' : '';
              }
              return init;
            }]);
            function camelCase(str) {
              return str.replace(/-[a-z]/g, function(str) {
                return str.charAt(1).toUpperCase();
              });
            }
          })();
        }
      })();
      (function() {
        "use strict";
        angular.module('material.components.autocomplete', ['material.core', 'material.components.icon', 'material.components.virtualRepeat']);
      })();
      (function() {
        "use strict";
        angular.module('material.components.backdrop', ['material.core']).directive('mdBackdrop', ["$mdTheming", "$mdUtil", "$animate", "$rootElement", "$window", "$log", "$$rAF", "$document", function BackdropDirective($mdTheming, $mdUtil, $animate, $rootElement, $window, $log, $$rAF, $document) {
          var ERROR_CSS_POSITION = "<md-backdrop> may not work properly in a scrolled, static-positioned parent container.";
          return {
            restrict: 'E',
            link: postLink
          };
          function postLink(scope, element, attrs) {
            if ($animate.pin)
              $animate.pin(element, $rootElement);
            $$rAF(function() {
              var body = $window.getComputedStyle($document[0].body);
              if (body.position == 'fixed') {
                var hViewport = parseInt(body.height, 10) + Math.abs(parseInt(body.top, 10));
                element.css({height: hViewport + 'px'});
              }
              var parent = element.parent()[0];
              if (parent) {
                if (parent.nodeName == 'BODY') {
                  element.css({position: 'fixed'});
                }
                var styles = $window.getComputedStyle(parent);
                if (styles.position == 'static') {
                  $log.warn(ERROR_CSS_POSITION);
                }
              }
              if (element.parent().length) {
                $mdTheming.inherit(element, element.parent());
              }
            });
            function resize() {
              var hViewport = parseInt(body.height, 10) + Math.abs(parseInt(body.top, 10));
              element.css({height: hViewport + 'px'});
            }
          }
        }]);
      })();
      (function() {
        "use strict";
        angular.module('material.components.bottomSheet', ['material.core', 'material.components.backdrop']).directive('mdBottomSheet', MdBottomSheetDirective).provider('$mdBottomSheet', MdBottomSheetProvider);
        function MdBottomSheetDirective($mdBottomSheet) {
          return {
            restrict: 'E',
            link: function postLink(scope, element) {
              element.addClass('_md');
              scope.$on('$destroy', function() {
                $mdBottomSheet.destroy();
              });
            }
          };
        }
        MdBottomSheetDirective.$inject = ["$mdBottomSheet"];
        function MdBottomSheetProvider($$interimElementProvider) {
          var CLOSING_VELOCITY = 0.5;
          var PADDING = 80;
          bottomSheetDefaults.$inject = ["$animate", "$mdConstant", "$mdUtil", "$mdTheming", "$mdBottomSheet", "$rootElement", "$mdGesture", "$log"];
          return $$interimElementProvider('$mdBottomSheet').setDefaults({
            methods: ['disableParentScroll', 'escapeToClose', 'clickOutsideToClose'],
            options: bottomSheetDefaults
          });
          function bottomSheetDefaults($animate, $mdConstant, $mdUtil, $mdTheming, $mdBottomSheet, $rootElement, $mdGesture, $log) {
            var backdrop;
            return {
              themable: true,
              onShow: onShow,
              onRemove: onRemove,
              disableBackdrop: false,
              escapeToClose: true,
              clickOutsideToClose: true,
              disableParentScroll: true
            };
            function onShow(scope, element, options, controller) {
              element = $mdUtil.extractElementByName(element, 'md-bottom-sheet');
              element.attr('tabindex', "-1");
              if (element.hasClass('ng-cloak')) {
                var message = '$mdBottomSheet: using `<md-bottom-sheet ng-cloak >` will affect the bottom-sheet opening animations.';
                $log.warn(message, element[0]);
              }
              if (!options.disableBackdrop) {
                backdrop = $mdUtil.createBackdrop(scope, "_md-bottom-sheet-backdrop md-opaque");
                backdrop[0].tabIndex = -1;
                if (options.clickOutsideToClose) {
                  backdrop.on('click', function() {
                    $mdUtil.nextTick($mdBottomSheet.cancel, true);
                  });
                }
                $mdTheming.inherit(backdrop, options.parent);
                $animate.enter(backdrop, options.parent, null);
              }
              var bottomSheet = new BottomSheet(element, options.parent);
              options.bottomSheet = bottomSheet;
              $mdTheming.inherit(bottomSheet.element, options.parent);
              if (options.disableParentScroll) {
                options.restoreScroll = $mdUtil.disableScrollAround(bottomSheet.element, options.parent);
              }
              return $animate.enter(bottomSheet.element, options.parent, backdrop).then(function() {
                var focusable = $mdUtil.findFocusTarget(element) || angular.element(element[0].querySelector('button') || element[0].querySelector('a') || element[0].querySelector($mdUtil.prefixer('ng-click', true))) || backdrop;
                if (options.escapeToClose) {
                  options.rootElementKeyupCallback = function(e) {
                    if (e.keyCode === $mdConstant.KEY_CODE.ESCAPE) {
                      $mdUtil.nextTick($mdBottomSheet.cancel, true);
                    }
                  };
                  $rootElement.on('keyup', options.rootElementKeyupCallback);
                  focusable && focusable.focus();
                }
              });
            }
            function onRemove(scope, element, options) {
              var bottomSheet = options.bottomSheet;
              if (!options.disableBackdrop)
                $animate.leave(backdrop);
              return $animate.leave(bottomSheet.element).then(function() {
                if (options.disableParentScroll) {
                  options.restoreScroll();
                  delete options.restoreScroll;
                }
                bottomSheet.cleanup();
              });
            }
            function BottomSheet(element, parent) {
              var deregister = $mdGesture.register(parent, 'drag', {horizontal: false});
              parent.on('$md.dragstart', onDragStart).on('$md.drag', onDrag).on('$md.dragend', onDragEnd);
              return {
                element: element,
                cleanup: function cleanup() {
                  deregister();
                  parent.off('$md.dragstart', onDragStart);
                  parent.off('$md.drag', onDrag);
                  parent.off('$md.dragend', onDragEnd);
                }
              };
              function onDragStart(ev) {
                element.css($mdConstant.CSS.TRANSITION_DURATION, '0ms');
              }
              function onDrag(ev) {
                var transform = ev.pointer.distanceY;
                if (transform < 5) {
                  transform = Math.max(-PADDING, transform / 2);
                }
                element.css($mdConstant.CSS.TRANSFORM, 'translate3d(0,' + (PADDING + transform) + 'px,0)');
              }
              function onDragEnd(ev) {
                if (ev.pointer.distanceY > 0 && (ev.pointer.distanceY > 20 || Math.abs(ev.pointer.velocityY) > CLOSING_VELOCITY)) {
                  var distanceRemaining = element.prop('offsetHeight') - ev.pointer.distanceY;
                  var transitionDuration = Math.min(distanceRemaining / ev.pointer.velocityY * 0.75, 500);
                  element.css($mdConstant.CSS.TRANSITION_DURATION, transitionDuration + 'ms');
                  $mdUtil.nextTick($mdBottomSheet.cancel, true);
                } else {
                  element.css($mdConstant.CSS.TRANSITION_DURATION, '');
                  element.css($mdConstant.CSS.TRANSFORM, '');
                }
              }
            }
          }
        }
        MdBottomSheetProvider.$inject = ["$$interimElementProvider"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.card', ['material.core']).directive('mdCard', mdCardDirective);
        function mdCardDirective($mdTheming) {
          return {
            restrict: 'E',
            link: function($scope, $element, attr) {
              $element.addClass('_md');
              $mdTheming($element);
            }
          };
        }
        mdCardDirective.$inject = ["$mdTheming"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.button', ['material.core']).directive('mdButton', MdButtonDirective).directive('a', MdAnchorDirective);
        function MdAnchorDirective($mdTheming) {
          return {
            restrict: 'E',
            link: function postLink(scope, element) {
              $mdTheming(element);
            }
          };
        }
        MdAnchorDirective.$inject = ["$mdTheming"];
        function MdButtonDirective($mdButtonInkRipple, $mdTheming, $mdAria, $timeout) {
          return {
            restrict: 'EA',
            replace: true,
            transclude: true,
            template: getTemplate,
            link: postLink
          };
          function isAnchor(attr) {
            return angular.isDefined(attr.href) || angular.isDefined(attr.ngHref) || angular.isDefined(attr.ngLink) || angular.isDefined(attr.uiSref);
          }
          function getTemplate(element, attr) {
            if (isAnchor(attr)) {
              return '<a class="md-button" ng-transclude></a>';
            } else {
              var btnType = (typeof attr.type === 'undefined') ? 'button' : attr.type;
              return '<button class="md-button" type="' + btnType + '" ng-transclude></button>';
            }
          }
          function postLink(scope, element, attr) {
            $mdTheming(element);
            $mdButtonInkRipple.attach(scope, element);
            $mdAria.expectWithoutText(element, 'aria-label');
            if (isAnchor(attr) && angular.isDefined(attr.ngDisabled)) {
              scope.$watch(attr.ngDisabled, function(isDisabled) {
                element.attr('tabindex', isDisabled ? -1 : 0);
              });
            }
            element.on('click', function(e) {
              if (attr.disabled === true) {
                e.preventDefault();
                e.stopImmediatePropagation();
              }
            });
            if (!element.hasClass('md-no-focus')) {
              scope.mouseActive = false;
              element.on('mousedown', function() {
                scope.mouseActive = true;
                $timeout(function() {
                  scope.mouseActive = false;
                }, 100);
              }).on('focus', function() {
                if (scope.mouseActive === false) {
                  element.addClass('md-focused');
                }
              }).on('blur', function(ev) {
                element.removeClass('md-focused');
              });
            }
          }
        }
        MdButtonDirective.$inject = ["$mdButtonInkRipple", "$mdTheming", "$mdAria", "$timeout"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.checkbox', ['material.core']).directive('mdCheckbox', MdCheckboxDirective);
        function MdCheckboxDirective(inputDirective, $mdAria, $mdConstant, $mdTheming, $mdUtil, $timeout) {
          inputDirective = inputDirective[0];
          var CHECKED_CSS = 'md-checked';
          return {
            restrict: 'E',
            transclude: true,
            require: '?ngModel',
            priority: 210,
            template: '<div class="_md-container" md-ink-ripple md-ink-ripple-checkbox>' + '<div class="_md-icon"></div>' + '</div>' + '<div ng-transclude class="_md-label"></div>',
            compile: compile
          };
          function compile(tElement, tAttrs) {
            var container = tElement.children();
            var mdIndeterminateStateEnabled = $mdUtil.parseAttributeBoolean(tAttrs.mdIndeterminate);
            tAttrs.$set('tabindex', tAttrs.tabindex || '0');
            tAttrs.$set('type', 'checkbox');
            tAttrs.$set('role', tAttrs.type);
            tElement.on('click', function(event) {
              if (this.hasAttribute('disabled')) {
                event.stopImmediatePropagation();
              }
            });
            container.on('focus', function() {
              tElement.focus();
            });
            return function postLink(scope, element, attr, ngModelCtrl) {
              var isIndeterminate;
              ngModelCtrl = ngModelCtrl || $mdUtil.fakeNgModel();
              $mdTheming(element);
              if (mdIndeterminateStateEnabled) {
                setIndeterminateState();
                scope.$watch(attr.mdIndeterminate, setIndeterminateState);
              }
              if (attr.ngChecked) {
                scope.$watch(scope.$eval.bind(scope, attr.ngChecked), ngModelCtrl.$setViewValue.bind(ngModelCtrl));
              }
              $$watchExpr('ngDisabled', 'tabindex', {
                true: '-1',
                false: attr.tabindex
              });
              $mdAria.expectWithText(element, 'aria-label');
              inputDirective.link.pre(scope, {
                on: angular.noop,
                0: {}
              }, attr, [ngModelCtrl]);
              scope.mouseActive = false;
              element.on('click', listener).on('keypress', keypressHandler).on('mousedown', function() {
                scope.mouseActive = true;
                $timeout(function() {
                  scope.mouseActive = false;
                }, 100);
              }).on('focus', function() {
                if (scope.mouseActive === false) {
                  element.addClass('md-focused');
                }
              }).on('blur', function() {
                element.removeClass('md-focused');
              });
              ngModelCtrl.$render = render;
              function $$watchExpr(expr, htmlAttr, valueOpts) {
                if (attr[expr]) {
                  scope.$watch(attr[expr], function(val) {
                    if (valueOpts[val]) {
                      element.attr(htmlAttr, valueOpts[val]);
                    }
                  });
                }
              }
              function keypressHandler(ev) {
                var keyCode = ev.which || ev.keyCode;
                if (keyCode === $mdConstant.KEY_CODE.SPACE || keyCode === $mdConstant.KEY_CODE.ENTER) {
                  ev.preventDefault();
                  if (!element.hasClass('md-focused')) {
                    element.addClass('md-focused');
                  }
                  listener(ev);
                }
              }
              function listener(ev) {
                if (element[0].hasAttribute('disabled') || scope.skipToggle) {
                  return;
                }
                scope.$apply(function() {
                  var viewValue = attr.ngChecked ? attr.checked : !ngModelCtrl.$viewValue;
                  ngModelCtrl.$setViewValue(viewValue, ev && ev.type);
                  ngModelCtrl.$render();
                });
              }
              function render() {
                if (ngModelCtrl.$viewValue && !isIndeterminate) {
                  element.addClass(CHECKED_CSS);
                } else {
                  element.removeClass(CHECKED_CSS);
                }
              }
              function setIndeterminateState(newValue) {
                isIndeterminate = newValue !== false;
                if (isIndeterminate) {
                  element.attr('aria-checked', 'mixed');
                }
                element.toggleClass('md-indeterminate', isIndeterminate);
              }
            };
          }
        }
        MdCheckboxDirective.$inject = ["inputDirective", "$mdAria", "$mdConstant", "$mdTheming", "$mdUtil", "$timeout"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.chips', ['material.core', 'material.components.autocomplete']);
      })();
      (function() {
        "use strict";
        (function() {
          "use strict";
          var STATIC_COLOR_EXPRESSION = /^{((\s|,)*?["'a-zA-Z-]+?\s*?:\s*?('|")[a-zA-Z0-9-.]*('|"))+\s*}$/;
          var colorPalettes = undefined;
          angular.module('material.components.colors', ['material.core']).directive('mdColors', MdColorsDirective).service('$mdColors', MdColorsService);
          function MdColorsService($mdTheming, $mdUtil, $log) {
            colorPalettes = colorPalettes || Object.keys($mdTheming.PALETTES);
            return {
              applyThemeColors: applyThemeColors,
              getThemeColor: getThemeColor,
              hasTheme: hasTheme
            };
            function applyThemeColors(element, colorExpression) {
              try {
                if (colorExpression) {
                  element.css(interpolateColors(colorExpression));
                }
              } catch (e) {
                $log.error(e.message);
              }
            }
            function getThemeColor(expression) {
              var color = extractColorOptions(expression);
              return parseColor(color);
            }
            function parseColor(color, contrast) {
              contrast = contrast || false;
              var rgbValues = $mdTheming.PALETTES[color.palette][color.hue];
              rgbValues = contrast ? rgbValues.contrast : rgbValues.value;
              return $mdUtil.supplant('rgba( {0}, {1}, {2}, {3} )', [rgbValues[0], rgbValues[1], rgbValues[2], rgbValues[3] || color.opacity]);
            }
            function interpolateColors(themeColors) {
              var rgbColors = {};
              var hasColorProperty = themeColors.hasOwnProperty('color');
              angular.forEach(themeColors, function(value, key) {
                var color = extractColorOptions(value);
                var hasBackground = key.indexOf('background') > -1;
                rgbColors[key] = parseColor(color);
                if (hasBackground && !hasColorProperty) {
                  rgbColors['color'] = parseColor(color, true);
                }
              });
              return rgbColors;
            }
            function hasTheme(expression) {
              return angular.isDefined($mdTheming.THEMES[expression.split('-')[0]]);
            }
            function extractColorOptions(expression) {
              var parts = expression.split('-');
              var hasTheme = angular.isDefined($mdTheming.THEMES[parts[0]]);
              var theme = hasTheme ? parts.splice(0, 1)[0] : $mdTheming.defaultTheme();
              return {
                theme: theme,
                palette: extractPalette(parts, theme),
                hue: extractHue(parts, theme),
                opacity: parts[2] || 1
              };
            }
            function extractPalette(parts, theme) {
              var isTwoWord = parts.length > 1 && colorPalettes.indexOf(parts[1]) !== -1;
              var palette = parts[0].replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
              if (isTwoWord)
                palette = parts[0] + '-' + parts.splice(1, 1);
              if (colorPalettes.indexOf(palette) === -1) {
                var scheme = $mdTheming.THEMES[theme].colors[palette];
                if (!scheme) {
                  throw new Error($mdUtil.supplant('mdColors: couldn\'t find \'{palette}\' in the palettes.', {palette: palette}));
                }
                palette = scheme.name;
              }
              return palette;
            }
            function extractHue(parts, theme) {
              var themeColors = $mdTheming.THEMES[theme].colors;
              if (parts[1] === 'hue') {
                var hueNumber = parseInt(parts.splice(2, 1)[0], 10);
                if (hueNumber < 1 || hueNumber > 3) {
                  throw new Error($mdUtil.supplant('mdColors: \'hue-{hueNumber}\' is not a valid hue, can be only \'hue-1\', \'hue-2\' and \'hue-3\'', {hueNumber: hueNumber}));
                }
                parts[1] = 'hue-' + hueNumber;
                if (!(parts[0] in themeColors)) {
                  throw new Error($mdUtil.supplant('mdColors: \'hue-x\' can only be used with [{availableThemes}], but was used with \'{usedTheme}\'', {
                    availableThemes: Object.keys(themeColors).join(', '),
                    usedTheme: parts[0]
                  }));
                }
                return themeColors[parts[0]].hues[parts[1]];
              }
              return parts[1] || themeColors[parts[0] in themeColors ? parts[0] : 'primary'].hues['default'];
            }
          }
          MdColorsService.$inject = ["$mdTheming", "$mdUtil", "$log"];
          function MdColorsDirective($mdColors, $mdUtil, $log, $parse) {
            return {
              restrict: 'A',
              require: ['^?mdTheme'],
              compile: function(tElem, tAttrs) {
                var shouldWatch = shouldColorsWatch();
                return function(scope, element, attrs, ctrl) {
                  var mdThemeController = ctrl[0];
                  var lastColors = {};
                  var parseColors = function(theme) {
                    if (typeof theme !== 'string') {
                      theme = '';
                    }
                    if (!attrs.mdColors) {
                      attrs.mdColors = '{}';
                    }
                    var colors = $parse(attrs.mdColors)(scope);
                    if (mdThemeController) {
                      Object.keys(colors).forEach(function(prop) {
                        var color = colors[prop];
                        if (!$mdColors.hasTheme(color)) {
                          colors[prop] = (theme || mdThemeController.$mdTheme) + '-' + color;
                        }
                      });
                    }
                    cleanElement(colors);
                    return colors;
                  };
                  var cleanElement = function(colors) {
                    if (!angular.equals(colors, lastColors)) {
                      var keys = Object.keys(lastColors);
                      if (lastColors.background && !keys['color']) {
                        keys.push('color');
                      }
                      keys.forEach(function(key) {
                        element.css(key, '');
                      });
                    }
                    lastColors = colors;
                  };
                  var unregisterChanges = angular.noop;
                  if (mdThemeController) {
                    unregisterChanges = mdThemeController.registerChanges(function(theme) {
                      $mdColors.applyThemeColors(element, parseColors(theme));
                    });
                  }
                  scope.$on('$destroy', function() {
                    unregisterChanges();
                  });
                  try {
                    if (shouldWatch) {
                      scope.$watch(parseColors, angular.bind(this, $mdColors.applyThemeColors, element), true);
                    } else {
                      $mdColors.applyThemeColors(element, parseColors());
                    }
                  } catch (e) {
                    $log.error(e.message);
                  }
                };
                function shouldColorsWatch() {
                  var rawColorExpression = tAttrs.mdColors;
                  var bindOnce = rawColorExpression.indexOf('::') > -1;
                  var isStatic = bindOnce ? true : STATIC_COLOR_EXPRESSION.test(tAttrs.mdColors);
                  tAttrs.mdColors = rawColorExpression.replace('::', '');
                  var hasWatchAttr = angular.isDefined(tAttrs.mdColorsWatch);
                  return (bindOnce || isStatic) ? false : hasWatchAttr ? $mdUtil.parseAttributeBoolean(tAttrs.mdColorsWatch) : true;
                }
              }
            };
          }
          MdColorsDirective.$inject = ["$mdColors", "$mdUtil", "$log", "$parse"];
        })();
      })();
      (function() {
        "use strict";
        angular.module('material.components.content', ['material.core']).directive('mdContent', mdContentDirective);
        function mdContentDirective($mdTheming) {
          return {
            restrict: 'E',
            controller: ['$scope', '$element', ContentController],
            link: function(scope, element) {
              element.addClass('_md');
              element.addClass('md-no-flicker');
              $mdTheming(element);
              scope.$broadcast('$mdContentLoaded', element);
              iosScrollFix(element[0]);
            }
          };
          function ContentController($scope, $element) {
            this.$scope = $scope;
            this.$element = $element;
          }
        }
        mdContentDirective.$inject = ["$mdTheming"];
        function iosScrollFix(node) {
          angular.element(node).on('$md.pressdown', function(ev) {
            if (ev.pointer.type !== 't')
              return;
            if (ev.$materialScrollFixed)
              return;
            ev.$materialScrollFixed = true;
            if (node.scrollTop === 0) {
              node.scrollTop = 1;
            } else if (node.scrollHeight === node.scrollTop + node.offsetHeight) {
              node.scrollTop -= 1;
            }
          });
        }
      })();
      (function() {
        "use strict";
        angular.module('material.components.datepicker', ['material.core', 'material.components.icon', 'material.components.virtualRepeat']);
      })();
      (function() {
        "use strict";
        angular.module('material.components.dialog', ['material.core', 'material.components.backdrop']).directive('mdDialog', MdDialogDirective).provider('$mdDialog', MdDialogProvider);
        function MdDialogDirective($$rAF, $mdTheming, $mdDialog) {
          return {
            restrict: 'E',
            link: function(scope, element) {
              element.addClass('_md');
              $mdTheming(element);
              $$rAF(function() {
                var images;
                var content = element[0].querySelector('md-dialog-content');
                if (content) {
                  images = content.getElementsByTagName('img');
                  addOverflowClass();
                  angular.element(images).on('load', addOverflowClass);
                }
                scope.$on('$destroy', function() {
                  $mdDialog.destroy(element);
                });
                function addOverflowClass() {
                  element.toggleClass('md-content-overflow', content.scrollHeight > content.clientHeight);
                }
              });
            }
          };
        }
        MdDialogDirective.$inject = ["$$rAF", "$mdTheming", "$mdDialog"];
        function MdDialogProvider($$interimElementProvider) {
          var topFocusTrap,
              bottomFocusTrap;
          advancedDialogOptions.$inject = ["$mdDialog", "$mdConstant"];
          dialogDefaultOptions.$inject = ["$mdDialog", "$mdAria", "$mdUtil", "$mdConstant", "$animate", "$document", "$window", "$rootElement", "$log", "$injector", "$mdTheming"];
          return $$interimElementProvider('$mdDialog').setDefaults({
            methods: ['disableParentScroll', 'hasBackdrop', 'clickOutsideToClose', 'escapeToClose', 'targetEvent', 'closeTo', 'openFrom', 'parent', 'fullscreen', 'contentElement'],
            options: dialogDefaultOptions
          }).addPreset('alert', {
            methods: ['title', 'htmlContent', 'textContent', 'content', 'ariaLabel', 'ok', 'theme', 'css'],
            options: advancedDialogOptions
          }).addPreset('confirm', {
            methods: ['title', 'htmlContent', 'textContent', 'content', 'ariaLabel', 'ok', 'cancel', 'theme', 'css'],
            options: advancedDialogOptions
          }).addPreset('prompt', {
            methods: ['title', 'htmlContent', 'textContent', 'initialValue', 'content', 'placeholder', 'ariaLabel', 'ok', 'cancel', 'theme', 'css'],
            options: advancedDialogOptions
          });
          function advancedDialogOptions($mdDialog, $mdConstant) {
            return {
              template: ['<md-dialog md-theme="{{ dialog.theme }}" aria-label="{{ dialog.ariaLabel }}" ng-class="dialog.css">', '  <md-dialog-content class="md-dialog-content" role="document" tabIndex="-1">', '    <h2 class="md-title">{{ dialog.title }}</h2>', '    <div ng-if="::dialog.mdHtmlContent" class="_md-dialog-content-body" ', '        ng-bind-html="::dialog.mdHtmlContent"></div>', '    <div ng-if="::!dialog.mdHtmlContent" class="_md-dialog-content-body">', '      <p>{{::dialog.mdTextContent}}</p>', '    </div>', '    <md-input-container md-no-float ng-if="::dialog.$type == \'prompt\'" class="md-prompt-input-container">', '      <input ng-keypress="dialog.keypress($event)" md-autofocus ng-model="dialog.result" ' + '             placeholder="{{::dialog.placeholder}}">', '    </md-input-container>', '  </md-dialog-content>', '  <md-dialog-actions>', '    <md-button ng-if="dialog.$type === \'confirm\' || dialog.$type === \'prompt\'"' + '               ng-click="dialog.abort()" class="md-primary">', '      {{ dialog.cancel }}', '    </md-button>', '    <md-button ng-click="dialog.hide()" class="md-primary" md-autofocus="dialog.$type===\'alert\'">', '      {{ dialog.ok }}', '    </md-button>', '  </md-dialog-actions>', '</md-dialog>'].join('').replace(/\s\s+/g, ''),
              controller: function mdDialogCtrl() {
                var isPrompt = this.$type == 'prompt';
                if (isPrompt && this.initialValue) {
                  this.result = this.initialValue;
                }
                this.hide = function() {
                  $mdDialog.hide(isPrompt ? this.result : true);
                };
                this.abort = function() {
                  $mdDialog.cancel();
                };
                this.keypress = function($event) {
                  if ($event.keyCode === $mdConstant.KEY_CODE.ENTER) {
                    $mdDialog.hide(this.result);
                  }
                };
              },
              controllerAs: 'dialog',
              bindToController: true
            };
          }
          function dialogDefaultOptions($mdDialog, $mdAria, $mdUtil, $mdConstant, $animate, $document, $window, $rootElement, $log, $injector, $mdTheming) {
            return {
              hasBackdrop: true,
              isolateScope: true,
              onCompiling: beforeCompile,
              onShow: onShow,
              onShowing: beforeShow,
              onRemove: onRemove,
              clickOutsideToClose: false,
              escapeToClose: true,
              targetEvent: null,
              contentElement: null,
              closeTo: null,
              openFrom: null,
              focusOnOpen: true,
              disableParentScroll: true,
              autoWrap: true,
              fullscreen: false,
              transformTemplate: function(template, options) {
                return '<div class="md-dialog-container" tabindex="-1">' + validatedTemplate(template) + '</div>';
                function validatedTemplate(template) {
                  if (options.autoWrap && !/<\/md-dialog>/g.test(template)) {
                    return '<md-dialog>' + (template || '') + '</md-dialog>';
                  } else {
                    return template || '';
                  }
                }
              }
            };
            function beforeCompile(options) {
              detectTheming(options);
            }
            function beforeShow(scope, element, options, controller) {
              if (controller) {
                controller.mdHtmlContent = controller.htmlContent || options.htmlContent || '';
                controller.mdTextContent = controller.textContent || options.textContent || controller.content || options.content || '';
                if (controller.mdHtmlContent && !$injector.has('$sanitize')) {
                  throw Error('The ngSanitize module must be loaded in order to use htmlContent.');
                }
                if (controller.mdHtmlContent && controller.mdTextContent) {
                  throw Error('md-dialog cannot have both `htmlContent` and `textContent`');
                }
              }
            }
            function onShow(scope, element, options, controller) {
              angular.element($document[0].body).addClass('md-dialog-is-showing');
              if (options.contentElement) {
                var contentEl = options.contentElement;
                if (angular.isString(contentEl)) {
                  contentEl = document.querySelector(contentEl);
                  options.elementInsertionSibling = contentEl.nextElementSibling;
                  options.elementInsertionParent = contentEl.parentNode;
                } else {
                  contentEl = contentEl[0] || contentEl;
                  if (document.contains(contentEl)) {
                    options.elementInsertionSibling = contentEl.nextElementSibling;
                    options.elementInsertionParent = contentEl.parentNode;
                  }
                }
                options.elementInsertionEntry = contentEl;
                element = angular.element(contentEl);
              }
              var dialogElement = element.find('md-dialog');
              if (dialogElement.hasClass('ng-cloak')) {
                var message = '$mdDialog: using `<md-dialog ng-cloak >` will affect the dialog opening animations.';
                $log.warn(message, element[0]);
              }
              captureParentAndFromToElements(options);
              configureAria(dialogElement, options);
              showBackdrop(scope, element, options);
              return dialogPopIn(element, options).then(function() {
                activateListeners(element, options);
                lockScreenReader(element, options);
                warnDeprecatedActions();
                focusOnOpen();
              });
              function warnDeprecatedActions() {
                if (element[0].querySelector('.md-actions')) {
                  $log.warn('Using a class of md-actions is deprecated, please use <md-dialog-actions>.');
                }
              }
              function focusOnOpen() {
                if (options.focusOnOpen) {
                  var target = $mdUtil.findFocusTarget(element) || findCloseButton();
                  target.focus();
                }
                function findCloseButton() {
                  var closeButton = element[0].querySelector('.dialog-close');
                  if (!closeButton) {
                    var actionButtons = element[0].querySelectorAll('.md-actions button, md-dialog-actions button');
                    closeButton = actionButtons[actionButtons.length - 1];
                  }
                  return angular.element(closeButton);
                }
              }
            }
            function onRemove(scope, element, options) {
              options.deactivateListeners();
              options.unlockScreenReader();
              options.hideBackdrop(options.$destroy);
              if (topFocusTrap && topFocusTrap.parentNode) {
                topFocusTrap.parentNode.removeChild(topFocusTrap);
              }
              if (bottomFocusTrap && bottomFocusTrap.parentNode) {
                bottomFocusTrap.parentNode.removeChild(bottomFocusTrap);
              }
              return !!options.$destroy ? detachAndClean() : animateRemoval().then(detachAndClean);
              function animateRemoval() {
                return dialogPopOut(element, options);
              }
              function removeContentElement() {
                if (!options.contentElement)
                  return;
                options.reverseContainerStretch();
                if (!options.elementInsertionParent) {
                  options.elementInsertionEntry.parentNode.removeChild(options.elementInsertionEntry);
                } else if (!options.elementInsertionSibling) {
                  options.elementInsertionParent.appendChild(options.elementInsertionEntry);
                } else {
                  options.elementInsertionParent.insertBefore(options.elementInsertionEntry, options.elementInsertionSibling);
                }
              }
              function detachAndClean() {
                angular.element($document[0].body).removeClass('md-dialog-is-showing');
                if (!options.contentElement) {
                  element.remove();
                } else {
                  removeContentElement();
                }
                if (!options.$destroy)
                  options.origin.focus();
              }
            }
            function detectTheming(options) {
              if (options.theme)
                return;
              options.theme = $mdTheming.defaultTheme();
              if (options.targetEvent && options.targetEvent.target) {
                var targetEl = angular.element(options.targetEvent.target);
                options.theme = (targetEl.controller('mdTheme') || {}).$mdTheme || options.theme;
              }
            }
            function captureParentAndFromToElements(options) {
              options.origin = angular.extend({
                element: null,
                bounds: null,
                focus: angular.noop
              }, options.origin || {});
              options.parent = getDomElement(options.parent, $rootElement);
              options.closeTo = getBoundingClientRect(getDomElement(options.closeTo));
              options.openFrom = getBoundingClientRect(getDomElement(options.openFrom));
              if (options.targetEvent) {
                options.origin = getBoundingClientRect(options.targetEvent.target, options.origin);
              }
              function getBoundingClientRect(element, orig) {
                var source = angular.element((element || {}));
                if (source && source.length) {
                  var bounds = {
                    top: 0,
                    left: 0,
                    height: 0,
                    width: 0
                  };
                  var hasFn = angular.isFunction(source[0].getBoundingClientRect);
                  return angular.extend(orig || {}, {
                    element: hasFn ? source : undefined,
                    bounds: hasFn ? source[0].getBoundingClientRect() : angular.extend({}, bounds, source[0]),
                    focus: angular.bind(source, source.focus)
                  });
                }
              }
              function getDomElement(element, defaultElement) {
                if (angular.isString(element)) {
                  element = $document[0].querySelector(element);
                }
                return angular.element(element || defaultElement);
              }
            }
            function activateListeners(element, options) {
              var window = angular.element($window);
              var onWindowResize = $mdUtil.debounce(function() {
                stretchDialogContainerToViewport(element, options);
              }, 60);
              var removeListeners = [];
              var smartClose = function() {
                var closeFn = (options.$type == 'alert') ? $mdDialog.hide : $mdDialog.cancel;
                $mdUtil.nextTick(closeFn, true);
              };
              if (options.escapeToClose) {
                var parentTarget = options.parent;
                var keyHandlerFn = function(ev) {
                  if (ev.keyCode === $mdConstant.KEY_CODE.ESCAPE) {
                    ev.stopPropagation();
                    ev.preventDefault();
                    smartClose();
                  }
                };
                element.on('keydown', keyHandlerFn);
                parentTarget.on('keydown', keyHandlerFn);
                removeListeners.push(function() {
                  element.off('keydown', keyHandlerFn);
                  parentTarget.off('keydown', keyHandlerFn);
                });
              }
              window.on('resize', onWindowResize);
              removeListeners.push(function() {
                window.off('resize', onWindowResize);
              });
              if (options.clickOutsideToClose) {
                var target = element;
                var sourceElem;
                var mousedownHandler = function(ev) {
                  sourceElem = ev.target;
                };
                var mouseupHandler = function(ev) {
                  if (sourceElem === target[0] && ev.target === target[0]) {
                    ev.stopPropagation();
                    ev.preventDefault();
                    smartClose();
                  }
                };
                target.on('mousedown', mousedownHandler);
                target.on('mouseup', mouseupHandler);
                removeListeners.push(function() {
                  target.off('mousedown', mousedownHandler);
                  target.off('mouseup', mouseupHandler);
                });
              }
              options.deactivateListeners = function() {
                removeListeners.forEach(function(removeFn) {
                  removeFn();
                });
                options.deactivateListeners = null;
              };
            }
            function showBackdrop(scope, element, options) {
              if (options.disableParentScroll) {
                options.restoreScroll = $mdUtil.disableScrollAround(element, options.parent);
              }
              if (options.hasBackdrop) {
                options.backdrop = $mdUtil.createBackdrop(scope, "_md-dialog-backdrop md-opaque");
                $animate.enter(options.backdrop, options.parent);
              }
              options.hideBackdrop = function hideBackdrop($destroy) {
                if (options.backdrop) {
                  if (!!$destroy)
                    options.backdrop.remove();
                  else
                    $animate.leave(options.backdrop);
                }
                if (options.disableParentScroll) {
                  options.restoreScroll();
                  delete options.restoreScroll;
                }
                options.hideBackdrop = null;
              };
            }
            function configureAria(element, options) {
              var role = (options.$type === 'alert') ? 'alertdialog' : 'dialog';
              var dialogContent = element.find('md-dialog-content');
              var existingDialogId = element.attr('id');
              var dialogContentId = 'dialogContent_' + (existingDialogId || $mdUtil.nextUid());
              element.attr({
                'role': role,
                'tabIndex': '-1'
              });
              if (dialogContent.length === 0) {
                dialogContent = element;
                if (existingDialogId) {
                  dialogContentId = existingDialogId;
                }
              }
              dialogContent.attr('id', dialogContentId);
              element.attr('aria-describedby', dialogContentId);
              if (options.ariaLabel) {
                $mdAria.expect(element, 'aria-label', options.ariaLabel);
              } else {
                $mdAria.expectAsync(element, 'aria-label', function() {
                  var words = dialogContent.text().split(/\s+/);
                  if (words.length > 3)
                    words = words.slice(0, 3).concat('...');
                  return words.join(' ');
                });
              }
              topFocusTrap = document.createElement('div');
              topFocusTrap.classList.add('_md-dialog-focus-trap');
              topFocusTrap.tabIndex = 0;
              bottomFocusTrap = topFocusTrap.cloneNode(false);
              var focusHandler = function() {
                element.focus();
              };
              topFocusTrap.addEventListener('focus', focusHandler);
              bottomFocusTrap.addEventListener('focus', focusHandler);
              element[0].parentNode.insertBefore(topFocusTrap, element[0]);
              element.after(bottomFocusTrap);
            }
            function lockScreenReader(element, options) {
              var isHidden = true;
              walkDOM(element[0]);
              options.unlockScreenReader = function() {
                isHidden = false;
                walkDOM(element[0]);
                options.unlockScreenReader = null;
              };
              function walkDOM(element) {
                while (element.parentNode) {
                  if (element === document.body) {
                    return;
                  }
                  var children = element.parentNode.children;
                  for (var i = 0; i < children.length; i++) {
                    if (element !== children[i] && !isNodeOneOf(children[i], ['SCRIPT', 'STYLE'])) {
                      children[i].setAttribute('aria-hidden', isHidden);
                    }
                  }
                  walkDOM(element = element.parentNode);
                }
              }
            }
            function stretchDialogContainerToViewport(container, options) {
              var isFixed = $window.getComputedStyle($document[0].body).position == 'fixed';
              var backdrop = options.backdrop ? $window.getComputedStyle(options.backdrop[0]) : null;
              var height = backdrop ? Math.min($document[0].body.clientHeight, Math.ceil(Math.abs(parseInt(backdrop.height, 10)))) : 0;
              var previousStyles = {
                top: container.css('top'),
                height: container.css('height')
              };
              container.css({
                top: (isFixed ? $mdUtil.scrollTop(options.parent) : 0) + 'px',
                height: height ? height + 'px' : '100%'
              });
              return function() {
                container.css(previousStyles);
              };
            }
            function dialogPopIn(container, options) {
              options.parent.append(container);
              options.reverseContainerStretch = stretchDialogContainerToViewport(container, options);
              var dialogEl = container.find('md-dialog');
              var animator = $mdUtil.dom.animator;
              var buildTranslateToOrigin = animator.calculateZoomToOrigin;
              var translateOptions = {
                transitionInClass: '_md-transition-in',
                transitionOutClass: '_md-transition-out'
              };
              var from = animator.toTransformCss(buildTranslateToOrigin(dialogEl, options.openFrom || options.origin));
              var to = animator.toTransformCss("");
              if (options.fullscreen) {
                dialogEl.addClass('md-dialog-fullscreen');
              }
              return animator.translate3d(dialogEl, from, to, translateOptions).then(function(animateReversal) {
                options.reverseAnimate = function() {
                  delete options.reverseAnimate;
                  if (options.closeTo) {
                    translateOptions = {
                      transitionInClass: '_md-transition-out',
                      transitionOutClass: '_md-transition-in'
                    };
                    from = to;
                    to = animator.toTransformCss(buildTranslateToOrigin(dialogEl, options.closeTo));
                    return animator.translate3d(dialogEl, from, to, translateOptions);
                  }
                  return animateReversal(to = animator.toTransformCss(buildTranslateToOrigin(dialogEl, options.origin)));
                };
                options.clearAnimate = function() {
                  delete options.clearAnimate;
                  return animator.translate3d(dialogEl, to, animator.toTransformCss(''), {});
                };
                return true;
              });
            }
            function dialogPopOut(container, options) {
              return options.reverseAnimate().then(function() {
                if (options.contentElement) {
                  options.clearAnimate();
                }
              });
            }
            function isNodeOneOf(elem, nodeTypeArray) {
              if (nodeTypeArray.indexOf(elem.nodeName) !== -1) {
                return true;
              }
            }
          }
        }
        MdDialogProvider.$inject = ["$$interimElementProvider"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.divider', ['material.core']).directive('mdDivider', MdDividerDirective);
        function MdDividerDirective($mdTheming) {
          return {
            restrict: 'E',
            link: $mdTheming
          };
        }
        MdDividerDirective.$inject = ["$mdTheming"];
      })();
      (function() {
        "use strict";
        (function() {
          'use strict';
          angular.module('material.components.fabActions', ['material.core']).directive('mdFabActions', MdFabActionsDirective);
          function MdFabActionsDirective($mdUtil) {
            return {
              restrict: 'E',
              require: ['^?mdFabSpeedDial', '^?mdFabToolbar'],
              compile: function(element, attributes) {
                var children = element.children();
                var hasNgRepeat = $mdUtil.prefixer().hasAttribute(children, 'ng-repeat');
                if (hasNgRepeat) {
                  children.addClass('md-fab-action-item');
                } else {
                  children.wrap('<div class="md-fab-action-item">');
                }
              }
            };
          }
          MdFabActionsDirective.$inject = ["$mdUtil"];
        })();
      })();
      (function() {
        "use strict";
        (function() {
          'use strict';
          angular.module('material.components.fabShared', ['material.core']).controller('MdFabController', MdFabController);
          function MdFabController($scope, $element, $animate, $mdUtil, $mdConstant, $timeout) {
            var vm = this;
            vm.open = function() {
              $scope.$evalAsync("vm.isOpen = true");
            };
            vm.close = function() {
              $scope.$evalAsync("vm.isOpen = false");
              $element.find('md-fab-trigger')[0].focus();
            };
            vm.toggle = function() {
              $scope.$evalAsync("vm.isOpen = !vm.isOpen");
            };
            setupDefaults();
            setupListeners();
            setupWatchers();
            var initialAnimationAttempts = 0;
            fireInitialAnimations();
            function setupDefaults() {
              vm.direction = vm.direction || 'down';
              vm.isOpen = vm.isOpen || false;
              resetActionIndex();
              $element.addClass('_md-animations-waiting');
            }
            function setupListeners() {
              var eventTypes = ['click', 'focusin', 'focusout'];
              angular.forEach(eventTypes, function(eventType) {
                $element.on(eventType, parseEvents);
              });
              $scope.$on('$destroy', function() {
                angular.forEach(eventTypes, function(eventType) {
                  $element.off(eventType, parseEvents);
                });
                disableKeyboard();
              });
            }
            var closeTimeout;
            function parseEvents(event) {
              if (event.type == 'click') {
                handleItemClick(event);
              }
              if (event.type == 'focusout' && !closeTimeout) {
                closeTimeout = $timeout(function() {
                  vm.close();
                }, 100, false);
              }
              if (event.type == 'focusin' && closeTimeout) {
                $timeout.cancel(closeTimeout);
                closeTimeout = null;
              }
            }
            function resetActionIndex() {
              vm.currentActionIndex = -1;
            }
            function setupWatchers() {
              $scope.$watch('vm.direction', function(newDir, oldDir) {
                $animate.removeClass($element, 'md-' + oldDir);
                $animate.addClass($element, 'md-' + newDir);
                resetActionIndex();
              });
              var trigger,
                  actions;
              $scope.$watch('vm.isOpen', function(isOpen) {
                resetActionIndex();
                if (!trigger || !actions) {
                  trigger = getTriggerElement();
                  actions = getActionsElement();
                }
                if (isOpen) {
                  enableKeyboard();
                } else {
                  disableKeyboard();
                }
                var toAdd = isOpen ? 'md-is-open' : '';
                var toRemove = isOpen ? '' : 'md-is-open';
                trigger.attr('aria-haspopup', true);
                trigger.attr('aria-expanded', isOpen);
                actions.attr('aria-hidden', !isOpen);
                $animate.setClass($element, toAdd, toRemove);
              });
            }
            function fireInitialAnimations() {
              if ($element[0].scrollHeight > 0) {
                $animate.addClass($element, '_md-animations-ready').then(function() {
                  $element.removeClass('_md-animations-waiting');
                });
              } else if (initialAnimationAttempts < 10) {
                $timeout(fireInitialAnimations, 100);
                initialAnimationAttempts = initialAnimationAttempts + 1;
              }
            }
            function enableKeyboard() {
              $element.on('keydown', keyPressed);
              $mdUtil.nextTick(function() {
                angular.element(document).on('click touchend', checkForOutsideClick);
              });
            }
            function disableKeyboard() {
              $element.off('keydown', keyPressed);
              angular.element(document).off('click touchend', checkForOutsideClick);
            }
            function checkForOutsideClick(event) {
              if (event.target) {
                var closestTrigger = $mdUtil.getClosest(event.target, 'md-fab-trigger');
                var closestActions = $mdUtil.getClosest(event.target, 'md-fab-actions');
                if (!closestTrigger && !closestActions) {
                  vm.close();
                }
              }
            }
            function keyPressed(event) {
              switch (event.which) {
                case $mdConstant.KEY_CODE.ESCAPE:
                  vm.close();
                  event.preventDefault();
                  return false;
                case $mdConstant.KEY_CODE.LEFT_ARROW:
                  doKeyLeft(event);
                  return false;
                case $mdConstant.KEY_CODE.UP_ARROW:
                  doKeyUp(event);
                  return false;
                case $mdConstant.KEY_CODE.RIGHT_ARROW:
                  doKeyRight(event);
                  return false;
                case $mdConstant.KEY_CODE.DOWN_ARROW:
                  doKeyDown(event);
                  return false;
              }
            }
            function doActionPrev(event) {
              focusAction(event, -1);
            }
            function doActionNext(event) {
              focusAction(event, 1);
            }
            function focusAction(event, direction) {
              var actions = resetActionTabIndexes();
              vm.currentActionIndex = vm.currentActionIndex + direction;
              vm.currentActionIndex = Math.min(actions.length - 1, vm.currentActionIndex);
              vm.currentActionIndex = Math.max(0, vm.currentActionIndex);
              var focusElement = angular.element(actions[vm.currentActionIndex]).children()[0];
              angular.element(focusElement).attr('tabindex', 0);
              focusElement.focus();
              event.preventDefault();
              event.stopImmediatePropagation();
            }
            function resetActionTabIndexes() {
              var actions = getActionsElement()[0].querySelectorAll('.md-fab-action-item');
              angular.forEach(actions, function(action) {
                angular.element(angular.element(action).children()[0]).attr('tabindex', -1);
              });
              return actions;
            }
            function doKeyLeft(event) {
              if (vm.direction === 'left') {
                doActionNext(event);
              } else {
                doActionPrev(event);
              }
            }
            function doKeyUp(event) {
              if (vm.direction === 'down') {
                doActionPrev(event);
              } else {
                doActionNext(event);
              }
            }
            function doKeyRight(event) {
              if (vm.direction === 'left') {
                doActionPrev(event);
              } else {
                doActionNext(event);
              }
            }
            function doKeyDown(event) {
              if (vm.direction === 'up') {
                doActionPrev(event);
              } else {
                doActionNext(event);
              }
            }
            function isTrigger(element) {
              return $mdUtil.getClosest(element, 'md-fab-trigger');
            }
            function isAction(element) {
              return $mdUtil.getClosest(element, 'md-fab-actions');
            }
            function handleItemClick(event) {
              if (isTrigger(event.target)) {
                vm.toggle();
              }
              if (isAction(event.target)) {
                vm.close();
              }
            }
            function getTriggerElement() {
              return $element.find('md-fab-trigger');
            }
            function getActionsElement() {
              return $element.find('md-fab-actions');
            }
          }
          MdFabController.$inject = ["$scope", "$element", "$animate", "$mdUtil", "$mdConstant", "$timeout"];
        })();
      })();
      (function() {
        "use strict";
        (function() {
          'use strict';
          var cssAnimationDuration = 300;
          angular.module('material.components.fabSpeedDial', ['material.core', 'material.components.fabShared', 'material.components.fabActions']).directive('mdFabSpeedDial', MdFabSpeedDialDirective).animation('.md-fling', MdFabSpeedDialFlingAnimation).animation('.md-scale', MdFabSpeedDialScaleAnimation).service('mdFabSpeedDialFlingAnimation', MdFabSpeedDialFlingAnimation).service('mdFabSpeedDialScaleAnimation', MdFabSpeedDialScaleAnimation);
          function MdFabSpeedDialDirective() {
            return {
              restrict: 'E',
              scope: {
                direction: '@?mdDirection',
                isOpen: '=?mdOpen'
              },
              bindToController: true,
              controller: 'MdFabController',
              controllerAs: 'vm',
              link: FabSpeedDialLink
            };
            function FabSpeedDialLink(scope, element) {
              element.prepend('<div class="_md-css-variables"></div>');
            }
          }
          function MdFabSpeedDialFlingAnimation($timeout) {
            function delayDone(done) {
              $timeout(done, cssAnimationDuration, false);
            }
            function runAnimation(element) {
              if (element.hasClass('_md-animations-waiting') && !element.hasClass('_md-animations-ready')) {
                return;
              }
              var el = element[0];
              var ctrl = element.controller('mdFabSpeedDial');
              var items = el.querySelectorAll('.md-fab-action-item');
              var triggerElement = el.querySelector('md-fab-trigger');
              var variablesElement = el.querySelector('._md-css-variables');
              var startZIndex = parseInt(window.getComputedStyle(variablesElement).zIndex);
              angular.forEach(items, function(item, index) {
                var styles = item.style;
                styles.transform = styles.webkitTransform = '';
                styles.transitionDelay = '';
                styles.opacity = 1;
                styles.zIndex = (items.length - index) + startZIndex;
              });
              triggerElement.style.zIndex = startZIndex + items.length + 1;
              if (!ctrl.isOpen) {
                angular.forEach(items, function(item, index) {
                  var newPosition,
                      axis;
                  var styles = item.style;
                  var triggerItemHeightOffset = (triggerElement.clientHeight - item.clientHeight) / 2;
                  var triggerItemWidthOffset = (triggerElement.clientWidth - item.clientWidth) / 2;
                  switch (ctrl.direction) {
                    case 'up':
                      newPosition = (item.scrollHeight * (index + 1) + triggerItemHeightOffset);
                      axis = 'Y';
                      break;
                    case 'down':
                      newPosition = -(item.scrollHeight * (index + 1) + triggerItemHeightOffset);
                      axis = 'Y';
                      break;
                    case 'left':
                      newPosition = (item.scrollWidth * (index + 1) + triggerItemWidthOffset);
                      axis = 'X';
                      break;
                    case 'right':
                      newPosition = -(item.scrollWidth * (index + 1) + triggerItemWidthOffset);
                      axis = 'X';
                      break;
                  }
                  var newTranslate = 'translate' + axis + '(' + newPosition + 'px)';
                  styles.transform = styles.webkitTransform = newTranslate;
                });
              }
            }
            return {
              addClass: function(element, className, done) {
                if (element.hasClass('md-fling')) {
                  runAnimation(element);
                  delayDone(done);
                } else {
                  done();
                }
              },
              removeClass: function(element, className, done) {
                runAnimation(element);
                delayDone(done);
              }
            };
          }
          MdFabSpeedDialFlingAnimation.$inject = ["$timeout"];
          function MdFabSpeedDialScaleAnimation($timeout) {
            function delayDone(done) {
              $timeout(done, cssAnimationDuration, false);
            }
            var delay = 65;
            function runAnimation(element) {
              var el = element[0];
              var ctrl = element.controller('mdFabSpeedDial');
              var items = el.querySelectorAll('.md-fab-action-item');
              var variablesElement = el.querySelector('._md-css-variables');
              var startZIndex = parseInt(window.getComputedStyle(variablesElement).zIndex);
              angular.forEach(items, function(item, index) {
                var styles = item.style,
                    offsetDelay = index * delay;
                styles.opacity = ctrl.isOpen ? 1 : 0;
                styles.transform = styles.webkitTransform = ctrl.isOpen ? 'scale(1)' : 'scale(0)';
                styles.transitionDelay = (ctrl.isOpen ? offsetDelay : (items.length - offsetDelay)) + 'ms';
                styles.zIndex = (items.length - index) + startZIndex;
              });
            }
            return {
              addClass: function(element, className, done) {
                runAnimation(element);
                delayDone(done);
              },
              removeClass: function(element, className, done) {
                runAnimation(element);
                delayDone(done);
              }
            };
          }
          MdFabSpeedDialScaleAnimation.$inject = ["$timeout"];
        })();
      })();
      (function() {
        "use strict";
        (function() {
          'use strict';
          angular.module('material.components.fabToolbar', ['material.core', 'material.components.fabShared', 'material.components.fabActions']).directive('mdFabToolbar', MdFabToolbarDirective).animation('.md-fab-toolbar', MdFabToolbarAnimation).service('mdFabToolbarAnimation', MdFabToolbarAnimation);
          function MdFabToolbarDirective() {
            return {
              restrict: 'E',
              transclude: true,
              template: '<div class="_md-fab-toolbar-wrapper">' + '  <div class="_md-fab-toolbar-content" ng-transclude></div>' + '</div>',
              scope: {
                direction: '@?mdDirection',
                isOpen: '=?mdOpen'
              },
              bindToController: true,
              controller: 'MdFabController',
              controllerAs: 'vm',
              link: link
            };
            function link(scope, element, attributes) {
              element.addClass('md-fab-toolbar');
              element.find('md-fab-trigger').find('button').prepend('<div class="_md-fab-toolbar-background"></div>');
            }
          }
          function MdFabToolbarAnimation() {
            function runAnimation(element, className, done) {
              if (!className) {
                return;
              }
              var el = element[0];
              var ctrl = element.controller('mdFabToolbar');
              var backgroundElement = el.querySelector('._md-fab-toolbar-background');
              var triggerElement = el.querySelector('md-fab-trigger button');
              var toolbarElement = el.querySelector('md-toolbar');
              var iconElement = el.querySelector('md-fab-trigger button md-icon');
              var actions = element.find('md-fab-actions').children();
              if (triggerElement && backgroundElement) {
                var color = window.getComputedStyle(triggerElement).getPropertyValue('background-color');
                var width = el.offsetWidth;
                var height = el.offsetHeight;
                var scale = 2 * (width / triggerElement.offsetWidth);
                backgroundElement.style.backgroundColor = color;
                backgroundElement.style.borderRadius = width + 'px';
                if (ctrl.isOpen) {
                  toolbarElement.style.pointerEvents = 'inherit';
                  backgroundElement.style.width = triggerElement.offsetWidth + 'px';
                  backgroundElement.style.height = triggerElement.offsetHeight + 'px';
                  backgroundElement.style.transform = 'scale(' + scale + ')';
                  backgroundElement.style.transitionDelay = '0ms';
                  iconElement && (iconElement.style.transitionDelay = '.3s');
                  angular.forEach(actions, function(action, index) {
                    action.style.transitionDelay = (actions.length - index) * 25 + 'ms';
                  });
                } else {
                  toolbarElement.style.pointerEvents = 'none';
                  backgroundElement.style.transform = 'scale(1)';
                  backgroundElement.style.top = '0';
                  if (element.hasClass('md-right')) {
                    backgroundElement.style.left = '0';
                    backgroundElement.style.right = null;
                  }
                  if (element.hasClass('md-left')) {
                    backgroundElement.style.right = '0';
                    backgroundElement.style.left = null;
                  }
                  backgroundElement.style.transitionDelay = '200ms';
                  iconElement && (iconElement.style.transitionDelay = '0ms');
                  angular.forEach(actions, function(action, index) {
                    action.style.transitionDelay = 200 + (index * 25) + 'ms';
                  });
                }
              }
            }
            return {
              addClass: function(element, className, done) {
                runAnimation(element, className, done);
                done();
              },
              removeClass: function(element, className, done) {
                runAnimation(element, className, done);
                done();
              }
            };
          }
        })();
      })();
      (function() {
        "use strict";
        angular.module('material.components.gridList', ['material.core']).directive('mdGridList', GridListDirective).directive('mdGridTile', GridTileDirective).directive('mdGridTileFooter', GridTileCaptionDirective).directive('mdGridTileHeader', GridTileCaptionDirective).factory('$mdGridLayout', GridLayoutFactory);
        function GridListDirective($interpolate, $mdConstant, $mdGridLayout, $mdMedia) {
          return {
            restrict: 'E',
            controller: GridListController,
            scope: {mdOnLayout: '&'},
            link: postLink
          };
          function postLink(scope, element, attrs, ctrl) {
            element.addClass('_md');
            element.attr('role', 'list');
            ctrl.layoutDelegate = layoutDelegate;
            var invalidateLayout = angular.bind(ctrl, ctrl.invalidateLayout),
                unwatchAttrs = watchMedia();
            scope.$on('$destroy', unwatchMedia);
            function watchMedia() {
              for (var mediaName in $mdConstant.MEDIA) {
                $mdMedia(mediaName);
                $mdMedia.getQuery($mdConstant.MEDIA[mediaName]).addListener(invalidateLayout);
              }
              return $mdMedia.watchResponsiveAttributes(['md-cols', 'md-row-height', 'md-gutter'], attrs, layoutIfMediaMatch);
            }
            function unwatchMedia() {
              ctrl.layoutDelegate = angular.noop;
              unwatchAttrs();
              for (var mediaName in $mdConstant.MEDIA) {
                $mdMedia.getQuery($mdConstant.MEDIA[mediaName]).removeListener(invalidateLayout);
              }
            }
            function layoutIfMediaMatch(mediaName) {
              if (mediaName == null) {
                ctrl.invalidateLayout();
              } else if ($mdMedia(mediaName)) {
                ctrl.invalidateLayout();
              }
            }
            var lastLayoutProps;
            function layoutDelegate(tilesInvalidated) {
              var tiles = getTileElements();
              var props = {
                tileSpans: getTileSpans(tiles),
                colCount: getColumnCount(),
                rowMode: getRowMode(),
                rowHeight: getRowHeight(),
                gutter: getGutter()
              };
              if (!tilesInvalidated && angular.equals(props, lastLayoutProps)) {
                return;
              }
              var performance = $mdGridLayout(props.colCount, props.tileSpans, tiles).map(function(tilePositions, rowCount) {
                return {
                  grid: {
                    element: element,
                    style: getGridStyle(props.colCount, rowCount, props.gutter, props.rowMode, props.rowHeight)
                  },
                  tiles: tilePositions.map(function(ps, i) {
                    return {
                      element: angular.element(tiles[i]),
                      style: getTileStyle(ps.position, ps.spans, props.colCount, rowCount, props.gutter, props.rowMode, props.rowHeight)
                    };
                  })
                };
              }).reflow().performance();
              scope.mdOnLayout({$event: {performance: performance}});
              lastLayoutProps = props;
            }
            var startSymbol = $interpolate.startSymbol();
            var endSymbol = $interpolate.endSymbol();
            function expr(exprStr) {
              return startSymbol + exprStr + endSymbol;
            }
            var UNIT = $interpolate(expr('share') + '% - (' + expr('gutter') + ' * ' + expr('gutterShare') + ')');
            var POSITION = $interpolate('calc((' + expr('unit') + ' + ' + expr('gutter') + ') * ' + expr('offset') + ')');
            var DIMENSION = $interpolate('calc((' + expr('unit') + ') * ' + expr('span') + ' + (' + expr('span') + ' - 1) * ' + expr('gutter') + ')');
            function getTileStyle(position, spans, colCount, rowCount, gutter, rowMode, rowHeight) {
              var hShare = (1 / colCount) * 100;
              var hGutterShare = (colCount - 1) / colCount;
              var hUnit = UNIT({
                share: hShare,
                gutterShare: hGutterShare,
                gutter: gutter
              });
              var style = {
                left: POSITION({
                  unit: hUnit,
                  offset: position.col,
                  gutter: gutter
                }),
                width: DIMENSION({
                  unit: hUnit,
                  span: spans.col,
                  gutter: gutter
                }),
                paddingTop: '',
                marginTop: '',
                top: '',
                height: ''
              };
              switch (rowMode) {
                case 'fixed':
                  style.top = POSITION({
                    unit: rowHeight,
                    offset: position.row,
                    gutter: gutter
                  });
                  style.height = DIMENSION({
                    unit: rowHeight,
                    span: spans.row,
                    gutter: gutter
                  });
                  break;
                case 'ratio':
                  var vShare = hShare / rowHeight;
                  var vUnit = UNIT({
                    share: vShare,
                    gutterShare: hGutterShare,
                    gutter: gutter
                  });
                  style.paddingTop = DIMENSION({
                    unit: vUnit,
                    span: spans.row,
                    gutter: gutter
                  });
                  style.marginTop = POSITION({
                    unit: vUnit,
                    offset: position.row,
                    gutter: gutter
                  });
                  break;
                case 'fit':
                  var vGutterShare = (rowCount - 1) / rowCount;
                  var vShare = (1 / rowCount) * 100;
                  var vUnit = UNIT({
                    share: vShare,
                    gutterShare: vGutterShare,
                    gutter: gutter
                  });
                  style.top = POSITION({
                    unit: vUnit,
                    offset: position.row,
                    gutter: gutter
                  });
                  style.height = DIMENSION({
                    unit: vUnit,
                    span: spans.row,
                    gutter: gutter
                  });
                  break;
              }
              return style;
            }
            function getGridStyle(colCount, rowCount, gutter, rowMode, rowHeight) {
              var style = {};
              switch (rowMode) {
                case 'fixed':
                  style.height = DIMENSION({
                    unit: rowHeight,
                    span: rowCount,
                    gutter: gutter
                  });
                  style.paddingBottom = '';
                  break;
                case 'ratio':
                  var hGutterShare = colCount === 1 ? 0 : (colCount - 1) / colCount,
                      hShare = (1 / colCount) * 100,
                      vShare = hShare * (1 / rowHeight),
                      vUnit = UNIT({
                        share: vShare,
                        gutterShare: hGutterShare,
                        gutter: gutter
                      });
                  style.height = '';
                  style.paddingBottom = DIMENSION({
                    unit: vUnit,
                    span: rowCount,
                    gutter: gutter
                  });
                  break;
                case 'fit':
                  break;
              }
              return style;
            }
            function getTileElements() {
              return [].filter.call(element.children(), function(ele) {
                return ele.tagName == 'MD-GRID-TILE' && !ele.$$mdDestroyed;
              });
            }
            function getTileSpans(tileElements) {
              return [].map.call(tileElements, function(ele) {
                var ctrl = angular.element(ele).controller('mdGridTile');
                return {
                  row: parseInt($mdMedia.getResponsiveAttribute(ctrl.$attrs, 'md-rowspan'), 10) || 1,
                  col: parseInt($mdMedia.getResponsiveAttribute(ctrl.$attrs, 'md-colspan'), 10) || 1
                };
              });
            }
            function getColumnCount() {
              var colCount = parseInt($mdMedia.getResponsiveAttribute(attrs, 'md-cols'), 10);
              if (isNaN(colCount)) {
                throw 'md-grid-list: md-cols attribute was not found, or contained a non-numeric value';
              }
              return colCount;
            }
            function getGutter() {
              return applyDefaultUnit($mdMedia.getResponsiveAttribute(attrs, 'md-gutter') || 1);
            }
            function getRowHeight() {
              var rowHeight = $mdMedia.getResponsiveAttribute(attrs, 'md-row-height');
              if (!rowHeight) {
                throw 'md-grid-list: md-row-height attribute was not found';
              }
              switch (getRowMode()) {
                case 'fixed':
                  return applyDefaultUnit(rowHeight);
                case 'ratio':
                  var whRatio = rowHeight.split(':');
                  return parseFloat(whRatio[0]) / parseFloat(whRatio[1]);
                case 'fit':
                  return 0;
              }
            }
            function getRowMode() {
              var rowHeight = $mdMedia.getResponsiveAttribute(attrs, 'md-row-height');
              if (!rowHeight) {
                throw 'md-grid-list: md-row-height attribute was not found';
              }
              if (rowHeight == 'fit') {
                return 'fit';
              } else if (rowHeight.indexOf(':') !== -1) {
                return 'ratio';
              } else {
                return 'fixed';
              }
            }
            function applyDefaultUnit(val) {
              return /\D$/.test(val) ? val : val + 'px';
            }
          }
        }
        GridListDirective.$inject = ["$interpolate", "$mdConstant", "$mdGridLayout", "$mdMedia"];
        function GridListController($mdUtil) {
          this.layoutInvalidated = false;
          this.tilesInvalidated = false;
          this.$timeout_ = $mdUtil.nextTick;
          this.layoutDelegate = angular.noop;
        }
        GridListController.$inject = ["$mdUtil"];
        GridListController.prototype = {
          invalidateTiles: function() {
            this.tilesInvalidated = true;
            this.invalidateLayout();
          },
          invalidateLayout: function() {
            if (this.layoutInvalidated) {
              return;
            }
            this.layoutInvalidated = true;
            this.$timeout_(angular.bind(this, this.layout));
          },
          layout: function() {
            try {
              this.layoutDelegate(this.tilesInvalidated);
            } finally {
              this.layoutInvalidated = false;
              this.tilesInvalidated = false;
            }
          }
        };
        function GridLayoutFactory($mdUtil) {
          var defaultAnimator = GridTileAnimator;
          GridLayout.animateWith = function(customAnimator) {
            defaultAnimator = !angular.isFunction(customAnimator) ? GridTileAnimator : customAnimator;
          };
          return GridLayout;
          function GridLayout(colCount, tileSpans) {
            var self,
                layoutInfo,
                gridStyles,
                layoutTime,
                mapTime,
                reflowTime;
            layoutTime = $mdUtil.time(function() {
              layoutInfo = calculateGridFor(colCount, tileSpans);
            });
            return self = {
              layoutInfo: function() {
                return layoutInfo;
              },
              map: function(updateFn) {
                mapTime = $mdUtil.time(function() {
                  var info = self.layoutInfo();
                  gridStyles = updateFn(info.positioning, info.rowCount);
                });
                return self;
              },
              reflow: function(animatorFn) {
                reflowTime = $mdUtil.time(function() {
                  var animator = animatorFn || defaultAnimator;
                  animator(gridStyles.grid, gridStyles.tiles);
                });
                return self;
              },
              performance: function() {
                return {
                  tileCount: tileSpans.length,
                  layoutTime: layoutTime,
                  mapTime: mapTime,
                  reflowTime: reflowTime,
                  totalTime: layoutTime + mapTime + reflowTime
                };
              }
            };
          }
          function GridTileAnimator(grid, tiles) {
            grid.element.css(grid.style);
            tiles.forEach(function(t) {
              t.element.css(t.style);
            });
          }
          function calculateGridFor(colCount, tileSpans) {
            var curCol = 0,
                curRow = 0,
                spaceTracker = newSpaceTracker();
            return {
              positioning: tileSpans.map(function(spans, i) {
                return {
                  spans: spans,
                  position: reserveSpace(spans, i)
                };
              }),
              rowCount: curRow + Math.max.apply(Math, spaceTracker)
            };
            function reserveSpace(spans, i) {
              if (spans.col > colCount) {
                throw 'md-grid-list: Tile at position ' + i + ' has a colspan ' + '(' + spans.col + ') that exceeds the column count ' + '(' + colCount + ')';
              }
              var start = 0,
                  end = 0;
              while (end - start < spans.col) {
                if (curCol >= colCount) {
                  nextRow();
                  continue;
                }
                start = spaceTracker.indexOf(0, curCol);
                if (start === -1 || (end = findEnd(start + 1)) === -1) {
                  start = end = 0;
                  nextRow();
                  continue;
                }
                curCol = end + 1;
              }
              adjustRow(start, spans.col, spans.row);
              curCol = start + spans.col;
              return {
                col: start,
                row: curRow
              };
            }
            function nextRow() {
              curCol = 0;
              curRow++;
              adjustRow(0, colCount, -1);
            }
            function adjustRow(from, cols, by) {
              for (var i = from; i < from + cols; i++) {
                spaceTracker[i] = Math.max(spaceTracker[i] + by, 0);
              }
            }
            function findEnd(start) {
              var i;
              for (i = start; i < spaceTracker.length; i++) {
                if (spaceTracker[i] !== 0) {
                  return i;
                }
              }
              if (i === spaceTracker.length) {
                return i;
              }
            }
            function newSpaceTracker() {
              var tracker = [];
              for (var i = 0; i < colCount; i++) {
                tracker.push(0);
              }
              return tracker;
            }
          }
        }
        GridLayoutFactory.$inject = ["$mdUtil"];
        function GridTileDirective($mdMedia) {
          return {
            restrict: 'E',
            require: '^mdGridList',
            template: '<figure ng-transclude></figure>',
            transclude: true,
            scope: {},
            controller: ["$attrs", function($attrs) {
              this.$attrs = $attrs;
            }],
            link: postLink
          };
          function postLink(scope, element, attrs, gridCtrl) {
            element.attr('role', 'listitem');
            var unwatchAttrs = $mdMedia.watchResponsiveAttributes(['md-colspan', 'md-rowspan'], attrs, angular.bind(gridCtrl, gridCtrl.invalidateLayout));
            gridCtrl.invalidateTiles();
            scope.$on('$destroy', function() {
              element[0].$$mdDestroyed = true;
              unwatchAttrs();
              gridCtrl.invalidateLayout();
            });
            if (angular.isDefined(scope.$parent.$index)) {
              scope.$watch(function() {
                return scope.$parent.$index;
              }, function indexChanged(newIdx, oldIdx) {
                if (newIdx === oldIdx) {
                  return;
                }
                gridCtrl.invalidateTiles();
              });
            }
          }
        }
        GridTileDirective.$inject = ["$mdMedia"];
        function GridTileCaptionDirective() {
          return {
            template: '<figcaption ng-transclude></figcaption>',
            transclude: true
          };
        }
      })();
      (function() {
        "use strict";
        angular.module('material.components.icon', ['material.core']);
      })();
      (function() {
        "use strict";
        angular.module('material.components.input', ['material.core']).directive('mdInputContainer', mdInputContainerDirective).directive('label', labelDirective).directive('input', inputTextareaDirective).directive('textarea', inputTextareaDirective).directive('mdMaxlength', mdMaxlengthDirective).directive('placeholder', placeholderDirective).directive('ngMessages', ngMessagesDirective).directive('ngMessage', ngMessageDirective).directive('ngMessageExp', ngMessageDirective).directive('mdSelectOnFocus', mdSelectOnFocusDirective).animation('.md-input-invalid', mdInputInvalidMessagesAnimation).animation('.md-input-messages-animation', ngMessagesAnimation).animation('.md-input-message-animation', ngMessageAnimation);
        function mdInputContainerDirective($mdTheming, $parse) {
          var INPUT_TAGS = ['INPUT', 'TEXTAREA', 'SELECT', 'MD-SELECT'];
          var LEFT_SELECTORS = INPUT_TAGS.reduce(function(selectors, isel) {
            return selectors.concat(['md-icon ~ ' + isel, '.md-icon ~ ' + isel]);
          }, []).join(",");
          var RIGHT_SELECTORS = INPUT_TAGS.reduce(function(selectors, isel) {
            return selectors.concat([isel + ' ~ md-icon', isel + ' ~ .md-icon']);
          }, []).join(",");
          ContainerCtrl.$inject = ["$scope", "$element", "$attrs", "$animate"];
          return {
            restrict: 'E',
            link: postLink,
            controller: ContainerCtrl
          };
          function postLink(scope, element) {
            $mdTheming(element);
            var leftIcon = element[0].querySelector(LEFT_SELECTORS);
            var rightIcon = element[0].querySelector(RIGHT_SELECTORS);
            if (leftIcon) {
              element.addClass('md-icon-left');
            }
            if (rightIcon) {
              element.addClass('md-icon-right');
            }
          }
          function ContainerCtrl($scope, $element, $attrs, $animate) {
            var self = this;
            self.isErrorGetter = $attrs.mdIsError && $parse($attrs.mdIsError);
            self.delegateClick = function() {
              self.input.focus();
            };
            self.element = $element;
            self.setFocused = function(isFocused) {
              $element.toggleClass('md-input-focused', !!isFocused);
            };
            self.setHasValue = function(hasValue) {
              $element.toggleClass('md-input-has-value', !!hasValue);
            };
            self.setHasPlaceholder = function(hasPlaceholder) {
              $element.toggleClass('md-input-has-placeholder', !!hasPlaceholder);
            };
            self.setInvalid = function(isInvalid) {
              if (isInvalid) {
                $animate.addClass($element, 'md-input-invalid');
              } else {
                $animate.removeClass($element, 'md-input-invalid');
              }
            };
            $scope.$watch(function() {
              return self.label && self.input;
            }, function(hasLabelAndInput) {
              if (hasLabelAndInput && !self.label.attr('for')) {
                self.label.attr('for', self.input.attr('id'));
              }
            });
          }
        }
        mdInputContainerDirective.$inject = ["$mdTheming", "$parse"];
        function labelDirective() {
          return {
            restrict: 'E',
            require: '^?mdInputContainer',
            link: function(scope, element, attr, containerCtrl) {
              if (!containerCtrl || attr.mdNoFloat || element.hasClass('_md-container-ignore'))
                return;
              containerCtrl.label = element;
              scope.$on('$destroy', function() {
                containerCtrl.label = null;
              });
            }
          };
        }
        function inputTextareaDirective($mdUtil, $window, $mdAria, $timeout, $mdGesture) {
          return {
            restrict: 'E',
            require: ['^?mdInputContainer', '?ngModel'],
            link: postLink
          };
          function postLink(scope, element, attr, ctrls) {
            var containerCtrl = ctrls[0];
            var hasNgModel = !!ctrls[1];
            var ngModelCtrl = ctrls[1] || $mdUtil.fakeNgModel();
            var isReadonly = angular.isDefined(attr.readonly);
            var mdNoAsterisk = $mdUtil.parseAttributeBoolean(attr.mdNoAsterisk);
            var tagName = element[0].tagName.toLowerCase();
            if (!containerCtrl)
              return;
            if (attr.type === 'hidden') {
              element.attr('aria-hidden', 'true');
              return;
            } else if (containerCtrl.input) {
              throw new Error("<md-input-container> can only have *one* <input>, <textarea> or <md-select> child element!");
            }
            containerCtrl.input = element;
            setupAttributeWatchers();
            var errorsSpacer = angular.element('<div class="md-errors-spacer">');
            element.after(errorsSpacer);
            if (!containerCtrl.label) {
              $mdAria.expect(element, 'aria-label', attr.placeholder);
            }
            element.addClass('md-input');
            if (!element.attr('id')) {
              element.attr('id', 'input_' + $mdUtil.nextUid());
            }
            if (tagName === 'input' && attr.type === 'number' && attr.min && attr.max && !attr.step) {
              element.attr('step', 'any');
            } else if (tagName === 'textarea') {
              setupTextarea();
            }
            if (!hasNgModel) {
              inputCheckValue();
            }
            var isErrorGetter = containerCtrl.isErrorGetter || function() {
              return ngModelCtrl.$invalid && (ngModelCtrl.$touched || $mdUtil.isParentFormSubmitted(element));
            };
            scope.$watch(isErrorGetter, containerCtrl.setInvalid);
            if (attr.ngValue) {
              attr.$observe('value', inputCheckValue);
            }
            ngModelCtrl.$parsers.push(ngModelPipelineCheckValue);
            ngModelCtrl.$formatters.push(ngModelPipelineCheckValue);
            element.on('input', inputCheckValue);
            if (!isReadonly) {
              element.on('focus', function(ev) {
                $mdUtil.nextTick(function() {
                  containerCtrl.setFocused(true);
                });
              }).on('blur', function(ev) {
                $mdUtil.nextTick(function() {
                  containerCtrl.setFocused(false);
                  inputCheckValue();
                });
              });
            }
            scope.$on('$destroy', function() {
              containerCtrl.setFocused(false);
              containerCtrl.setHasValue(false);
              containerCtrl.input = null;
            });
            function ngModelPipelineCheckValue(arg) {
              containerCtrl.setHasValue(!ngModelCtrl.$isEmpty(arg));
              return arg;
            }
            function setupAttributeWatchers() {
              if (containerCtrl.label) {
                attr.$observe('required', function(value) {
                  containerCtrl.label.toggleClass('md-required', value && !mdNoAsterisk);
                });
              }
            }
            function inputCheckValue() {
              containerCtrl.setHasValue(element.val().length > 0 || (element[0].validity || {}).badInput);
            }
            function setupTextarea() {
              var isAutogrowing = !attr.hasOwnProperty('mdNoAutogrow');
              attachResizeHandle();
              if (!isAutogrowing)
                return;
              var minRows = attr.hasOwnProperty('rows') ? parseInt(attr.rows) : NaN;
              var maxRows = attr.hasOwnProperty('maxRows') ? parseInt(attr.maxRows) : NaN;
              var scopeResizeListener = scope.$on('md-resize-textarea', growTextarea);
              var lineHeight = null;
              var node = element[0];
              $timeout(function() {
                $mdUtil.nextTick(growTextarea);
              }, 10, false);
              element.on('input', growTextarea);
              if (hasNgModel) {
                ngModelCtrl.$formatters.push(formattersListener);
              }
              if (!minRows) {
                element.attr('rows', 1);
              }
              angular.element($window).on('resize', growTextarea);
              scope.$on('$destroy', disableAutogrow);
              function growTextarea() {
                element.attr('rows', 1).css('height', 'auto').addClass('md-no-flex');
                var height = getHeight();
                if (!lineHeight) {
                  var originalPadding = element[0].style.padding || '';
                  lineHeight = element.css('padding', 0).prop('offsetHeight');
                  element[0].style.padding = originalPadding;
                }
                if (minRows && lineHeight) {
                  height = Math.max(height, lineHeight * minRows);
                }
                if (maxRows && lineHeight) {
                  var maxHeight = lineHeight * maxRows;
                  if (maxHeight < height) {
                    element.attr('md-no-autogrow', '');
                    height = maxHeight;
                  } else {
                    element.removeAttr('md-no-autogrow');
                  }
                }
                if (lineHeight) {
                  element.attr('rows', Math.round(height / lineHeight));
                }
                element.css('height', height + 'px').removeClass('md-no-flex');
              }
              function getHeight() {
                var offsetHeight = node.offsetHeight;
                var line = node.scrollHeight - offsetHeight;
                return offsetHeight + Math.max(line, 0);
              }
              function formattersListener(value) {
                $mdUtil.nextTick(growTextarea);
                return value;
              }
              function disableAutogrow() {
                if (!isAutogrowing)
                  return;
                isAutogrowing = false;
                angular.element($window).off('resize', growTextarea);
                scopeResizeListener && scopeResizeListener();
                element.attr('md-no-autogrow', '').off('input', growTextarea);
                if (hasNgModel) {
                  var listenerIndex = ngModelCtrl.$formatters.indexOf(formattersListener);
                  if (listenerIndex > -1) {
                    ngModelCtrl.$formatters.splice(listenerIndex, 1);
                  }
                }
              }
              function attachResizeHandle() {
                if (attr.hasOwnProperty('mdNoResize'))
                  return;
                var handle = angular.element('<div class="md-resize-handle"></div>');
                var isDragging = false;
                var dragStart = null;
                var startHeight = 0;
                var container = containerCtrl.element;
                var dragGestureHandler = $mdGesture.register(handle, 'drag', {horizontal: false});
                element.after(handle);
                handle.on('mousedown', onMouseDown);
                container.on('$md.dragstart', onDragStart).on('$md.drag', onDrag).on('$md.dragend', onDragEnd);
                scope.$on('$destroy', function() {
                  handle.off('mousedown', onMouseDown).remove();
                  container.off('$md.dragstart', onDragStart).off('$md.drag', onDrag).off('$md.dragend', onDragEnd);
                  dragGestureHandler();
                  handle = null;
                  container = null;
                  dragGestureHandler = null;
                });
                function onMouseDown(ev) {
                  ev.preventDefault();
                  isDragging = true;
                  dragStart = ev.clientY;
                  startHeight = parseFloat(element.css('height')) || element.prop('offsetHeight');
                }
                function onDragStart(ev) {
                  if (!isDragging)
                    return;
                  ev.preventDefault();
                  disableAutogrow();
                  container.addClass('md-input-resized');
                }
                function onDrag(ev) {
                  if (!isDragging)
                    return;
                  element.css('height', startHeight + (ev.pointer.y - dragStart) - $mdUtil.scrollTop() + 'px');
                }
                function onDragEnd(ev) {
                  if (!isDragging)
                    return;
                  isDragging = false;
                  container.removeClass('md-input-resized');
                }
              }
              if (attr.hasOwnProperty('mdDetectHidden')) {
                var handleHiddenChange = function() {
                  var wasHidden = false;
                  return function() {
                    var isHidden = node.offsetHeight === 0;
                    if (isHidden === false && wasHidden === true) {
                      growTextarea();
                    }
                    wasHidden = isHidden;
                  };
                }();
                scope.$watch(function() {
                  $mdUtil.nextTick(handleHiddenChange, false);
                  return true;
                });
              }
            }
          }
        }
        inputTextareaDirective.$inject = ["$mdUtil", "$window", "$mdAria", "$timeout", "$mdGesture"];
        function mdMaxlengthDirective($animate, $mdUtil) {
          return {
            restrict: 'A',
            require: ['ngModel', '^mdInputContainer'],
            link: postLink
          };
          function postLink(scope, element, attr, ctrls) {
            var maxlength;
            var ngModelCtrl = ctrls[0];
            var containerCtrl = ctrls[1];
            var charCountEl,
                errorsSpacer;
            $mdUtil.nextTick(function() {
              errorsSpacer = angular.element(containerCtrl.element[0].querySelector('.md-errors-spacer'));
              charCountEl = angular.element('<div class="md-char-counter">');
              errorsSpacer.append(charCountEl);
              attr.$set('ngTrim', 'false');
              ngModelCtrl.$formatters.push(renderCharCount);
              ngModelCtrl.$viewChangeListeners.push(renderCharCount);
              element.on('input keydown keyup', function() {
                renderCharCount();
              });
              scope.$watch(attr.mdMaxlength, function(value) {
                maxlength = value;
                if (angular.isNumber(value) && value > 0) {
                  if (!charCountEl.parent().length) {
                    $animate.enter(charCountEl, errorsSpacer);
                  }
                  renderCharCount();
                } else {
                  $animate.leave(charCountEl);
                }
              });
              ngModelCtrl.$validators['md-maxlength'] = function(modelValue, viewValue) {
                if (!angular.isNumber(maxlength) || maxlength < 0) {
                  return true;
                }
                return (modelValue || element.val() || viewValue || '').length <= maxlength;
              };
            });
            function renderCharCount(value) {
              if (!charCountEl.parent) {
                return value;
              }
              charCountEl.text(String(element.val() || value || '').length + ' / ' + maxlength);
              return value;
            }
          }
        }
        mdMaxlengthDirective.$inject = ["$animate", "$mdUtil"];
        function placeholderDirective($compile) {
          return {
            restrict: 'A',
            require: '^^?mdInputContainer',
            priority: 200,
            link: {pre: preLink}
          };
          function preLink(scope, element, attr, inputContainer) {
            if (!inputContainer)
              return;
            var label = inputContainer.element.find('label');
            var noFloat = inputContainer.element.attr('md-no-float');
            if ((label && label.length) || noFloat === '' || scope.$eval(noFloat)) {
              inputContainer.setHasPlaceholder(true);
              return;
            }
            if (element[0].nodeName != 'MD-SELECT') {
              var newLabel = angular.element('<label ng-click="delegateClick()" tabindex="-1">' + attr.placeholder + '</label>');
              attr.$set('placeholder', null);
              inputContainer.element.addClass('md-icon-float').prepend(newLabel);
              $compile(newLabel)(scope);
            }
          }
        }
        placeholderDirective.$inject = ["$compile"];
        function mdSelectOnFocusDirective($timeout) {
          return {
            restrict: 'A',
            link: postLink
          };
          function postLink(scope, element, attr) {
            if (element[0].nodeName !== 'INPUT' && element[0].nodeName !== "TEXTAREA")
              return;
            var preventMouseUp = false;
            element.on('focus', onFocus).on('mouseup', onMouseUp);
            scope.$on('$destroy', function() {
              element.off('focus', onFocus).off('mouseup', onMouseUp);
            });
            function onFocus() {
              preventMouseUp = true;
              $timeout(function() {
                element[0].select();
                preventMouseUp = false;
              }, 1, false);
            }
            function onMouseUp(event) {
              if (preventMouseUp) {
                event.preventDefault();
              }
            }
          }
        }
        mdSelectOnFocusDirective.$inject = ["$timeout"];
        var visibilityDirectives = ['ngIf', 'ngShow', 'ngHide', 'ngSwitchWhen', 'ngSwitchDefault'];
        function ngMessagesDirective() {
          return {
            restrict: 'EA',
            link: postLink,
            require: '^^?mdInputContainer'
          };
          function postLink(scope, element, attrs, inputContainer) {
            if (!inputContainer)
              return;
            element.toggleClass('md-input-messages-animation', true);
            element.toggleClass('md-auto-hide', true);
            if (attrs.mdAutoHide == 'false' || hasVisibiltyDirective(attrs)) {
              element.toggleClass('md-auto-hide', false);
            }
          }
          function hasVisibiltyDirective(attrs) {
            return visibilityDirectives.some(function(attr) {
              return attrs[attr];
            });
          }
        }
        function ngMessageDirective($mdUtil) {
          return {
            restrict: 'EA',
            compile: compile,
            priority: 100
          };
          function compile(tElement) {
            if (!isInsideInputContainer(tElement)) {
              if (isInsideFragment()) {
                return function(scope, element) {
                  if (isInsideInputContainer(element)) {
                    initMessageElement(tElement);
                  }
                };
              }
            } else {
              initMessageElement(tElement);
            }
            function isInsideFragment() {
              var nextNode = tElement[0];
              while (nextNode = nextNode.parentNode) {
                if (nextNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
                  return true;
                }
              }
              return false;
            }
            function isInsideInputContainer(element) {
              return !!$mdUtil.getClosest(element, "md-input-container");
            }
            function initMessageElement(element) {
              element.toggleClass('md-input-message-animation', true);
            }
          }
        }
        ngMessageDirective.$inject = ["$mdUtil"];
        function mdInputInvalidMessagesAnimation($q, $animateCss) {
          return {addClass: function(element, className, done) {
              var messages = getMessagesElement(element);
              if (className == "md-input-invalid" && messages.hasClass('md-auto-hide')) {
                showInputMessages(element, $animateCss, $q).finally(done);
              } else {
                done();
              }
            }};
        }
        mdInputInvalidMessagesAnimation.$inject = ["$q", "$animateCss"];
        function ngMessagesAnimation($q, $animateCss) {
          return {
            enter: function(element, done) {
              showInputMessages(element, $animateCss, $q).finally(done);
            },
            leave: function(element, done) {
              hideInputMessages(element, $animateCss, $q).finally(done);
            },
            addClass: function(element, className, done) {
              if (className == "ng-hide") {
                hideInputMessages(element, $animateCss, $q).finally(done);
              } else {
                done();
              }
            },
            removeClass: function(element, className, done) {
              if (className == "ng-hide") {
                showInputMessages(element, $animateCss, $q).finally(done);
              } else {
                done();
              }
            }
          };
        }
        ngMessagesAnimation.$inject = ["$q", "$animateCss"];
        function ngMessageAnimation($animateCss) {
          return {
            enter: function(element, done) {
              var messages = getMessagesElement(element);
              if (messages.hasClass('md-auto-hide')) {
                done();
                return;
              }
              return showMessage(element, $animateCss);
            },
            leave: function(element, done) {
              return hideMessage(element, $animateCss);
            }
          };
        }
        ngMessageAnimation.$inject = ["$animateCss"];
        function showInputMessages(element, $animateCss, $q) {
          var animators = [],
              animator;
          var messages = getMessagesElement(element);
          angular.forEach(messages.children(), function(child) {
            animator = showMessage(angular.element(child), $animateCss);
            animators.push(animator.start());
          });
          return $q.all(animators);
        }
        function hideInputMessages(element, $animateCss, $q) {
          var animators = [],
              animator;
          var messages = getMessagesElement(element);
          angular.forEach(messages.children(), function(child) {
            animator = hideMessage(angular.element(child), $animateCss);
            animators.push(animator.start());
          });
          return $q.all(animators);
        }
        function showMessage(element, $animateCss) {
          var height = element[0].offsetHeight;
          return $animateCss(element, {
            event: 'enter',
            structural: true,
            from: {
              "opacity": 0,
              "margin-top": -height + "px"
            },
            to: {
              "opacity": 1,
              "margin-top": "0"
            },
            duration: 0.3
          });
        }
        function hideMessage(element, $animateCss) {
          var height = element[0].offsetHeight;
          var styles = window.getComputedStyle(element[0]);
          if (styles.opacity == 0) {
            return $animateCss(element, {});
          }
          return $animateCss(element, {
            event: 'leave',
            structural: true,
            from: {
              "opacity": 1,
              "margin-top": 0
            },
            to: {
              "opacity": 0,
              "margin-top": -height + "px"
            },
            duration: 0.3
          });
        }
        function getInputElement(element) {
          var inputContainer = element.controller('mdInputContainer');
          return inputContainer.element;
        }
        function getMessagesElement(element) {
          var input = getInputElement(element);
          return angular.element(input[0].querySelector('.md-input-messages-animation'));
        }
      })();
      (function() {
        "use strict";
        angular.module('material.components.list', ['material.core']).controller('MdListController', MdListController).directive('mdList', mdListDirective).directive('mdListItem', mdListItemDirective);
        function mdListDirective($mdTheming) {
          return {
            restrict: 'E',
            compile: function(tEl) {
              tEl[0].setAttribute('role', 'list');
              return $mdTheming;
            }
          };
        }
        mdListDirective.$inject = ["$mdTheming"];
        function mdListItemDirective($mdAria, $mdConstant, $mdUtil, $timeout) {
          var proxiedTypes = ['md-checkbox', 'md-switch', 'md-menu'];
          return {
            restrict: 'E',
            controller: 'MdListController',
            compile: function(tEl, tAttrs) {
              var secondaryItems = tEl[0].querySelectorAll('.md-secondary');
              var hasProxiedElement;
              var proxyElement;
              var itemContainer = tEl;
              tEl[0].setAttribute('role', 'listitem');
              if (tAttrs.ngClick || tAttrs.ngDblclick || tAttrs.ngHref || tAttrs.href || tAttrs.uiSref || tAttrs.ngAttrUiSref) {
                wrapIn('button');
              } else {
                for (var i = 0,
                    type; type = proxiedTypes[i]; ++i) {
                  if (proxyElement = tEl[0].querySelector(type)) {
                    hasProxiedElement = true;
                    break;
                  }
                }
                if (hasProxiedElement) {
                  wrapIn('div');
                } else if (!tEl[0].querySelector('md-button:not(.md-secondary):not(.md-exclude)')) {
                  tEl.addClass('_md-no-proxy');
                }
              }
              wrapSecondaryItems();
              setupToggleAria();
              if (hasProxiedElement && proxyElement.nodeName === "MD-MENU") {
                setupProxiedMenu();
              }
              function setupToggleAria() {
                var toggleTypes = ['md-switch', 'md-checkbox'];
                var toggle;
                for (var i = 0,
                    toggleType; toggleType = toggleTypes[i]; ++i) {
                  if (toggle = tEl.find(toggleType)[0]) {
                    if (!toggle.hasAttribute('aria-label')) {
                      var p = tEl.find('p')[0];
                      if (!p)
                        return;
                      toggle.setAttribute('aria-label', 'Toggle ' + p.textContent);
                    }
                  }
                }
              }
              function setupProxiedMenu() {
                var menuEl = angular.element(proxyElement);
                var isEndAligned = menuEl.parent().hasClass('_md-secondary-container') || proxyElement.parentNode.firstElementChild !== proxyElement;
                var xAxisPosition = 'left';
                if (isEndAligned) {
                  xAxisPosition = 'right';
                }
                if (!menuEl.attr('md-position-mode')) {
                  menuEl.attr('md-position-mode', xAxisPosition + ' target');
                }
                var menuOpenButton = menuEl.children().eq(0);
                if (!hasClickEvent(menuOpenButton[0])) {
                  menuOpenButton.attr('ng-click', '$mdOpenMenu($event)');
                }
                if (!menuOpenButton.attr('aria-label')) {
                  menuOpenButton.attr('aria-label', 'Open List Menu');
                }
              }
              function wrapIn(type) {
                if (type == 'div') {
                  itemContainer = angular.element('<div class="_md-no-style _md-list-item-inner">');
                  itemContainer.append(tEl.contents());
                  tEl.addClass('_md-proxy-focus');
                } else {
                  itemContainer = angular.element('<div class="md-button _md-no-style">' + '   <div class="_md-list-item-inner"></div>' + '</div>');
                  var buttonWrap = angular.element('<md-button class="_md-no-style"></md-button>');
                  buttonWrap[0].setAttribute('aria-label', tEl[0].textContent);
                  copyAttributes(tEl[0], buttonWrap[0]);
                  if (tEl.hasClass('md-no-focus')) {
                    buttonWrap.addClass('md-no-focus');
                  }
                  itemContainer.prepend(buttonWrap);
                  itemContainer.children().eq(1).append(tEl.contents());
                  tEl.addClass('_md-button-wrap');
                }
                tEl[0].setAttribute('tabindex', '-1');
                tEl.append(itemContainer);
              }
              function wrapSecondaryItems() {
                var secondaryItemsWrapper = angular.element('<div class="_md-secondary-container">');
                angular.forEach(secondaryItems, function(secondaryItem) {
                  wrapSecondaryItem(secondaryItem, secondaryItemsWrapper);
                });
                itemContainer.append(secondaryItemsWrapper);
              }
              function wrapSecondaryItem(secondaryItem, container) {
                if (secondaryItem && !isButton(secondaryItem) && secondaryItem.hasAttribute('ng-click')) {
                  $mdAria.expect(secondaryItem, 'aria-label');
                  var buttonWrapper = angular.element('<md-button class="md-secondary md-icon-button">');
                  copyAttributes(secondaryItem, buttonWrapper[0], ['ng-if', 'ng-hide', 'ng-show']);
                  secondaryItem.setAttribute('tabindex', '-1');
                  buttonWrapper.append(secondaryItem);
                  secondaryItem = buttonWrapper[0];
                }
                if (secondaryItem && (!hasClickEvent(secondaryItem) || (!tAttrs.ngClick && isProxiedElement(secondaryItem)))) {
                  angular.element(secondaryItem).removeClass('md-secondary');
                }
                tEl.addClass('md-with-secondary');
                container.append(secondaryItem);
              }
              function copyAttributes(source, destination, extraAttrs) {
                var copiedAttrs = $mdUtil.prefixer(['ng-if', 'ng-click', 'ng-dblclick', 'aria-label', 'ng-disabled', 'ui-sref', 'href', 'ng-href', 'target', 'ng-attr-ui-sref', 'ui-sref-opts']);
                if (extraAttrs) {
                  copiedAttrs = copiedAttrs.concat($mdUtil.prefixer(extraAttrs));
                }
                angular.forEach(copiedAttrs, function(attr) {
                  if (source.hasAttribute(attr)) {
                    destination.setAttribute(attr, source.getAttribute(attr));
                    source.removeAttribute(attr);
                  }
                });
              }
              function isProxiedElement(el) {
                return proxiedTypes.indexOf(el.nodeName.toLowerCase()) != -1;
              }
              function isButton(el) {
                var nodeName = el.nodeName.toUpperCase();
                return nodeName == "MD-BUTTON" || nodeName == "BUTTON";
              }
              function hasClickEvent(element) {
                var attr = element.attributes;
                for (var i = 0; i < attr.length; i++) {
                  if (tAttrs.$normalize(attr[i].name) === 'ngClick')
                    return true;
                }
                return false;
              }
              return postLink;
              function postLink($scope, $element, $attr, ctrl) {
                $element.addClass('_md');
                var proxies = [],
                    firstElement = $element[0].firstElementChild,
                    isButtonWrap = $element.hasClass('_md-button-wrap'),
                    clickChild = isButtonWrap ? firstElement.firstElementChild : firstElement,
                    hasClick = clickChild && hasClickEvent(clickChild);
                computeProxies();
                computeClickable();
                if ($element.hasClass('_md-proxy-focus') && proxies.length) {
                  angular.forEach(proxies, function(proxy) {
                    proxy = angular.element(proxy);
                    $scope.mouseActive = false;
                    proxy.on('mousedown', function() {
                      $scope.mouseActive = true;
                      $timeout(function() {
                        $scope.mouseActive = false;
                      }, 100);
                    }).on('focus', function() {
                      if ($scope.mouseActive === false) {
                        $element.addClass('md-focused');
                      }
                      proxy.on('blur', function proxyOnBlur() {
                        $element.removeClass('md-focused');
                        proxy.off('blur', proxyOnBlur);
                      });
                    });
                  });
                }
                function computeProxies() {
                  if (firstElement && firstElement.children && !hasClick) {
                    angular.forEach(proxiedTypes, function(type) {
                      angular.forEach(firstElement.querySelectorAll(type + ':not(.md-secondary)'), function(child) {
                        proxies.push(child);
                      });
                    });
                  }
                }
                function computeClickable() {
                  if (proxies.length == 1 || hasClick) {
                    $element.addClass('md-clickable');
                    if (!hasClick) {
                      ctrl.attachRipple($scope, angular.element($element[0].querySelector('._md-no-style')));
                    }
                  }
                }
                function isEventFromControl(event) {
                  var forbiddenControls = ['md-slider'];
                  if (!event.path) {
                    return forbiddenControls.indexOf(event.target.tagName.toLowerCase()) !== -1;
                  }
                  var maxPath = event.path.indexOf($element.children()[0]);
                  for (var i = 0; i < maxPath; i++) {
                    if (forbiddenControls.indexOf(event.path[i].tagName.toLowerCase()) !== -1) {
                      return true;
                    }
                  }
                }
                var clickChildKeypressListener = function(e) {
                  if (e.target.nodeName != 'INPUT' && e.target.nodeName != 'TEXTAREA' && !e.target.isContentEditable) {
                    var keyCode = e.which || e.keyCode;
                    if (keyCode == $mdConstant.KEY_CODE.SPACE) {
                      if (clickChild) {
                        clickChild.click();
                        e.preventDefault();
                        e.stopPropagation();
                      }
                    }
                  }
                };
                if (!hasClick && !proxies.length) {
                  clickChild && clickChild.addEventListener('keypress', clickChildKeypressListener);
                }
                $element.off('click');
                $element.off('keypress');
                if (proxies.length == 1 && clickChild) {
                  $element.children().eq(0).on('click', function(e) {
                    if (isEventFromControl(e))
                      return;
                    var parentButton = $mdUtil.getClosest(e.target, 'BUTTON');
                    if (!parentButton && clickChild.contains(e.target)) {
                      angular.forEach(proxies, function(proxy) {
                        if (e.target !== proxy && !proxy.contains(e.target)) {
                          if (proxy.nodeName === 'MD-MENU') {
                            proxy = proxy.children[0];
                          }
                          angular.element(proxy).triggerHandler('click');
                        }
                      });
                    }
                  });
                }
                $scope.$on('$destroy', function() {
                  clickChild && clickChild.removeEventListener('keypress', clickChildKeypressListener);
                });
              }
            }
          };
        }
        mdListItemDirective.$inject = ["$mdAria", "$mdConstant", "$mdUtil", "$timeout"];
        function MdListController($scope, $element, $mdListInkRipple) {
          var ctrl = this;
          ctrl.attachRipple = attachRipple;
          function attachRipple(scope, element) {
            var options = {};
            $mdListInkRipple.attach(scope, element, options);
          }
        }
        MdListController.$inject = ["$scope", "$element", "$mdListInkRipple"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.menu', ['material.core', 'material.components.backdrop']);
      })();
      (function() {
        "use strict";
        angular.module('material.components.menuBar', ['material.core', 'material.components.menu']);
      })();
      (function() {
        "use strict";
        angular.module('material.components.navBar', ['material.core']).controller('MdNavBarController', MdNavBarController).directive('mdNavBar', MdNavBar).controller('MdNavItemController', MdNavItemController).directive('mdNavItem', MdNavItem);
        function MdNavBar($mdAria) {
          return {
            restrict: 'E',
            transclude: true,
            controller: MdNavBarController,
            controllerAs: 'ctrl',
            bindToController: true,
            scope: {
              'mdSelectedNavItem': '=?',
              'navBarAriaLabel': '@?'
            },
            template: '<div class="md-nav-bar">' + '<nav role="navigation">' + '<ul class="_md-nav-bar-list" layout="row" ng-transclude role="listbox"' + 'tabindex="0"' + 'ng-focus="ctrl.onFocus()"' + 'ng-blur="ctrl.onBlur()"' + 'ng-keydown="ctrl.onKeydown($event)"' + 'aria-label="{{ctrl.navBarAriaLabel}}">' + '</ul>' + '</nav>' + '<md-nav-ink-bar></md-nav-ink-bar>' + '</div>',
            link: function(scope, element, attrs, ctrl) {
              if (!ctrl.navBarAriaLabel) {
                $mdAria.expectAsync(element, 'aria-label', angular.noop);
              }
            }
          };
        }
        MdNavBar.$inject = ["$mdAria"];
        function MdNavBarController($element, $scope, $timeout, $mdConstant) {
          this._$timeout = $timeout;
          this._$scope = $scope;
          this._$mdConstant = $mdConstant;
          this.mdSelectedNavItem;
          this.navBarAriaLabel;
          this._navBarEl = $element[0];
          this._inkbar;
          var self = this;
          var deregisterTabWatch = this._$scope.$watch(function() {
            return self._navBarEl.querySelectorAll('._md-nav-button').length;
          }, function(newLength) {
            if (newLength > 0) {
              self._initTabs();
              deregisterTabWatch();
            }
          });
        }
        MdNavBarController.$inject = ["$element", "$scope", "$timeout", "$mdConstant"];
        MdNavBarController.prototype._initTabs = function() {
          this._inkbar = angular.element(this._navBarEl.getElementsByTagName('md-nav-ink-bar')[0]);
          var self = this;
          this._$timeout(function() {
            self._updateTabs(self.mdSelectedNavItem, undefined);
          });
          this._$scope.$watch('ctrl.mdSelectedNavItem', function(newValue, oldValue) {
            self._$timeout(function() {
              self._updateTabs(newValue, oldValue);
            });
          });
        };
        MdNavBarController.prototype._updateTabs = function(newValue, oldValue) {
          var self = this;
          var tabs = this._getTabs();
          var oldIndex = -1;
          var newIndex = -1;
          var newTab = this._getTabByName(newValue);
          var oldTab = this._getTabByName(oldValue);
          if (oldTab) {
            oldTab.setSelected(false);
            oldIndex = tabs.indexOf(oldTab);
          }
          if (newTab) {
            newTab.setSelected(true);
            newIndex = tabs.indexOf(newTab);
          }
          this._$timeout(function() {
            self._updateInkBarStyles(newTab, newIndex, oldIndex);
          });
        };
        MdNavBarController.prototype._updateInkBarStyles = function(tab, newIndex, oldIndex) {
          this._inkbar.toggleClass('_md-left', newIndex < oldIndex).toggleClass('_md-right', newIndex > oldIndex);
          this._inkbar.css({display: newIndex < 0 ? 'none' : ''});
          if (tab) {
            var tabEl = tab.getButtonEl();
            var left = tabEl.offsetLeft;
            this._inkbar.css({
              left: left + 'px',
              width: tabEl.offsetWidth + 'px'
            });
          }
        };
        MdNavBarController.prototype._getTabs = function() {
          var linkArray = Array.prototype.slice.call(this._navBarEl.querySelectorAll('.md-nav-item'));
          return linkArray.map(function(el) {
            return angular.element(el).controller('mdNavItem');
          });
        };
        MdNavBarController.prototype._getTabByName = function(name) {
          return this._findTab(function(tab) {
            return tab.getName() == name;
          });
        };
        MdNavBarController.prototype._getSelectedTab = function() {
          return this._findTab(function(tab) {
            return tab.isSelected();
          });
        };
        MdNavBarController.prototype.getFocusedTab = function() {
          return this._findTab(function(tab) {
            return tab.hasFocus();
          });
        };
        MdNavBarController.prototype._findTab = function(fn) {
          var tabs = this._getTabs();
          for (var i = 0; i < tabs.length; i++) {
            if (fn(tabs[i])) {
              return tabs[i];
            }
          }
          return null;
        };
        MdNavBarController.prototype.onFocus = function() {
          var tab = this._getSelectedTab();
          if (tab) {
            tab.setFocused(true);
          }
        };
        MdNavBarController.prototype.onBlur = function() {
          var tab = this.getFocusedTab();
          if (tab) {
            tab.setFocused(false);
          }
        };
        MdNavBarController.prototype._moveFocus = function(oldTab, newTab) {
          oldTab.setFocused(false);
          newTab.setFocused(true);
        };
        MdNavBarController.prototype.onKeydown = function(e) {
          var keyCodes = this._$mdConstant.KEY_CODE;
          var tabs = this._getTabs();
          var focusedTab = this.getFocusedTab();
          if (!focusedTab)
            return;
          var focusedTabIndex = tabs.indexOf(focusedTab);
          switch (e.keyCode) {
            case keyCodes.UP_ARROW:
            case keyCodes.LEFT_ARROW:
              if (focusedTabIndex > 0) {
                this._moveFocus(focusedTab, tabs[focusedTabIndex - 1]);
              }
              break;
            case keyCodes.DOWN_ARROW:
            case keyCodes.RIGHT_ARROW:
              if (focusedTabIndex < tabs.length - 1) {
                this._moveFocus(focusedTab, tabs[focusedTabIndex + 1]);
              }
              break;
            case keyCodes.SPACE:
            case keyCodes.ENTER:
              this._$timeout(function() {
                focusedTab.getButtonEl().click();
              });
              break;
          }
        };
        function MdNavItem($$rAF) {
          return {
            restrict: 'E',
            require: ['mdNavItem', '^mdNavBar'],
            controller: MdNavItemController,
            bindToController: true,
            controllerAs: 'ctrl',
            replace: true,
            transclude: true,
            template: '<li class="md-nav-item" role="option" aria-selected="{{ctrl.isSelected()}}">' + '<md-button ng-if="ctrl.mdNavSref" class="_md-nav-button md-accent"' + 'ng-class="ctrl.getNgClassMap()"' + 'tabindex="-1"' + 'ui-sref="{{ctrl.mdNavSref}}">' + '<span ng-transclude class="_md-nav-button-text"></span>' + '</md-button>' + '<md-button ng-if="ctrl.mdNavHref" class="_md-nav-button md-accent"' + 'ng-class="ctrl.getNgClassMap()"' + 'tabindex="-1"' + 'ng-href="{{ctrl.mdNavHref}}">' + '<span ng-transclude class="_md-nav-button-text"></span>' + '</md-button>' + '<md-button ng-if="ctrl.mdNavClick" class="_md-nav-button md-accent"' + 'ng-class="ctrl.getNgClassMap()"' + 'tabindex="-1"' + 'ng-click="ctrl.mdNavClick()">' + '<span ng-transclude class="_md-nav-button-text"></span>' + '</md-button>' + '</li>',
            scope: {
              'mdNavClick': '&?',
              'mdNavHref': '@?',
              'mdNavSref': '@?',
              'name': '@'
            },
            link: function(scope, element, attrs, controllers) {
              var mdNavItem = controllers[0];
              var mdNavBar = controllers[1];
              $$rAF(function() {
                if (!mdNavItem.name) {
                  mdNavItem.name = angular.element(element[0].querySelector('._md-nav-button-text')).text().trim();
                }
                var navButton = angular.element(element[0].querySelector('._md-nav-button'));
                navButton.on('click', function() {
                  mdNavBar.mdSelectedNavItem = mdNavItem.name;
                  scope.$apply();
                });
              });
            }
          };
        }
        MdNavItem.$inject = ["$$rAF"];
        function MdNavItemController($element) {
          this._$element = $element;
          this.mdNavClick;
          this.mdNavHref;
          this.name;
          this._selected = false;
          this._focused = false;
          var hasNavClick = !!($element.attr('md-nav-click'));
          var hasNavHref = !!($element.attr('md-nav-href'));
          var hasNavSref = !!($element.attr('md-nav-sref'));
          if ((hasNavClick ? 1 : 0) + (hasNavHref ? 1 : 0) + (hasNavSref ? 1 : 0) > 1) {
            throw Error('Must specify exactly one of md-nav-click, md-nav-href, ' + 'md-nav-sref for nav-item directive');
          }
        }
        MdNavItemController.$inject = ["$element"];
        MdNavItemController.prototype.getNgClassMap = function() {
          return {
            'md-active': this._selected,
            'md-primary': this._selected,
            'md-unselected': !this._selected,
            'md-focused': this._focused
          };
        };
        MdNavItemController.prototype.getName = function() {
          return this.name;
        };
        MdNavItemController.prototype.getButtonEl = function() {
          return this._$element[0].querySelector('._md-nav-button');
        };
        MdNavItemController.prototype.setSelected = function(isSelected) {
          this._selected = isSelected;
        };
        MdNavItemController.prototype.isSelected = function() {
          return this._selected;
        };
        MdNavItemController.prototype.setFocused = function(isFocused) {
          this._focused = isFocused;
        };
        MdNavItemController.prototype.hasFocus = function() {
          return this._focused;
        };
      })();
      (function() {
        "use strict";
        angular.module('material.components.panel', ['material.core', 'material.components.backdrop']).service('$mdPanel', MdPanelService);
        var defaultZIndex = 80;
        var MD_PANEL_HIDDEN = '_md-panel-hidden';
        var FOCUS_TRAP_TEMPLATE = angular.element('<div class="_md-panel-focus-trap" tabindex="0"></div>');
        function MdPanelService($rootElement, $rootScope, $injector, $window) {
          this._defaultConfigOptions = {
            bindToController: true,
            clickOutsideToClose: false,
            disableParentScroll: false,
            escapeToClose: false,
            focusOnOpen: true,
            fullscreen: false,
            hasBackdrop: false,
            transformTemplate: angular.bind(this, this._wrapTemplate),
            trapFocus: false,
            zIndex: defaultZIndex
          };
          this._config = {};
          this._$rootElement = $rootElement;
          this._$rootScope = $rootScope;
          this._$injector = $injector;
          this._$window = $window;
          this.animation = MdPanelAnimation.animation;
          this.xPosition = MdPanelPosition.xPosition;
          this.yPosition = MdPanelPosition.yPosition;
        }
        MdPanelService.$inject = ["$rootElement", "$rootScope", "$injector", "$window"];
        MdPanelService.prototype.create = function(opt_config) {
          var configSettings = opt_config || {};
          this._config = {
            scope: this._$rootScope.$new(true),
            attachTo: this._$rootElement
          };
          angular.extend(this._config, this._defaultConfigOptions, configSettings);
          var instanceId = 'panel_' + this._$injector.get('$mdUtil').nextUid();
          var instanceConfig = angular.extend({id: instanceId}, this._config);
          return new MdPanelRef(instanceConfig, this._$injector);
        };
        MdPanelService.prototype.open = function(opt_config) {
          var panelRef = this.create(opt_config);
          return panelRef.open().then(function() {
            return panelRef;
          });
        };
        MdPanelService.prototype.newPanelPosition = function() {
          return new MdPanelPosition(this._$window);
        };
        MdPanelService.prototype.newPanelAnimation = function() {
          return new MdPanelAnimation(this._$injector);
        };
        MdPanelService.prototype._wrapTemplate = function(origTemplate) {
          var template = origTemplate || '';
          return '' + '<div class="md-panel-outer-wrapper">' + '  <div class="md-panel" style="left: -9999px;">' + template + '</div>' + '</div>';
        };
        function MdPanelRef(config, $injector) {
          this._$q = $injector.get('$q');
          this._$mdCompiler = $injector.get('$mdCompiler');
          this._$mdConstant = $injector.get('$mdConstant');
          this._$mdUtil = $injector.get('$mdUtil');
          this._$rootScope = $injector.get('$rootScope');
          this._$animate = $injector.get('$animate');
          this._$mdPanel = $injector.get('$mdPanel');
          this._$log = $injector.get('$log');
          this._$window = $injector.get('$window');
          this._$$rAF = $injector.get('$$rAF');
          this.id = config.id;
          this.isAttached = false;
          this._config = config;
          this._panelContainer;
          this._panelEl;
          this._removeListeners = [];
          this._topFocusTrap;
          this._bottomFocusTrap;
          this._backdropRef;
          this._restoreScroll = null;
        }
        MdPanelRef.prototype.open = function() {
          var self = this;
          return this._$q(function(resolve, reject) {
            var done = self._done(resolve, self);
            var show = self._simpleBind(self.show, self);
            self.attach().then(show).then(done).catch(reject);
          });
        };
        MdPanelRef.prototype.close = function() {
          var self = this;
          return this._$q(function(resolve, reject) {
            var done = self._done(resolve, self);
            var detach = self._simpleBind(self.detach, self);
            self.hide().then(detach).then(done).catch(reject);
          });
        };
        MdPanelRef.prototype.attach = function() {
          if (this.isAttached && this._panelEl) {
            return this._$q.when(this);
          }
          var self = this;
          return this._$q(function(resolve, reject) {
            var done = self._done(resolve, self);
            var onDomAdded = self._config['onDomAdded'] || angular.noop;
            var addListeners = function(response) {
              self.isAttached = true;
              self._addEventListeners();
              return response;
            };
            self._$q.all([self._createBackdrop(), self._createPanel().then(addListeners).catch(reject)]).then(onDomAdded).then(done).catch(reject);
          });
        };
        MdPanelRef.prototype.detach = function() {
          if (!this.isAttached) {
            return this._$q.when(this);
          }
          var self = this;
          var onDomRemoved = self._config['onDomRemoved'] || angular.noop;
          var detachFn = function() {
            self._removeEventListeners();
            if (self._topFocusTrap && self._topFocusTrap.parentNode) {
              self._topFocusTrap.parentNode.removeChild(self._topFocusTrap);
            }
            if (self._bottomFocusTrap && self._bottomFocusTrap.parentNode) {
              self._bottomFocusTrap.parentNode.removeChild(self._bottomFocusTrap);
            }
            self._panelContainer.remove();
            self.isAttached = false;
            return self._$q.when(self);
          };
          if (this._restoreScroll) {
            this._restoreScroll();
            this._restoreScroll = null;
          }
          return this._$q(function(resolve, reject) {
            var done = self._done(resolve, self);
            self._$q.all([detachFn(), self._backdropRef ? self._backdropRef.detach() : true]).then(onDomRemoved).then(done).catch(reject);
          });
        };
        MdPanelRef.prototype.destroy = function() {
          this._config.locals = null;
        };
        MdPanelRef.prototype.show = function() {
          if (!this._panelContainer) {
            return this._$q(function(resolve, reject) {
              reject('Panel does not exist yet. Call open() or attach().');
            });
          }
          if (!this._panelContainer.hasClass(MD_PANEL_HIDDEN)) {
            return this._$q.when(this);
          }
          var self = this;
          var animatePromise = function() {
            self.removeClass(MD_PANEL_HIDDEN);
            return self._animateOpen();
          };
          return this._$q(function(resolve, reject) {
            var done = self._done(resolve, self);
            var onOpenComplete = self._config['onOpenComplete'] || angular.noop;
            self._$q.all([self._backdropRef ? self._backdropRef.show() : self, animatePromise().then(function() {
              self._focusOnOpen();
            }, reject)]).then(onOpenComplete).then(done).catch(reject);
          });
        };
        MdPanelRef.prototype.hide = function() {
          if (!this._panelContainer) {
            return this._$q(function(resolve, reject) {
              reject('Panel does not exist yet. Call open() or attach().');
            });
          }
          if (this._panelContainer.hasClass(MD_PANEL_HIDDEN)) {
            return this._$q.when(this);
          }
          var self = this;
          return this._$q(function(resolve, reject) {
            var done = self._done(resolve, self);
            var onRemoving = self._config['onRemoving'] || angular.noop;
            var focusOnOrigin = function() {
              var origin = self._config['origin'];
              if (origin) {
                getElement(origin).focus();
              }
            };
            var hidePanel = function() {
              self.addClass(MD_PANEL_HIDDEN);
            };
            self._$q.all([self._backdropRef ? self._backdropRef.hide() : self, self._animateClose().then(onRemoving).then(hidePanel).then(focusOnOrigin).catch(reject)]).then(done, reject);
          });
        };
        MdPanelRef.prototype.addClass = function(newClass) {
          if (!this._panelContainer) {
            throw new Error('Panel does not exist yet. Call open() or attach().');
          }
          if (!this._panelContainer.hasClass(newClass)) {
            this._panelContainer.addClass(newClass);
          }
        };
        MdPanelRef.prototype.removeClass = function(oldClass) {
          if (!this._panelContainer) {
            throw new Error('Panel does not exist yet. Call open() or attach().');
          }
          if (this._panelContainer.hasClass(oldClass)) {
            this._panelContainer.removeClass(oldClass);
          }
        };
        MdPanelRef.prototype.toggleClass = function(toggleClass) {
          if (!this._panelContainer) {
            throw new Error('Panel does not exist yet. Call open() or attach().');
          }
          this._panelContainer.toggleClass(toggleClass);
        };
        MdPanelRef.prototype._createPanel = function() {
          var self = this;
          return this._$q(function(resolve, reject) {
            if (!self._config.locals) {
              self._config.locals = {};
            }
            self._config.locals.mdPanelRef = self;
            self._$mdCompiler.compile(self._config).then(function(compileData) {
              self._panelContainer = compileData.link(self._config['scope']);
              getElement(self._config['attachTo']).append(self._panelContainer);
              if (self._config['disableParentScroll']) {
                self._restoreScroll = self._$mdUtil.disableScrollAround(null, self._panelContainer);
              }
              self._panelEl = angular.element(self._panelContainer[0].querySelector('.md-panel'));
              if (self._config['panelClass']) {
                self._panelEl.addClass(self._config['panelClass']);
              }
              if (self._$animate.pin) {
                self._$animate.pin(self._panelContainer, getElement(self._config['attachTo']));
              }
              self._configureTrapFocus();
              self._addStyles().then(function() {
                resolve(self);
              }, reject);
            }, reject);
          });
        };
        MdPanelRef.prototype._addStyles = function() {
          var self = this;
          return this._$q(function(resolve) {
            self._panelContainer.css('z-index', self._config['zIndex']);
            self._panelEl.css('z-index', self._config['zIndex'] + 1);
            var hideAndResolve = function() {
              self._panelEl.css('left', '');
              self._panelContainer.addClass(MD_PANEL_HIDDEN);
              resolve(self);
            };
            if (self._config['fullscreen']) {
              self._panelEl.addClass('_md-panel-fullscreen');
              hideAndResolve();
              return;
            }
            var positionConfig = self._config['position'];
            if (!positionConfig) {
              hideAndResolve();
              return;
            }
            self._$rootScope['$$postDigest'](function() {
              self._updatePosition(true);
              resolve(self);
            });
          });
        };
        MdPanelRef.prototype._updatePosition = function(opt_init) {
          var positionConfig = this._config['position'];
          if (positionConfig) {
            positionConfig._setPanelPosition(this._panelEl);
            if (opt_init) {
              this._panelContainer.addClass(MD_PANEL_HIDDEN);
            }
            this._panelEl.css('top', positionConfig.getTop());
            this._panelEl.css('bottom', positionConfig.getBottom());
            this._panelEl.css('left', positionConfig.getLeft());
            this._panelEl.css('right', positionConfig.getRight());
            var prefixedTransform = this._$mdConstant.CSS.TRANSFORM;
            this._panelEl.css(prefixedTransform, positionConfig.getTransform());
          }
        };
        MdPanelRef.prototype._focusOnOpen = function() {
          if (this._config['focusOnOpen']) {
            var self = this;
            this._$rootScope['$$postDigest'](function() {
              var target = self._$mdUtil.findFocusTarget(self._panelEl) || self._panelEl;
              target.focus();
            });
          }
        };
        MdPanelRef.prototype._createBackdrop = function() {
          if (this._config.hasBackdrop) {
            if (!this._backdropRef) {
              var backdropAnimation = this._$mdPanel.newPanelAnimation().openFrom(this._config.attachTo).withAnimation({
                open: '_md-opaque-enter',
                close: '_md-opaque-leave'
              });
              var backdropConfig = {
                animation: backdropAnimation,
                attachTo: this._config.attachTo,
                focusOnOpen: false,
                panelClass: '_md-panel-backdrop',
                zIndex: this._config.zIndex - 1
              };
              this._backdropRef = this._$mdPanel.create(backdropConfig);
            }
            if (!this._backdropRef.isAttached) {
              return this._backdropRef.attach();
            }
          }
        };
        MdPanelRef.prototype._addEventListeners = function() {
          this._configureEscapeToClose();
          this._configureClickOutsideToClose();
          this._configureScrollListener();
        };
        MdPanelRef.prototype._removeEventListeners = function() {
          this._removeListeners && this._removeListeners.forEach(function(removeFn) {
            removeFn();
          });
          this._removeListeners = null;
        };
        MdPanelRef.prototype._configureEscapeToClose = function() {
          if (this._config['escapeToClose']) {
            var parentTarget = getElement(this._config['attachTo']);
            var self = this;
            var keyHandlerFn = function(ev) {
              if (ev.keyCode === self._$mdConstant.KEY_CODE.ESCAPE) {
                ev.stopPropagation();
                ev.preventDefault();
                self.close();
              }
            };
            this._panelContainer.on('keydown', keyHandlerFn);
            parentTarget.on('keydown', keyHandlerFn);
            this._removeListeners.push(function() {
              self._panelContainer.off('keydown', keyHandlerFn);
              parentTarget.off('keydown', keyHandlerFn);
            });
          }
        };
        MdPanelRef.prototype._configureClickOutsideToClose = function() {
          if (this._config['clickOutsideToClose']) {
            var target = this._panelContainer;
            var sourceElem;
            var mousedownHandler = function(ev) {
              sourceElem = ev.target;
            };
            var self = this;
            var mouseupHandler = function(ev) {
              if (sourceElem === target[0] && ev.target === target[0]) {
                ev.stopPropagation();
                ev.preventDefault();
                self.close();
              }
            };
            target.on('mousedown', mousedownHandler);
            target.on('mouseup', mouseupHandler);
            this._removeListeners.push(function() {
              target.off('mousedown', mousedownHandler);
              target.off('mouseup', mouseupHandler);
            });
          }
        };
        MdPanelRef.prototype._configureScrollListener = function() {
          var updatePosition = angular.bind(this, this._updatePosition);
          var debouncedUpdatePosition = this._$$rAF.throttle(updatePosition);
          var self = this;
          var onScroll = function() {
            if (!self._config['disableParentScroll']) {
              debouncedUpdatePosition();
            }
          };
          this._$window.addEventListener('scroll', onScroll, true);
          this._removeListeners.push(function() {
            self._$window.removeEventListener('scroll', onScroll, true);
          });
        };
        MdPanelRef.prototype._configureTrapFocus = function() {
          this._panelEl.attr('tabIndex', '-1');
          if (this._config['trapFocus']) {
            var element = this._panelEl;
            this._topFocusTrap = FOCUS_TRAP_TEMPLATE.clone()[0];
            this._bottomFocusTrap = FOCUS_TRAP_TEMPLATE.clone()[0];
            var focusHandler = function() {
              element.focus();
            };
            this._topFocusTrap.addEventListener('focus', focusHandler);
            this._bottomFocusTrap.addEventListener('focus', focusHandler);
            this._removeListeners.push(this._simpleBind(function() {
              this._topFocusTrap.removeEventListener('focus', focusHandler);
              this._bottomFocusTrap.removeEventListener('focus', focusHandler);
            }, this));
            element[0].parentNode.insertBefore(this._topFocusTrap, element[0]);
            element.after(this._bottomFocusTrap);
          }
        };
        MdPanelRef.prototype._animateOpen = function() {
          this.addClass('md-panel-is-showing');
          var animationConfig = this._config['animation'];
          if (!animationConfig) {
            this.addClass('_md-panel-shown');
            return this._$q.when(this);
          }
          var self = this;
          return this._$q(function(resolve) {
            var done = self._done(resolve, self);
            var warnAndOpen = function() {
              self._$log.warn('MdPanel Animations failed. Showing panel without animating.');
              done();
            };
            animationConfig.animateOpen(self._panelEl).then(done, warnAndOpen);
          });
        };
        MdPanelRef.prototype._animateClose = function() {
          var animationConfig = this._config['animation'];
          if (!animationConfig) {
            this.removeClass('md-panel-is-showing');
            this.removeClass('_md-panel-shown');
            return this._$q.when(this);
          }
          var self = this;
          return this._$q(function(resolve) {
            var done = function() {
              self.removeClass('md-panel-is-showing');
              resolve(self);
            };
            var warnAndClose = function() {
              self._$log.warn('MdPanel Animations failed. Hiding panel without animating.');
              done();
            };
            animationConfig.animateClose(self._panelEl).then(done, warnAndClose);
          });
        };
        MdPanelRef.prototype._simpleBind = function(callback, self) {
          return function(value) {
            return callback.apply(self, value);
          };
        };
        MdPanelRef.prototype._done = function(callback, self) {
          return function() {
            callback(self);
          };
        };
        function MdPanelPosition($window) {
          this._$window = $window;
          this._absolute = false;
          this._relativeToEl;
          this._top = '';
          this._bottom = '';
          this._left = '';
          this._right = '';
          this._translateX = [];
          this._translateY = [];
          this._positions = [];
          this._actualPosition;
        }
        MdPanelPosition.xPosition = {
          CENTER: 'center',
          ALIGN_START: 'align-start',
          ALIGN_END: 'align-end',
          OFFSET_START: 'offset-start',
          OFFSET_END: 'offset-end'
        };
        MdPanelPosition.yPosition = {
          CENTER: 'center',
          ALIGN_TOPS: 'align-tops',
          ALIGN_BOTTOMS: 'align-bottoms',
          ABOVE: 'above',
          BELOW: 'below'
        };
        MdPanelPosition.prototype.absolute = function() {
          this._absolute = true;
          return this;
        };
        MdPanelPosition.prototype.top = function(opt_top) {
          this._bottom = '';
          this._top = opt_top || '0';
          return this;
        };
        MdPanelPosition.prototype.bottom = function(opt_bottom) {
          this._top = '';
          this._bottom = opt_bottom || '0';
          return this;
        };
        MdPanelPosition.prototype.left = function(opt_left) {
          this._right = '';
          this._left = opt_left || '0';
          return this;
        };
        MdPanelPosition.prototype.right = function(opt_right) {
          this._left = '';
          this._right = opt_right || '0';
          return this;
        };
        MdPanelPosition.prototype.centerHorizontally = function() {
          this._left = '50%';
          this._right = '';
          this._translateX = ['-50%'];
          return this;
        };
        MdPanelPosition.prototype.centerVertically = function() {
          this._top = '50%';
          this._bottom = '';
          this._translateY = ['-50%'];
          return this;
        };
        MdPanelPosition.prototype.center = function() {
          return this.centerHorizontally().centerVertically();
        };
        MdPanelPosition.prototype.relativeTo = function(element) {
          this._absolute = false;
          this._relativeToEl = getElement(element);
          return this;
        };
        MdPanelPosition.prototype.addPanelPosition = function(xPosition, yPosition) {
          if (!this._relativeToEl) {
            throw new Error('addPanelPosition can only be used with relative ' + 'positioning. Set relativeTo first.');
          }
          this._validateXPosition(xPosition);
          this._validateYPosition(yPosition);
          this._positions.push({
            x: xPosition,
            y: yPosition
          });
          return this;
        };
        MdPanelPosition.prototype._validateYPosition = function(yPosition) {
          if (yPosition == null) {
            return;
          }
          var positionKeys = Object.keys(MdPanelPosition.yPosition);
          var positionValues = [];
          for (var key,
              i = 0; key = positionKeys[i]; i++) {
            var position = MdPanelPosition.yPosition[key];
            positionValues.push(position);
            if (position === yPosition) {
              return;
            }
          }
          throw new Error('Panel y position only accepts the following values:\n' + positionValues.join(' | '));
        };
        MdPanelPosition.prototype._validateXPosition = function(xPosition) {
          if (xPosition == null) {
            return;
          }
          var positionKeys = Object.keys(MdPanelPosition.xPosition);
          var positionValues = [];
          for (var key,
              i = 0; key = positionKeys[i]; i++) {
            var position = MdPanelPosition.xPosition[key];
            positionValues.push(position);
            if (position === xPosition) {
              return;
            }
          }
          throw new Error('Panel x Position only accepts the following values:\n' + positionValues.join(' | '));
        };
        MdPanelPosition.prototype.withOffsetX = function(offsetX) {
          this._translateX.push(offsetX);
          return this;
        };
        MdPanelPosition.prototype.withOffsetY = function(offsetY) {
          this._translateY.push(offsetY);
          return this;
        };
        MdPanelPosition.prototype.getTop = function() {
          return this._top;
        };
        MdPanelPosition.prototype.getBottom = function() {
          return this._bottom;
        };
        MdPanelPosition.prototype.getLeft = function() {
          return this._left;
        };
        MdPanelPosition.prototype.getRight = function() {
          return this._right;
        };
        MdPanelPosition.prototype.getTransform = function() {
          var translateX = this._reduceTranslateValues('translateX', this._translateX);
          var translateY = this._reduceTranslateValues('translateY', this._translateY);
          return (translateX + ' ' + translateY).trim();
        };
        MdPanelPosition.prototype._isOnscreen = function(panelEl) {
          var left = parseInt(this.getLeft());
          var top = parseInt(this.getTop());
          var right = left + panelEl[0].offsetWidth;
          var bottom = top + panelEl[0].offsetHeight;
          return (left >= 0) && (top >= 0) && (bottom <= this._$window.innerHeight) && (right <= this._$window.innerWidth);
        };
        MdPanelPosition.prototype.getActualPosition = function() {
          return this._actualPosition;
        };
        MdPanelPosition.prototype._reduceTranslateValues = function(translateFn, values) {
          return values.map(function(translation) {
            return translateFn + '(' + translation + ')';
          }).join(' ');
        };
        MdPanelPosition.prototype._setPanelPosition = function(panelEl) {
          if (this._absolute) {
            return;
          }
          if (this._actualPosition) {
            this._calculatePanelPosition(panelEl, this._actualPosition);
            return;
          }
          for (var i = 0; i < this._positions.length; i++) {
            this._actualPosition = this._positions[i];
            this._calculatePanelPosition(panelEl, this._actualPosition);
            if (this._isOnscreen(panelEl)) {
              break;
            }
          }
        };
        MdPanelPosition.prototype._calculatePanelPosition = function(panelEl, position) {
          var panelBounds = panelEl[0].getBoundingClientRect();
          var panelWidth = panelBounds.width;
          var panelHeight = panelBounds.height;
          var targetBounds = this._relativeToEl[0].getBoundingClientRect();
          var targetLeft = targetBounds.left;
          var targetRight = targetBounds.right;
          var targetWidth = targetBounds.width;
          switch (position.x) {
            case MdPanelPosition.xPosition.OFFSET_START:
              this._left = targetLeft - panelWidth + 'px';
              break;
            case MdPanelPosition.xPosition.ALIGN_END:
              this._left = targetRight - panelWidth + 'px';
              break;
            case MdPanelPosition.xPosition.CENTER:
              var left = targetLeft + (0.5 * targetWidth) - (0.5 * panelWidth);
              this._left = left + 'px';
              break;
            case MdPanelPosition.xPosition.ALIGN_START:
              this._left = targetLeft + 'px';
              break;
            case MdPanelPosition.xPosition.OFFSET_END:
              this._left = targetRight + 'px';
              break;
          }
          var targetTop = targetBounds.top;
          var targetBottom = targetBounds.bottom;
          var targetHeight = targetBounds.height;
          switch (position.y) {
            case MdPanelPosition.yPosition.ABOVE:
              this._top = targetTop - panelHeight + 'px';
              break;
            case MdPanelPosition.yPosition.ALIGN_BOTTOMS:
              this._top = targetBottom - panelHeight + 'px';
              break;
            case MdPanelPosition.yPosition.CENTER:
              var top = targetTop + (0.5 * targetHeight) - (0.5 * panelHeight);
              this._top = top + 'px';
              break;
            case MdPanelPosition.yPosition.ALIGN_TOPS:
              this._top = targetTop + 'px';
              break;
            case MdPanelPosition.yPosition.BELOW:
              this._top = targetBottom + 'px';
              break;
          }
        };
        function MdPanelAnimation($injector) {
          this._$mdUtil = $injector.get('$mdUtil');
          this._openFrom;
          this._closeTo;
          this._animationClass = '';
        }
        MdPanelAnimation.animation = {
          SLIDE: 'md-panel-animate-slide',
          SCALE: 'md-panel-animate-scale',
          FADE: 'md-panel-animate-fade'
        };
        MdPanelAnimation.prototype.openFrom = function(openFrom) {
          openFrom = openFrom.target ? openFrom.target : openFrom;
          this._openFrom = this._getPanelAnimationTarget(openFrom);
          if (!this._closeTo) {
            this._closeTo = this._openFrom;
          }
          return this;
        };
        MdPanelAnimation.prototype.closeTo = function(closeTo) {
          this._closeTo = this._getPanelAnimationTarget(closeTo);
          return this;
        };
        MdPanelAnimation.prototype._getPanelAnimationTarget = function(location) {
          if (angular.isDefined(location.top) || angular.isDefined(location.left)) {
            return {
              element: undefined,
              bounds: {
                top: location.top || 0,
                left: location.left || 0
              }
            };
          } else {
            return this._getBoundingClientRect(getElement(location));
          }
        };
        MdPanelAnimation.prototype.withAnimation = function(cssClass) {
          this._animationClass = cssClass;
          return this;
        };
        MdPanelAnimation.prototype.animateOpen = function(panelEl) {
          var animator = this._$mdUtil.dom.animator;
          this._fixBounds(panelEl);
          var animationOptions = {};
          var panelTransform = panelEl[0].style.transform || '';
          var openFrom = animator.toTransformCss(panelTransform);
          var openTo = animator.toTransformCss(panelTransform);
          switch (this._animationClass) {
            case MdPanelAnimation.animation.SLIDE:
              panelEl.css('opacity', '1');
              animationOptions = {transitionInClass: '_md-panel-animate-enter'};
              var openSlide = animator.calculateSlideToOrigin(panelEl, this._openFrom) || '';
              openFrom = animator.toTransformCss(openSlide + ' ' + panelTransform);
              break;
            case MdPanelAnimation.animation.SCALE:
              animationOptions = {transitionInClass: '_md-panel-animate-enter'};
              var openScale = animator.calculateZoomToOrigin(panelEl, this._openFrom) || '';
              openFrom = animator.toTransformCss(openScale + ' ' + panelTransform);
              break;
            case MdPanelAnimation.animation.FADE:
              animationOptions = {transitionInClass: '_md-panel-animate-enter'};
              break;
            default:
              if (angular.isString(this._animationClass)) {
                animationOptions = {transitionInClass: this._animationClass};
              } else {
                animationOptions = {
                  transitionInClass: this._animationClass['open'],
                  transitionOutClass: this._animationClass['close']
                };
              }
          }
          return animator.translate3d(panelEl, openFrom, openTo, animationOptions);
        };
        MdPanelAnimation.prototype.animateClose = function(panelEl) {
          var animator = this._$mdUtil.dom.animator;
          var reverseAnimationOptions = {};
          var panelTransform = panelEl[0].style.transform || '';
          var closeFrom = animator.toTransformCss(panelTransform);
          var closeTo = animator.toTransformCss(panelTransform);
          switch (this._animationClass) {
            case MdPanelAnimation.animation.SLIDE:
              panelEl.css('opacity', '1');
              reverseAnimationOptions = {transitionInClass: '_md-panel-animate-leave'};
              var closeSlide = animator.calculateSlideToOrigin(panelEl, this._closeTo) || '';
              closeTo = animator.toTransformCss(closeSlide + ' ' + panelTransform);
              break;
            case MdPanelAnimation.animation.SCALE:
              reverseAnimationOptions = {transitionInClass: '_md-panel-animate-scale-out _md-panel-animate-leave'};
              var closeScale = animator.calculateZoomToOrigin(panelEl, this._closeTo) || '';
              closeTo = animator.toTransformCss(closeScale + ' ' + panelTransform);
              break;
            case MdPanelAnimation.animation.FADE:
              reverseAnimationOptions = {transitionInClass: '_md-panel-animate-fade-out _md-panel-animate-leave'};
              break;
            default:
              if (angular.isString(this._animationClass)) {
                reverseAnimationOptions = {transitionOutClass: this._animationClass};
              } else {
                reverseAnimationOptions = {
                  transitionInClass: this._animationClass['close'],
                  transitionOutClass: this._animationClass['open']
                };
              }
          }
          return animator.translate3d(panelEl, closeFrom, closeTo, reverseAnimationOptions);
        };
        MdPanelAnimation.prototype._fixBounds = function(panelEl) {
          var panelWidth = panelEl[0].offsetWidth;
          var panelHeight = panelEl[0].offsetHeight;
          if (this._openFrom && this._openFrom.bounds.height == null) {
            this._openFrom.bounds.height = panelHeight;
          }
          if (this._openFrom && this._openFrom.bounds.width == null) {
            this._openFrom.bounds.width = panelWidth;
          }
          if (this._closeTo && this._closeTo.bounds.height == null) {
            this._closeTo.bounds.height = panelHeight;
          }
          if (this._closeTo && this._closeTo.bounds.width == null) {
            this._closeTo.bounds.width = panelWidth;
          }
        };
        MdPanelAnimation.prototype._getBoundingClientRect = function(element) {
          if (element instanceof angular.element) {
            return {
              element: element,
              bounds: element[0].getBoundingClientRect()
            };
          }
        };
        function getElement(el) {
          var queryResult = angular.isString(el) ? document.querySelector(el) : el;
          return angular.element(queryResult);
        }
      })();
      (function() {
        "use strict";
        angular.module('material.components.progressCircular', ['material.core']);
      })();
      (function() {
        "use strict";
        angular.module('material.components.progressLinear', ['material.core']).directive('mdProgressLinear', MdProgressLinearDirective);
        function MdProgressLinearDirective($mdTheming, $mdUtil, $log) {
          var MODE_DETERMINATE = "determinate";
          var MODE_INDETERMINATE = "indeterminate";
          var MODE_BUFFER = "buffer";
          var MODE_QUERY = "query";
          var DISABLED_CLASS = "_md-progress-linear-disabled";
          return {
            restrict: 'E',
            template: '<div class="_md-container">' + '<div class="_md-dashed"></div>' + '<div class="_md-bar _md-bar1"></div>' + '<div class="_md-bar _md-bar2"></div>' + '</div>',
            compile: compile
          };
          function compile(tElement, tAttrs, transclude) {
            tElement.attr('aria-valuemin', 0);
            tElement.attr('aria-valuemax', 100);
            tElement.attr('role', 'progressbar');
            return postLink;
          }
          function postLink(scope, element, attr) {
            $mdTheming(element);
            var lastMode;
            var isDisabled = attr.hasOwnProperty('disabled');
            var toVendorCSS = $mdUtil.dom.animator.toCss;
            var bar1 = angular.element(element[0].querySelector('._md-bar1'));
            var bar2 = angular.element(element[0].querySelector('._md-bar2'));
            var container = angular.element(element[0].querySelector('._md-container'));
            element.attr('md-mode', mode()).toggleClass(DISABLED_CLASS, isDisabled);
            validateMode();
            watchAttributes();
            function watchAttributes() {
              attr.$observe('value', function(value) {
                var percentValue = clamp(value);
                element.attr('aria-valuenow', percentValue);
                if (mode() != MODE_QUERY)
                  animateIndicator(bar2, percentValue);
              });
              attr.$observe('mdBufferValue', function(value) {
                animateIndicator(bar1, clamp(value));
              });
              attr.$observe('disabled', function(value) {
                if (value === true || value === false) {
                  isDisabled = !!value;
                } else {
                  isDisabled = angular.isDefined(value);
                }
                element.toggleClass(DISABLED_CLASS, isDisabled);
                container.toggleClass(lastMode, !isDisabled);
              });
              attr.$observe('mdMode', function(mode) {
                if (lastMode)
                  container.removeClass(lastMode);
                switch (mode) {
                  case MODE_QUERY:
                  case MODE_BUFFER:
                  case MODE_DETERMINATE:
                  case MODE_INDETERMINATE:
                    container.addClass(lastMode = "_md-mode-" + mode);
                    break;
                  default:
                    container.addClass(lastMode = "_md-mode-" + MODE_INDETERMINATE);
                    break;
                }
              });
            }
            function validateMode() {
              if (angular.isUndefined(attr.mdMode)) {
                var hasValue = angular.isDefined(attr.value);
                var mode = hasValue ? MODE_DETERMINATE : MODE_INDETERMINATE;
                var info = "Auto-adding the missing md-mode='{0}' to the ProgressLinear element";
                element.attr("md-mode", mode);
                attr.mdMode = mode;
              }
            }
            function mode() {
              var value = (attr.mdMode || "").trim();
              if (value) {
                switch (value) {
                  case MODE_DETERMINATE:
                  case MODE_INDETERMINATE:
                  case MODE_BUFFER:
                  case MODE_QUERY:
                    break;
                  default:
                    value = MODE_INDETERMINATE;
                    break;
                }
              }
              return value;
            }
            function animateIndicator(target, value) {
              if (isDisabled || !mode())
                return;
              var to = $mdUtil.supplant("translateX({0}%) scale({1},1)", [(value - 100) / 2, value / 100]);
              var styles = toVendorCSS({transform: to});
              angular.element(target).css(styles);
            }
          }
          function clamp(value) {
            return Math.max(0, Math.min(value || 0, 100));
          }
        }
        MdProgressLinearDirective.$inject = ["$mdTheming", "$mdUtil", "$log"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.radioButton', ['material.core']).directive('mdRadioGroup', mdRadioGroupDirective).directive('mdRadioButton', mdRadioButtonDirective);
        function mdRadioGroupDirective($mdUtil, $mdConstant, $mdTheming, $timeout) {
          RadioGroupController.prototype = createRadioGroupControllerProto();
          return {
            restrict: 'E',
            controller: ['$element', RadioGroupController],
            require: ['mdRadioGroup', '?ngModel'],
            link: {pre: linkRadioGroup}
          };
          function linkRadioGroup(scope, element, attr, ctrls) {
            element.addClass('_md');
            $mdTheming(element);
            var rgCtrl = ctrls[0];
            var ngModelCtrl = ctrls[1] || $mdUtil.fakeNgModel();
            rgCtrl.init(ngModelCtrl);
            scope.mouseActive = false;
            element.attr({
              'role': 'radiogroup',
              'tabIndex': element.attr('tabindex') || '0'
            }).on('keydown', keydownListener).on('mousedown', function(event) {
              scope.mouseActive = true;
              $timeout(function() {
                scope.mouseActive = false;
              }, 100);
            }).on('focus', function() {
              if (scope.mouseActive === false) {
                rgCtrl.$element.addClass('md-focused');
              }
            }).on('blur', function() {
              rgCtrl.$element.removeClass('md-focused');
            });
            function setFocus() {
              if (!element.hasClass('md-focused')) {
                element.addClass('md-focused');
              }
            }
            function keydownListener(ev) {
              var keyCode = ev.which || ev.keyCode;
              if (keyCode != $mdConstant.KEY_CODE.ENTER && ev.currentTarget != ev.target) {
                return;
              }
              switch (keyCode) {
                case $mdConstant.KEY_CODE.LEFT_ARROW:
                case $mdConstant.KEY_CODE.UP_ARROW:
                  ev.preventDefault();
                  rgCtrl.selectPrevious();
                  setFocus();
                  break;
                case $mdConstant.KEY_CODE.RIGHT_ARROW:
                case $mdConstant.KEY_CODE.DOWN_ARROW:
                  ev.preventDefault();
                  rgCtrl.selectNext();
                  setFocus();
                  break;
                case $mdConstant.KEY_CODE.ENTER:
                  var form = angular.element($mdUtil.getClosest(element[0], 'form'));
                  if (form.length > 0) {
                    form.triggerHandler('submit');
                  }
                  break;
              }
            }
          }
          function RadioGroupController($element) {
            this._radioButtonRenderFns = [];
            this.$element = $element;
          }
          function createRadioGroupControllerProto() {
            return {
              init: function(ngModelCtrl) {
                this._ngModelCtrl = ngModelCtrl;
                this._ngModelCtrl.$render = angular.bind(this, this.render);
              },
              add: function(rbRender) {
                this._radioButtonRenderFns.push(rbRender);
              },
              remove: function(rbRender) {
                var index = this._radioButtonRenderFns.indexOf(rbRender);
                if (index !== -1) {
                  this._radioButtonRenderFns.splice(index, 1);
                }
              },
              render: function() {
                this._radioButtonRenderFns.forEach(function(rbRender) {
                  rbRender();
                });
              },
              setViewValue: function(value, eventType) {
                this._ngModelCtrl.$setViewValue(value, eventType);
                this.render();
              },
              getViewValue: function() {
                return this._ngModelCtrl.$viewValue;
              },
              selectNext: function() {
                return changeSelectedButton(this.$element, 1);
              },
              selectPrevious: function() {
                return changeSelectedButton(this.$element, -1);
              },
              setActiveDescendant: function(radioId) {
                this.$element.attr('aria-activedescendant', radioId);
              }
            };
          }
          function changeSelectedButton(parent, increment) {
            var buttons = $mdUtil.iterator(parent[0].querySelectorAll('md-radio-button'), true);
            if (buttons.count()) {
              var validate = function(button) {
                return !angular.element(button).attr("disabled");
              };
              var selected = parent[0].querySelector('md-radio-button.md-checked');
              var target = buttons[increment < 0 ? 'previous' : 'next'](selected, validate) || buttons.first();
              angular.element(target).triggerHandler('click');
            }
          }
        }
        mdRadioGroupDirective.$inject = ["$mdUtil", "$mdConstant", "$mdTheming", "$timeout"];
        function mdRadioButtonDirective($mdAria, $mdUtil, $mdTheming) {
          var CHECKED_CSS = 'md-checked';
          return {
            restrict: 'E',
            require: '^mdRadioGroup',
            transclude: true,
            template: '<div class="_md-container" md-ink-ripple md-ink-ripple-checkbox>' + '<div class="_md-off"></div>' + '<div class="_md-on"></div>' + '</div>' + '<div ng-transclude class="_md-label"></div>',
            link: link
          };
          function link(scope, element, attr, rgCtrl) {
            var lastChecked;
            $mdTheming(element);
            configureAria(element, scope);
            initialize();
            function initialize(controller) {
              if (!rgCtrl) {
                throw 'RadioGroupController not found.';
              }
              rgCtrl.add(render);
              attr.$observe('value', render);
              element.on('click', listener).on('$destroy', function() {
                rgCtrl.remove(render);
              });
            }
            function listener(ev) {
              if (element[0].hasAttribute('disabled'))
                return;
              scope.$apply(function() {
                rgCtrl.setViewValue(attr.value, ev && ev.type);
              });
            }
            function render() {
              var checked = (rgCtrl.getViewValue() == attr.value);
              if (checked === lastChecked) {
                return;
              }
              lastChecked = checked;
              element.attr('aria-checked', checked);
              if (checked) {
                markParentAsChecked(true);
                element.addClass(CHECKED_CSS);
                rgCtrl.setActiveDescendant(element.attr('id'));
              } else {
                markParentAsChecked(false);
                element.removeClass(CHECKED_CSS);
              }
              function markParentAsChecked(addClass) {
                if (element.parent()[0].nodeName != "MD-RADIO-GROUP") {
                  element.parent()[!!addClass ? 'addClass' : 'removeClass'](CHECKED_CSS);
                }
              }
            }
            function configureAria(element, scope) {
              scope.ariaId = buildAriaID();
              element.attr({
                'id': scope.ariaId,
                'role': 'radio',
                'aria-checked': 'false'
              });
              $mdAria.expectWithText(element, 'aria-label');
              function buildAriaID() {
                return attr.id || ('radio' + "_" + $mdUtil.nextUid());
              }
            }
          }
        }
        mdRadioButtonDirective.$inject = ["$mdAria", "$mdUtil", "$mdTheming"];
      })();
      (function() {
        "use strict";
        var SELECT_EDGE_MARGIN = 8;
        var selectNextId = 0;
        var CHECKBOX_SELECTION_INDICATOR = angular.element('<div class="_md-container"><div class="_md-icon"></div></div>');
        angular.module('material.components.select', ['material.core', 'material.components.backdrop']).directive('mdSelect', SelectDirective).directive('mdSelectMenu', SelectMenuDirective).directive('mdOption', OptionDirective).directive('mdOptgroup', OptgroupDirective).directive('mdSelectHeader', SelectHeaderDirective).provider('$mdSelect', SelectProvider);
        function SelectDirective($mdSelect, $mdUtil, $mdTheming, $mdAria, $compile, $parse) {
          return {
            restrict: 'E',
            require: ['^?mdInputContainer', 'mdSelect', 'ngModel', '?^form'],
            compile: compile,
            controller: function() {}
          };
          function compile(element, attr) {
            var valueEl = angular.element('<md-select-value><span></span></md-select-value>');
            valueEl.append('<span class="_md-select-icon" aria-hidden="true"></span>');
            valueEl.addClass('_md-select-value');
            if (!valueEl[0].hasAttribute('id')) {
              valueEl.attr('id', 'select_value_label_' + $mdUtil.nextUid());
            }
            if (!element.find('md-content').length) {
              element.append(angular.element('<md-content>').append(element.contents()));
            }
            if (attr.mdOnOpen) {
              element.find('md-content').prepend(angular.element('<div>' + ' <md-progress-circular md-mode="indeterminate" ng-if="$$loadingAsyncDone === false" md-diameter="25px"></md-progress-circular>' + '</div>'));
              element.find('md-option').attr('ng-show', '$$loadingAsyncDone');
            }
            if (attr.name) {
              var autofillClone = angular.element('<select class="_md-visually-hidden">');
              autofillClone.attr({
                'name': attr.name,
                'aria-hidden': 'true',
                'tabindex': '-1'
              });
              var opts = element.find('md-option');
              angular.forEach(opts, function(el) {
                var newEl = angular.element('<option>' + el.innerHTML + '</option>');
                if (el.hasAttribute('ng-value'))
                  newEl.attr('ng-value', el.getAttribute('ng-value'));
                else if (el.hasAttribute('value'))
                  newEl.attr('value', el.getAttribute('value'));
                autofillClone.append(newEl);
              });
              autofillClone.append('<option ng-value="' + attr.ngModel + '" selected></option>');
              element.parent().append(autofillClone);
            }
            var isMultiple = $mdUtil.parseAttributeBoolean(attr.multiple);
            var multipleContent = isMultiple ? 'multiple' : '';
            var selectTemplate = '' + '<div class="_md-select-menu-container" aria-hidden="true">' + '<md-select-menu {0}>{1}</md-select-menu>' + '</div>';
            selectTemplate = $mdUtil.supplant(selectTemplate, [multipleContent, element.html()]);
            element.empty().append(valueEl);
            element.append(selectTemplate);
            if (!attr.tabindex) {
              attr.$set('tabindex', 0);
            }
            return function postLink(scope, element, attr, ctrls) {
              var untouched = true;
              var isDisabled,
                  ariaLabelBase;
              var containerCtrl = ctrls[0];
              var mdSelectCtrl = ctrls[1];
              var ngModelCtrl = ctrls[2];
              var formCtrl = ctrls[3];
              var valueEl = element.find('md-select-value');
              var isReadonly = angular.isDefined(attr.readonly);
              var disableAsterisk = $mdUtil.parseAttributeBoolean(attr.mdNoAsterisk);
              if (containerCtrl) {
                var isErrorGetter = containerCtrl.isErrorGetter || function() {
                  return ngModelCtrl.$invalid && (ngModelCtrl.$touched || $mdUtil.isParentFormSubmitted(element));
                };
                if (containerCtrl.input) {
                  if (element.find('md-select-header').find('input')[0] !== containerCtrl.input[0]) {
                    throw new Error("<md-input-container> can only have *one* child <input>, <textarea> or <select> element!");
                  }
                }
                containerCtrl.input = element;
                if (!containerCtrl.label) {
                  $mdAria.expect(element, 'aria-label', element.attr('placeholder'));
                }
                scope.$watch(isErrorGetter, containerCtrl.setInvalid);
              }
              var selectContainer,
                  selectScope,
                  selectMenuCtrl;
              findSelectContainer();
              $mdTheming(element);
              if (formCtrl && angular.isDefined(attr.multiple)) {
                $mdUtil.nextTick(function() {
                  var hasModelValue = ngModelCtrl.$modelValue || ngModelCtrl.$viewValue;
                  if (hasModelValue) {
                    formCtrl.$setPristine();
                  }
                });
              }
              var originalRender = ngModelCtrl.$render;
              ngModelCtrl.$render = function() {
                originalRender();
                syncLabelText();
                syncAriaLabel();
                inputCheckValue();
              };
              attr.$observe('placeholder', ngModelCtrl.$render);
              if (containerCtrl && containerCtrl.label) {
                attr.$observe('required', function(value) {
                  containerCtrl.label.toggleClass('md-required', value && !disableAsterisk);
                });
              }
              mdSelectCtrl.setLabelText = function(text) {
                mdSelectCtrl.setIsPlaceholder(!text);
                if (attr.mdSelectedText) {
                  text = $parse(attr.mdSelectedText)(scope);
                } else {
                  var tmpPlaceholder = attr.placeholder || (containerCtrl && containerCtrl.label ? containerCtrl.label.text() : '');
                  text = text || tmpPlaceholder || '';
                }
                var target = valueEl.children().eq(0);
                target.html(text);
              };
              mdSelectCtrl.setIsPlaceholder = function(isPlaceholder) {
                if (isPlaceholder) {
                  valueEl.addClass('_md-select-placeholder');
                  if (containerCtrl && containerCtrl.label) {
                    containerCtrl.label.addClass('_md-placeholder');
                  }
                } else {
                  valueEl.removeClass('_md-select-placeholder');
                  if (containerCtrl && containerCtrl.label) {
                    containerCtrl.label.removeClass('_md-placeholder');
                  }
                }
              };
              if (!isReadonly) {
                element.on('focus', function(ev) {
                  containerCtrl && containerCtrl.setFocused(true);
                });
                element.on('blur', function(event) {
                  if (untouched) {
                    untouched = false;
                    if (selectScope._mdSelectIsOpen) {
                      event.stopImmediatePropagation();
                    }
                  }
                  if (selectScope._mdSelectIsOpen)
                    return;
                  containerCtrl && containerCtrl.setFocused(false);
                  inputCheckValue();
                });
              }
              mdSelectCtrl.triggerClose = function() {
                $parse(attr.mdOnClose)(scope);
              };
              scope.$$postDigest(function() {
                initAriaLabel();
                syncLabelText();
                syncAriaLabel();
              });
              function initAriaLabel() {
                var labelText = element.attr('aria-label') || element.attr('placeholder');
                if (!labelText && containerCtrl && containerCtrl.label) {
                  labelText = containerCtrl.label.text();
                }
                ariaLabelBase = labelText;
                $mdAria.expect(element, 'aria-label', labelText);
              }
              scope.$watch(function() {
                return selectMenuCtrl.selectedLabels();
              }, syncLabelText);
              function syncLabelText() {
                if (selectContainer) {
                  selectMenuCtrl = selectMenuCtrl || selectContainer.find('md-select-menu').controller('mdSelectMenu');
                  mdSelectCtrl.setLabelText(selectMenuCtrl.selectedLabels());
                }
              }
              function syncAriaLabel() {
                if (!ariaLabelBase)
                  return;
                var ariaLabels = selectMenuCtrl.selectedLabels({mode: 'aria'});
                element.attr('aria-label', ariaLabels.length ? ariaLabelBase + ': ' + ariaLabels : ariaLabelBase);
              }
              var deregisterWatcher;
              attr.$observe('ngMultiple', function(val) {
                if (deregisterWatcher)
                  deregisterWatcher();
                var parser = $parse(val);
                deregisterWatcher = scope.$watch(function() {
                  return parser(scope);
                }, function(multiple, prevVal) {
                  if (multiple === undefined && prevVal === undefined)
                    return;
                  if (multiple) {
                    element.attr('multiple', 'multiple');
                  } else {
                    element.removeAttr('multiple');
                  }
                  element.attr('aria-multiselectable', multiple ? 'true' : 'false');
                  if (selectContainer) {
                    selectMenuCtrl.setMultiple(multiple);
                    originalRender = ngModelCtrl.$render;
                    ngModelCtrl.$render = function() {
                      originalRender();
                      syncLabelText();
                      syncAriaLabel();
                      inputCheckValue();
                    };
                    ngModelCtrl.$render();
                  }
                });
              });
              attr.$observe('disabled', function(disabled) {
                if (angular.isString(disabled)) {
                  disabled = true;
                }
                if (isDisabled !== undefined && isDisabled === disabled) {
                  return;
                }
                isDisabled = disabled;
                if (disabled) {
                  element.attr({'aria-disabled': 'true'}).removeAttr('tabindex').off('click', openSelect).off('keydown', handleKeypress);
                } else {
                  element.attr({
                    'tabindex': attr.tabindex,
                    'aria-disabled': 'false'
                  }).on('click', openSelect).on('keydown', handleKeypress);
                }
              });
              if (!attr.hasOwnProperty('disabled') && !attr.hasOwnProperty('ngDisabled')) {
                element.attr({'aria-disabled': 'false'});
                element.on('click', openSelect);
                element.on('keydown', handleKeypress);
              }
              var ariaAttrs = {
                role: 'listbox',
                'aria-expanded': 'false',
                'aria-multiselectable': isMultiple && !attr.ngMultiple ? 'true' : 'false'
              };
              if (!element[0].hasAttribute('id')) {
                ariaAttrs.id = 'select_' + $mdUtil.nextUid();
              }
              var containerId = 'select_container_' + $mdUtil.nextUid();
              selectContainer.attr('id', containerId);
              ariaAttrs['aria-owns'] = containerId;
              element.attr(ariaAttrs);
              scope.$on('$destroy', function() {
                $mdSelect.destroy().finally(function() {
                  if (containerCtrl) {
                    containerCtrl.setFocused(false);
                    containerCtrl.setHasValue(false);
                    containerCtrl.input = null;
                  }
                  ngModelCtrl.$setTouched();
                });
              });
              function inputCheckValue() {
                containerCtrl && containerCtrl.setHasValue(selectMenuCtrl.selectedLabels().length > 0 || (element[0].validity || {}).badInput);
              }
              function findSelectContainer() {
                selectContainer = angular.element(element[0].querySelector('._md-select-menu-container'));
                selectScope = scope;
                if (attr.mdContainerClass) {
                  var value = selectContainer[0].getAttribute('class') + ' ' + attr.mdContainerClass;
                  selectContainer[0].setAttribute('class', value);
                }
                selectMenuCtrl = selectContainer.find('md-select-menu').controller('mdSelectMenu');
                selectMenuCtrl.init(ngModelCtrl, attr.ngModel);
                element.on('$destroy', function() {
                  selectContainer.remove();
                });
              }
              function handleKeypress(e) {
                var allowedCodes = [32, 13, 38, 40];
                if (allowedCodes.indexOf(e.keyCode) != -1) {
                  e.preventDefault();
                  openSelect(e);
                } else {
                  if (e.keyCode <= 90 && e.keyCode >= 31) {
                    e.preventDefault();
                    var node = selectMenuCtrl.optNodeForKeyboardSearch(e);
                    if (!node || node.hasAttribute('disabled'))
                      return;
                    var optionCtrl = angular.element(node).controller('mdOption');
                    if (!selectMenuCtrl.isMultiple) {
                      selectMenuCtrl.deselect(Object.keys(selectMenuCtrl.selected)[0]);
                    }
                    selectMenuCtrl.select(optionCtrl.hashKey, optionCtrl.value);
                    selectMenuCtrl.refreshViewValue();
                  }
                }
              }
              function openSelect() {
                selectScope._mdSelectIsOpen = true;
                element.attr('aria-expanded', 'true');
                $mdSelect.show({
                  scope: selectScope,
                  preserveScope: true,
                  skipCompile: true,
                  element: selectContainer,
                  target: element[0],
                  selectCtrl: mdSelectCtrl,
                  preserveElement: true,
                  hasBackdrop: true,
                  loadingAsync: attr.mdOnOpen ? scope.$eval(attr.mdOnOpen) || true : false
                }).finally(function() {
                  selectScope._mdSelectIsOpen = false;
                  element.focus();
                  element.attr('aria-expanded', 'false');
                  ngModelCtrl.$setTouched();
                });
              }
            };
          }
        }
        SelectDirective.$inject = ["$mdSelect", "$mdUtil", "$mdTheming", "$mdAria", "$compile", "$parse"];
        function SelectMenuDirective($parse, $mdUtil, $mdTheming) {
          SelectMenuController.$inject = ["$scope", "$attrs", "$element"];
          return {
            restrict: 'E',
            require: ['mdSelectMenu'],
            scope: false,
            controller: SelectMenuController,
            link: {pre: preLink}
          };
          function preLink(scope, element, attr, ctrls) {
            var selectCtrl = ctrls[0];
            element.addClass('_md');
            $mdTheming(element);
            element.on('click', clickListener);
            element.on('keypress', keyListener);
            function keyListener(e) {
              if (e.keyCode == 13 || e.keyCode == 32) {
                clickListener(e);
              }
            }
            function clickListener(ev) {
              var option = $mdUtil.getClosest(ev.target, 'md-option');
              var optionCtrl = option && angular.element(option).data('$mdOptionController');
              if (!option || !optionCtrl)
                return;
              if (option.hasAttribute('disabled')) {
                ev.stopImmediatePropagation();
                return false;
              }
              var optionHashKey = selectCtrl.hashGetter(optionCtrl.value);
              var isSelected = angular.isDefined(selectCtrl.selected[optionHashKey]);
              scope.$apply(function() {
                if (selectCtrl.isMultiple) {
                  if (isSelected) {
                    selectCtrl.deselect(optionHashKey);
                  } else {
                    selectCtrl.select(optionHashKey, optionCtrl.value);
                  }
                } else {
                  if (!isSelected) {
                    selectCtrl.deselect(Object.keys(selectCtrl.selected)[0]);
                    selectCtrl.select(optionHashKey, optionCtrl.value);
                  }
                }
                selectCtrl.refreshViewValue();
              });
            }
          }
          function SelectMenuController($scope, $attrs, $element) {
            var self = this;
            self.isMultiple = angular.isDefined($attrs.multiple);
            self.selected = {};
            self.options = {};
            $scope.$watchCollection(function() {
              return self.options;
            }, function() {
              self.ngModel.$render();
            });
            var deregisterCollectionWatch;
            var defaultIsEmpty;
            self.setMultiple = function(isMultiple) {
              var ngModel = self.ngModel;
              defaultIsEmpty = defaultIsEmpty || ngModel.$isEmpty;
              self.isMultiple = isMultiple;
              if (deregisterCollectionWatch)
                deregisterCollectionWatch();
              if (self.isMultiple) {
                ngModel.$validators['md-multiple'] = validateArray;
                ngModel.$render = renderMultiple;
                $scope.$watchCollection(self.modelBinding, function(value) {
                  if (validateArray(value))
                    renderMultiple(value);
                  self.ngModel.$setPristine();
                });
                ngModel.$isEmpty = function(value) {
                  return !value || value.length === 0;
                };
              } else {
                delete ngModel.$validators['md-multiple'];
                ngModel.$render = renderSingular;
              }
              function validateArray(modelValue, viewValue) {
                return angular.isArray(modelValue || viewValue || []);
              }
            };
            var searchStr = '';
            var clearSearchTimeout,
                optNodes,
                optText;
            var CLEAR_SEARCH_AFTER = 300;
            self.optNodeForKeyboardSearch = function(e) {
              clearSearchTimeout && clearTimeout(clearSearchTimeout);
              clearSearchTimeout = setTimeout(function() {
                clearSearchTimeout = undefined;
                searchStr = '';
                optText = undefined;
                optNodes = undefined;
              }, CLEAR_SEARCH_AFTER);
              searchStr += String.fromCharCode(e.keyCode);
              var search = new RegExp('^' + searchStr, 'i');
              if (!optNodes) {
                optNodes = $element.find('md-option');
                optText = new Array(optNodes.length);
                angular.forEach(optNodes, function(el, i) {
                  optText[i] = el.textContent.trim();
                });
              }
              for (var i = 0; i < optText.length; ++i) {
                if (search.test(optText[i])) {
                  return optNodes[i];
                }
              }
            };
            self.init = function(ngModel, binding) {
              self.ngModel = ngModel;
              self.modelBinding = binding;
              self.ngModel.$isEmpty = function($viewValue) {
                return !self.options[self.hashGetter($viewValue)];
              };
              if (ngModel.$options && ngModel.$options.trackBy) {
                var trackByLocals = {};
                var trackByParsed = $parse(ngModel.$options.trackBy);
                self.hashGetter = function(value, valueScope) {
                  trackByLocals.$value = value;
                  return trackByParsed(valueScope || $scope, trackByLocals);
                };
              } else {
                self.hashGetter = function getHashValue(value) {
                  if (angular.isObject(value)) {
                    return 'object_' + (value.$$mdSelectId || (value.$$mdSelectId = ++selectNextId));
                  }
                  return value;
                };
              }
              self.setMultiple(self.isMultiple);
            };
            self.selectedLabels = function(opts) {
              opts = opts || {};
              var mode = opts.mode || 'html';
              var selectedOptionEls = $mdUtil.nodesToArray($element[0].querySelectorAll('md-option[selected]'));
              if (selectedOptionEls.length) {
                var mapFn;
                if (mode == 'html') {
                  mapFn = function(el) {
                    var html = el.innerHTML;
                    var rippleContainer = el.querySelector('.md-ripple-container');
                    if (rippleContainer) {
                      html = html.replace(rippleContainer.outerHTML, '');
                    }
                    var checkboxContainer = el.querySelector('._md-container');
                    if (checkboxContainer) {
                      html = html.replace(checkboxContainer.outerHTML, '');
                    }
                    return html;
                  };
                } else if (mode == 'aria') {
                  mapFn = function(el) {
                    return el.hasAttribute('aria-label') ? el.getAttribute('aria-label') : el.textContent;
                  };
                }
                return selectedOptionEls.map(mapFn).join(', ');
              } else {
                return '';
              }
            };
            self.select = function(hashKey, hashedValue) {
              var option = self.options[hashKey];
              option && option.setSelected(true);
              self.selected[hashKey] = hashedValue;
            };
            self.deselect = function(hashKey) {
              var option = self.options[hashKey];
              option && option.setSelected(false);
              delete self.selected[hashKey];
            };
            self.addOption = function(hashKey, optionCtrl) {
              if (angular.isDefined(self.options[hashKey])) {
                throw new Error('Duplicate md-option values are not allowed in a select. ' + 'Duplicate value "' + optionCtrl.value + '" found.');
              }
              self.options[hashKey] = optionCtrl;
              if (angular.isDefined(self.selected[hashKey])) {
                self.select(hashKey, optionCtrl.value);
                if (self.ngModel.$modelValue && self.hashGetter(self.ngModel.$modelValue) === hashKey) {
                  self.ngModel.$validate();
                }
                self.refreshViewValue();
              }
            };
            self.removeOption = function(hashKey) {
              delete self.options[hashKey];
            };
            self.refreshViewValue = function() {
              var values = [];
              var option;
              for (var hashKey in self.selected) {
                if ((option = self.options[hashKey])) {
                  values.push(option.value);
                } else {
                  values.push(self.selected[hashKey]);
                }
              }
              var usingTrackBy = self.ngModel.$options && self.ngModel.$options.trackBy;
              var newVal = self.isMultiple ? values : values[0];
              var prevVal = self.ngModel.$modelValue;
              if (usingTrackBy ? !angular.equals(prevVal, newVal) : prevVal != newVal) {
                self.ngModel.$setViewValue(newVal);
                self.ngModel.$render();
              }
            };
            function renderMultiple() {
              var newSelectedValues = self.ngModel.$modelValue || self.ngModel.$viewValue || [];
              if (!angular.isArray(newSelectedValues))
                return;
              var oldSelected = Object.keys(self.selected);
              var newSelectedHashes = newSelectedValues.map(self.hashGetter);
              var deselected = oldSelected.filter(function(hash) {
                return newSelectedHashes.indexOf(hash) === -1;
              });
              deselected.forEach(self.deselect);
              newSelectedHashes.forEach(function(hashKey, i) {
                self.select(hashKey, newSelectedValues[i]);
              });
            }
            function renderSingular() {
              var value = self.ngModel.$viewValue || self.ngModel.$modelValue;
              Object.keys(self.selected).forEach(self.deselect);
              self.select(self.hashGetter(value), value);
            }
          }
        }
        SelectMenuDirective.$inject = ["$parse", "$mdUtil", "$mdTheming"];
        function OptionDirective($mdButtonInkRipple, $mdUtil) {
          OptionController.$inject = ["$element"];
          return {
            restrict: 'E',
            require: ['mdOption', '^^mdSelectMenu'],
            controller: OptionController,
            compile: compile
          };
          function compile(element, attr) {
            element.append(angular.element('<div class="_md-text">').append(element.contents()));
            element.attr('tabindex', attr.tabindex || '0');
            return postLink;
          }
          function postLink(scope, element, attr, ctrls) {
            var optionCtrl = ctrls[0];
            var selectCtrl = ctrls[1];
            if (selectCtrl.isMultiple) {
              element.addClass('_md-checkbox-enabled');
              element.prepend(CHECKBOX_SELECTION_INDICATOR.clone());
            }
            if (angular.isDefined(attr.ngValue)) {
              scope.$watch(attr.ngValue, setOptionValue);
            } else if (angular.isDefined(attr.value)) {
              setOptionValue(attr.value);
            } else {
              scope.$watch(function() {
                return element.text().trim();
              }, setOptionValue);
            }
            attr.$observe('disabled', function(disabled) {
              if (disabled) {
                element.attr('tabindex', '-1');
              } else {
                element.attr('tabindex', '0');
              }
            });
            scope.$$postDigest(function() {
              attr.$observe('selected', function(selected) {
                if (!angular.isDefined(selected))
                  return;
                if (typeof selected == 'string')
                  selected = true;
                if (selected) {
                  if (!selectCtrl.isMultiple) {
                    selectCtrl.deselect(Object.keys(selectCtrl.selected)[0]);
                  }
                  selectCtrl.select(optionCtrl.hashKey, optionCtrl.value);
                } else {
                  selectCtrl.deselect(optionCtrl.hashKey);
                }
                selectCtrl.refreshViewValue();
              });
            });
            $mdButtonInkRipple.attach(scope, element);
            configureAria();
            function setOptionValue(newValue, oldValue, prevAttempt) {
              if (!selectCtrl.hashGetter) {
                if (!prevAttempt) {
                  scope.$$postDigest(function() {
                    setOptionValue(newValue, oldValue, true);
                  });
                }
                return;
              }
              var oldHashKey = selectCtrl.hashGetter(oldValue, scope);
              var newHashKey = selectCtrl.hashGetter(newValue, scope);
              optionCtrl.hashKey = newHashKey;
              optionCtrl.value = newValue;
              selectCtrl.removeOption(oldHashKey, optionCtrl);
              selectCtrl.addOption(newHashKey, optionCtrl);
            }
            scope.$on('$destroy', function() {
              selectCtrl.removeOption(optionCtrl.hashKey, optionCtrl);
            });
            function configureAria() {
              var ariaAttrs = {
                'role': 'option',
                'aria-selected': 'false'
              };
              if (!element[0].hasAttribute('id')) {
                ariaAttrs.id = 'select_option_' + $mdUtil.nextUid();
              }
              element.attr(ariaAttrs);
            }
          }
          function OptionController($element) {
            this.selected = false;
            this.setSelected = function(isSelected) {
              if (isSelected && !this.selected) {
                $element.attr({
                  'selected': 'selected',
                  'aria-selected': 'true'
                });
              } else if (!isSelected && this.selected) {
                $element.removeAttr('selected');
                $element.attr('aria-selected', 'false');
              }
              this.selected = isSelected;
            };
          }
        }
        OptionDirective.$inject = ["$mdButtonInkRipple", "$mdUtil"];
        function OptgroupDirective() {
          return {
            restrict: 'E',
            compile: compile
          };
          function compile(el, attrs) {
            if (!hasSelectHeader()) {
              setupLabelElement();
            }
            function hasSelectHeader() {
              return el.parent().find('md-select-header').length;
            }
            function setupLabelElement() {
              var labelElement = el.find('label');
              if (!labelElement.length) {
                labelElement = angular.element('<label>');
                el.prepend(labelElement);
              }
              labelElement.addClass('_md-container-ignore');
              if (attrs.label)
                labelElement.text(attrs.label);
            }
          }
        }
        function SelectHeaderDirective() {
          return {restrict: 'E'};
        }
        function SelectProvider($$interimElementProvider) {
          selectDefaultOptions.$inject = ["$mdSelect", "$mdConstant", "$mdUtil", "$window", "$q", "$$rAF", "$animateCss", "$animate", "$document"];
          return $$interimElementProvider('$mdSelect').setDefaults({
            methods: ['target'],
            options: selectDefaultOptions
          });
          function selectDefaultOptions($mdSelect, $mdConstant, $mdUtil, $window, $q, $$rAF, $animateCss, $animate, $document) {
            var ERROR_TARGET_EXPECTED = "$mdSelect.show() expected a target element in options.target but got '{0}'!";
            var animator = $mdUtil.dom.animator;
            return {
              parent: 'body',
              themable: true,
              onShow: onShow,
              onRemove: onRemove,
              hasBackdrop: true,
              disableParentScroll: true
            };
            function onRemove(scope, element, opts) {
              opts = opts || {};
              opts.cleanupInteraction();
              opts.cleanupResizing();
              opts.hideBackdrop();
              return (opts.$destroy === true) ? cleanElement() : animateRemoval().then(cleanElement);
              function animateRemoval() {
                return $animateCss(element, {addClass: '_md-leave'}).start();
              }
              function cleanElement() {
                element.removeClass('_md-active');
                element.attr('aria-hidden', 'true');
                element[0].style.display = 'none';
                announceClosed(opts);
                if (!opts.$destroy && opts.restoreFocus) {
                  opts.target.focus();
                }
              }
            }
            function onShow(scope, element, opts) {
              watchAsyncLoad();
              sanitizeAndConfigure(scope, opts);
              opts.hideBackdrop = showBackdrop(scope, element, opts);
              return showDropDown(scope, element, opts).then(function(response) {
                element.attr('aria-hidden', 'false');
                opts.alreadyOpen = true;
                opts.cleanupInteraction = activateInteraction();
                opts.cleanupResizing = activateResizing();
                return response;
              }, opts.hideBackdrop);
              function showDropDown(scope, element, opts) {
                opts.parent.append(element);
                return $q(function(resolve, reject) {
                  try {
                    $animateCss(element, {
                      removeClass: '_md-leave',
                      duration: 0
                    }).start().then(positionAndFocusMenu).then(resolve);
                  } catch (e) {
                    reject(e);
                  }
                });
              }
              function positionAndFocusMenu() {
                return $q(function(resolve) {
                  if (opts.isRemoved)
                    return $q.reject(false);
                  var info = calculateMenuPositions(scope, element, opts);
                  info.container.element.css(animator.toCss(info.container.styles));
                  info.dropDown.element.css(animator.toCss(info.dropDown.styles));
                  $$rAF(function() {
                    element.addClass('_md-active');
                    info.dropDown.element.css(animator.toCss({transform: ''}));
                    autoFocus(opts.focusedNode);
                    resolve();
                  });
                });
              }
              function showBackdrop(scope, element, options) {
                if (options.disableParentScroll && !$mdUtil.getClosest(options.target, 'MD-DIALOG')) {
                  options.restoreScroll = $mdUtil.disableScrollAround(options.element, options.parent);
                } else {
                  options.disableParentScroll = false;
                }
                if (options.hasBackdrop) {
                  options.backdrop = $mdUtil.createBackdrop(scope, "_md-select-backdrop _md-click-catcher");
                  $animate.enter(options.backdrop, $document[0].body, null, {duration: 0});
                }
                return function hideBackdrop() {
                  if (options.backdrop)
                    options.backdrop.remove();
                  if (options.disableParentScroll)
                    options.restoreScroll();
                  delete options.restoreScroll;
                };
              }
              function autoFocus(focusedNode) {
                if (focusedNode && !focusedNode.hasAttribute('disabled')) {
                  focusedNode.focus();
                }
              }
              function sanitizeAndConfigure(scope, options) {
                var selectEl = element.find('md-select-menu');
                if (!options.target) {
                  throw new Error($mdUtil.supplant(ERROR_TARGET_EXPECTED, [options.target]));
                }
                angular.extend(options, {
                  isRemoved: false,
                  target: angular.element(options.target),
                  parent: angular.element(options.parent),
                  selectEl: selectEl,
                  contentEl: element.find('md-content'),
                  optionNodes: selectEl[0].getElementsByTagName('md-option')
                });
              }
              function activateResizing() {
                var debouncedOnResize = (function(scope, target, options) {
                  return function() {
                    if (options.isRemoved)
                      return;
                    var updates = calculateMenuPositions(scope, target, options);
                    var container = updates.container;
                    var dropDown = updates.dropDown;
                    container.element.css(animator.toCss(container.styles));
                    dropDown.element.css(animator.toCss(dropDown.styles));
                  };
                })(scope, element, opts);
                var window = angular.element($window);
                window.on('resize', debouncedOnResize);
                window.on('orientationchange', debouncedOnResize);
                return function deactivateResizing() {
                  window.off('resize', debouncedOnResize);
                  window.off('orientationchange', debouncedOnResize);
                };
              }
              function watchAsyncLoad() {
                if (opts.loadingAsync && !opts.isRemoved) {
                  scope.$$loadingAsyncDone = false;
                  $q.when(opts.loadingAsync).then(function() {
                    scope.$$loadingAsyncDone = true;
                    delete opts.loadingAsync;
                  }).then(function() {
                    $$rAF(positionAndFocusMenu);
                  });
                }
              }
              function activateInteraction() {
                if (opts.isRemoved)
                  return;
                var dropDown = opts.selectEl;
                var selectCtrl = dropDown.controller('mdSelectMenu') || {};
                element.addClass('_md-clickable');
                opts.backdrop && opts.backdrop.on('click', onBackdropClick);
                dropDown.on('keydown', onMenuKeyDown);
                dropDown.on('click', checkCloseMenu);
                return function cleanupInteraction() {
                  opts.backdrop && opts.backdrop.off('click', onBackdropClick);
                  dropDown.off('keydown', onMenuKeyDown);
                  dropDown.off('click', checkCloseMenu);
                  element.removeClass('_md-clickable');
                  opts.isRemoved = true;
                };
                function onBackdropClick(e) {
                  e.preventDefault();
                  e.stopPropagation();
                  opts.restoreFocus = false;
                  $mdUtil.nextTick($mdSelect.hide, true);
                }
                function onMenuKeyDown(ev) {
                  var keyCodes = $mdConstant.KEY_CODE;
                  ev.preventDefault();
                  ev.stopPropagation();
                  switch (ev.keyCode) {
                    case keyCodes.UP_ARROW:
                      return focusPrevOption();
                    case keyCodes.DOWN_ARROW:
                      return focusNextOption();
                    case keyCodes.SPACE:
                    case keyCodes.ENTER:
                      var option = $mdUtil.getClosest(ev.target, 'md-option');
                      if (option) {
                        dropDown.triggerHandler({
                          type: 'click',
                          target: option
                        });
                        ev.preventDefault();
                      }
                      checkCloseMenu(ev);
                      break;
                    case keyCodes.TAB:
                    case keyCodes.ESCAPE:
                      ev.stopPropagation();
                      ev.preventDefault();
                      opts.restoreFocus = true;
                      $mdUtil.nextTick($mdSelect.hide, true);
                      break;
                    default:
                      if (ev.keyCode >= 31 && ev.keyCode <= 90) {
                        var optNode = dropDown.controller('mdSelectMenu').optNodeForKeyboardSearch(ev);
                        opts.focusedNode = optNode || opts.focusedNode;
                        optNode && optNode.focus();
                      }
                  }
                }
                function focusOption(direction) {
                  var optionsArray = $mdUtil.nodesToArray(opts.optionNodes);
                  var index = optionsArray.indexOf(opts.focusedNode);
                  var newOption;
                  do {
                    if (index === -1) {
                      index = 0;
                    } else if (direction === 'next' && index < optionsArray.length - 1) {
                      index++;
                    } else if (direction === 'prev' && index > 0) {
                      index--;
                    }
                    newOption = optionsArray[index];
                    if (newOption.hasAttribute('disabled'))
                      newOption = undefined;
                  } while (!newOption && index < optionsArray.length - 1 && index > 0);
                  newOption && newOption.focus();
                  opts.focusedNode = newOption;
                }
                function focusNextOption() {
                  focusOption('next');
                }
                function focusPrevOption() {
                  focusOption('prev');
                }
                function checkCloseMenu(ev) {
                  if (ev && (ev.type == 'click') && (ev.currentTarget != dropDown[0]))
                    return;
                  if (mouseOnScrollbar())
                    return;
                  var option = $mdUtil.getClosest(ev.target, 'md-option');
                  if (option && option.hasAttribute && !option.hasAttribute('disabled')) {
                    ev.preventDefault();
                    ev.stopPropagation();
                    if (!selectCtrl.isMultiple) {
                      opts.restoreFocus = true;
                      $mdUtil.nextTick(function() {
                        $mdSelect.hide(selectCtrl.ngModel.$viewValue);
                      }, true);
                    }
                  }
                  function mouseOnScrollbar() {
                    var clickOnScrollbar = false;
                    if (ev && (ev.currentTarget.children.length > 0)) {
                      var child = ev.currentTarget.children[0];
                      var hasScrollbar = child.scrollHeight > child.clientHeight;
                      if (hasScrollbar && child.children.length > 0) {
                        var relPosX = ev.pageX - ev.currentTarget.getBoundingClientRect().left;
                        if (relPosX > child.querySelector('md-option').offsetWidth)
                          clickOnScrollbar = true;
                      }
                    }
                    return clickOnScrollbar;
                  }
                }
              }
            }
            function announceClosed(opts) {
              var mdSelect = opts.selectCtrl;
              if (mdSelect) {
                var menuController = opts.selectEl.controller('mdSelectMenu');
                mdSelect.setLabelText(menuController ? menuController.selectedLabels() : '');
                mdSelect.triggerClose();
              }
            }
            function calculateMenuPositions(scope, element, opts) {
              var containerNode = element[0],
                  targetNode = opts.target[0].children[0],
                  parentNode = $document[0].body,
                  selectNode = opts.selectEl[0],
                  contentNode = opts.contentEl[0],
                  parentRect = parentNode.getBoundingClientRect(),
                  targetRect = targetNode.getBoundingClientRect(),
                  shouldOpenAroundTarget = false,
                  bounds = {
                    left: parentRect.left + SELECT_EDGE_MARGIN,
                    top: SELECT_EDGE_MARGIN,
                    bottom: parentRect.height - SELECT_EDGE_MARGIN,
                    right: parentRect.width - SELECT_EDGE_MARGIN - ($mdUtil.floatingScrollbars() ? 16 : 0)
                  },
                  spaceAvailable = {
                    top: targetRect.top - bounds.top,
                    left: targetRect.left - bounds.left,
                    right: bounds.right - (targetRect.left + targetRect.width),
                    bottom: bounds.bottom - (targetRect.top + targetRect.height)
                  },
                  maxWidth = parentRect.width - SELECT_EDGE_MARGIN * 2,
                  selectedNode = selectNode.querySelector('md-option[selected]'),
                  optionNodes = selectNode.getElementsByTagName('md-option'),
                  optgroupNodes = selectNode.getElementsByTagName('md-optgroup'),
                  isScrollable = calculateScrollable(element, contentNode),
                  centeredNode;
              var loading = isPromiseLike(opts.loadingAsync);
              if (!loading) {
                if (selectedNode) {
                  centeredNode = selectedNode;
                } else if (optgroupNodes.length) {
                  centeredNode = optgroupNodes[0];
                } else if (optionNodes.length) {
                  centeredNode = optionNodes[0];
                } else {
                  centeredNode = contentNode.firstElementChild || contentNode;
                }
              } else {
                centeredNode = contentNode.firstElementChild || contentNode;
              }
              if (contentNode.offsetWidth > maxWidth) {
                contentNode.style['max-width'] = maxWidth + 'px';
              } else {
                contentNode.style.maxWidth = null;
              }
              if (shouldOpenAroundTarget) {
                contentNode.style['min-width'] = targetRect.width + 'px';
              }
              if (isScrollable) {
                selectNode.classList.add('_md-overflow');
              }
              var focusedNode = centeredNode;
              if ((focusedNode.tagName || '').toUpperCase() === 'MD-OPTGROUP') {
                focusedNode = optionNodes[0] || contentNode.firstElementChild || contentNode;
                centeredNode = focusedNode;
              }
              opts.focusedNode = focusedNode;
              containerNode.style.display = 'block';
              var selectMenuRect = selectNode.getBoundingClientRect();
              var centeredRect = getOffsetRect(centeredNode);
              if (centeredNode) {
                var centeredStyle = $window.getComputedStyle(centeredNode);
                centeredRect.paddingLeft = parseInt(centeredStyle.paddingLeft, 10) || 0;
                centeredRect.paddingRight = parseInt(centeredStyle.paddingRight, 10) || 0;
              }
              if (isScrollable) {
                var scrollBuffer = contentNode.offsetHeight / 2;
                contentNode.scrollTop = centeredRect.top + centeredRect.height / 2 - scrollBuffer;
                if (spaceAvailable.top < scrollBuffer) {
                  contentNode.scrollTop = Math.min(centeredRect.top, contentNode.scrollTop + scrollBuffer - spaceAvailable.top);
                } else if (spaceAvailable.bottom < scrollBuffer) {
                  contentNode.scrollTop = Math.max(centeredRect.top + centeredRect.height - selectMenuRect.height, contentNode.scrollTop - scrollBuffer + spaceAvailable.bottom);
                }
              }
              var left,
                  top,
                  transformOrigin,
                  minWidth,
                  fontSize;
              if (shouldOpenAroundTarget) {
                left = targetRect.left;
                top = targetRect.top + targetRect.height;
                transformOrigin = '50% 0';
                if (top + selectMenuRect.height > bounds.bottom) {
                  top = targetRect.top - selectMenuRect.height;
                  transformOrigin = '50% 100%';
                }
              } else {
                left = (targetRect.left + centeredRect.left - centeredRect.paddingLeft) + 2;
                top = Math.floor(targetRect.top + targetRect.height / 2 - centeredRect.height / 2 - centeredRect.top + contentNode.scrollTop) + 2;
                transformOrigin = (centeredRect.left + targetRect.width / 2) + 'px ' + (centeredRect.top + centeredRect.height / 2 - contentNode.scrollTop) + 'px 0px';
                minWidth = Math.min(targetRect.width + centeredRect.paddingLeft + centeredRect.paddingRight, maxWidth);
                fontSize = window.getComputedStyle(targetNode)['font-size'];
              }
              var containerRect = containerNode.getBoundingClientRect();
              var scaleX = Math.round(100 * Math.min(targetRect.width / selectMenuRect.width, 1.0)) / 100;
              var scaleY = Math.round(100 * Math.min(targetRect.height / selectMenuRect.height, 1.0)) / 100;
              return {
                container: {
                  element: angular.element(containerNode),
                  styles: {
                    left: Math.floor(clamp(bounds.left, left, bounds.right - containerRect.width)),
                    top: Math.floor(clamp(bounds.top, top, bounds.bottom - containerRect.height)),
                    'min-width': minWidth,
                    'font-size': fontSize
                  }
                },
                dropDown: {
                  element: angular.element(selectNode),
                  styles: {
                    transformOrigin: transformOrigin,
                    transform: !opts.alreadyOpen ? $mdUtil.supplant('scale({0},{1})', [scaleX, scaleY]) : ""
                  }
                }
              };
            }
          }
          function isPromiseLike(obj) {
            return obj && angular.isFunction(obj.then);
          }
          function clamp(min, n, max) {
            return Math.max(min, Math.min(n, max));
          }
          function getOffsetRect(node) {
            return node ? {
              left: node.offsetLeft,
              top: node.offsetTop,
              width: node.offsetWidth,
              height: node.offsetHeight
            } : {
              left: 0,
              top: 0,
              width: 0,
              height: 0
            };
          }
          function calculateScrollable(element, contentNode) {
            var isScrollable = false;
            try {
              var oldDisplay = element[0].style.display;
              element[0].style.display = 'block';
              isScrollable = contentNode.scrollHeight > contentNode.offsetHeight;
              element[0].style.display = oldDisplay;
            } finally {}
            return isScrollable;
          }
        }
        SelectProvider.$inject = ["$$interimElementProvider"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.showHide', ['material.core']).directive('ngShow', createDirective('ngShow', true)).directive('ngHide', createDirective('ngHide', false));
        function createDirective(name, targetValue) {
          return ['$mdUtil', function($mdUtil) {
            return {
              restrict: 'A',
              multiElement: true,
              link: function($scope, $element, $attr) {
                var unregister = $scope.$on('$md-resize-enable', function() {
                  unregister();
                  var cachedTransitionStyles = window.getComputedStyle($element[0]);
                  $scope.$watch($attr[name], function(value) {
                    if (!!value === targetValue) {
                      $mdUtil.nextTick(function() {
                        $scope.$broadcast('$md-resize');
                      });
                      var opts = {cachedTransitionStyles: cachedTransitionStyles};
                      $mdUtil.dom.animator.waitTransitionEnd($element, opts).then(function() {
                        $scope.$broadcast('$md-resize');
                      });
                    }
                  });
                });
              }
            };
          }];
        }
      })();
      (function() {
        "use strict";
        angular.module('material.components.sidenav', ['material.core', 'material.components.backdrop']).factory('$mdSidenav', SidenavService).directive('mdSidenav', SidenavDirective).directive('mdSidenavFocus', SidenavFocusDirective).controller('$mdSidenavController', SidenavController);
        function SidenavService($mdComponentRegistry, $mdUtil, $q, $log) {
          var errorMsg = "SideNav '{0}' is not available! Did you use md-component-id='{0}'?";
          var service = {
            find: findInstance,
            waitFor: waitForInstance
          };
          return function(handle, enableWait) {
            if (angular.isUndefined(handle))
              return service;
            var shouldWait = enableWait === true;
            var instance = service.find(handle, shouldWait);
            return !instance && shouldWait ? service.waitFor(handle) : !instance && angular.isUndefined(enableWait) ? addLegacyAPI(service, handle) : instance;
          };
          function addLegacyAPI(service, handle) {
            var falseFn = function() {
              return false;
            };
            var rejectFn = function() {
              return $q.when($mdUtil.supplant(errorMsg, [handle || ""]));
            };
            return angular.extend({
              isLockedOpen: falseFn,
              isOpen: falseFn,
              toggle: rejectFn,
              open: rejectFn,
              close: rejectFn,
              onClose: angular.noop,
              then: function(callback) {
                return waitForInstance(handle).then(callback || angular.noop);
              }
            }, service);
          }
          function findInstance(handle, shouldWait) {
            var instance = $mdComponentRegistry.get(handle);
            if (!instance && !shouldWait) {
              $log.error($mdUtil.supplant(errorMsg, [handle || ""]));
              return undefined;
            }
            return instance;
          }
          function waitForInstance(handle) {
            return $mdComponentRegistry.when(handle).catch($log.error);
          }
        }
        SidenavService.$inject = ["$mdComponentRegistry", "$mdUtil", "$q", "$log"];
        function SidenavFocusDirective() {
          return {
            restrict: 'A',
            require: '^mdSidenav',
            link: function(scope, element, attr, sidenavCtrl) {}
          };
        }
        function SidenavDirective($mdMedia, $mdUtil, $mdConstant, $mdTheming, $animate, $compile, $parse, $log, $q, $document) {
          return {
            restrict: 'E',
            scope: {isOpen: '=?mdIsOpen'},
            controller: '$mdSidenavController',
            compile: function(element) {
              element.addClass('_md-closed');
              element.attr('tabIndex', '-1');
              return postLink;
            }
          };
          function postLink(scope, element, attr, sidenavCtrl) {
            var lastParentOverFlow;
            var backdrop;
            var triggeringElement = null;
            var previousContainerStyles;
            var promise = $q.when(true);
            var isLockedOpenParsed = $parse(attr.mdIsLockedOpen);
            var isLocked = function() {
              return isLockedOpenParsed(scope.$parent, {
                $media: function(arg) {
                  $log.warn("$media is deprecated for is-locked-open. Use $mdMedia instead.");
                  return $mdMedia(arg);
                },
                $mdMedia: $mdMedia
              });
            };
            if (!angular.isDefined(attr.mdDisableBackdrop)) {
              backdrop = $mdUtil.createBackdrop(scope, "_md-sidenav-backdrop md-opaque ng-enter");
            }
            element.addClass('_md');
            $mdTheming(element);
            if (backdrop)
              $mdTheming.inherit(backdrop, element);
            element.on('$destroy', function() {
              backdrop && backdrop.remove();
              sidenavCtrl.destroy();
            });
            scope.$on('$destroy', function() {
              backdrop && backdrop.remove();
            });
            scope.$watch(isLocked, updateIsLocked);
            scope.$watch('isOpen', updateIsOpen);
            sidenavCtrl.$toggleOpen = toggleOpen;
            function updateIsLocked(isLocked, oldValue) {
              scope.isLockedOpen = isLocked;
              if (isLocked === oldValue) {
                element.toggleClass('_md-locked-open', !!isLocked);
              } else {
                $animate[isLocked ? 'addClass' : 'removeClass'](element, '_md-locked-open');
              }
              if (backdrop) {
                backdrop.toggleClass('_md-locked-open', !!isLocked);
              }
            }
            function updateIsOpen(isOpen) {
              var focusEl = $mdUtil.findFocusTarget(element) || $mdUtil.findFocusTarget(element, '[md-sidenav-focus]') || element;
              var parent = element.parent();
              parent[isOpen ? 'on' : 'off']('keydown', onKeyDown);
              if (backdrop)
                backdrop[isOpen ? 'on' : 'off']('click', close);
              var restorePositioning = updateContainerPositions(parent, isOpen);
              if (isOpen) {
                triggeringElement = $document[0].activeElement;
              }
              disableParentScroll(isOpen);
              return promise = $q.all([isOpen && backdrop ? $animate.enter(backdrop, parent) : backdrop ? $animate.leave(backdrop) : $q.when(true), $animate[isOpen ? 'removeClass' : 'addClass'](element, '_md-closed')]).then(function() {
                if (scope.isOpen) {
                  focusEl && focusEl.focus();
                }
                restorePositioning && restorePositioning();
              });
            }
            function updateContainerPositions(parent, willOpen) {
              var drawerEl = element[0];
              var scrollTop = parent[0].scrollTop;
              if (willOpen && scrollTop) {
                previousContainerStyles = {
                  top: drawerEl.style.top,
                  bottom: drawerEl.style.bottom,
                  height: drawerEl.style.height
                };
                var positionStyle = {
                  top: scrollTop + 'px',
                  bottom: 'initial',
                  height: parent[0].clientHeight + 'px'
                };
                element.css(positionStyle);
                backdrop.css(positionStyle);
              }
              if (!willOpen && previousContainerStyles) {
                return function() {
                  drawerEl.style.top = previousContainerStyles.top;
                  drawerEl.style.bottom = previousContainerStyles.bottom;
                  drawerEl.style.height = previousContainerStyles.height;
                  backdrop[0].style.top = null;
                  backdrop[0].style.bottom = null;
                  backdrop[0].style.height = null;
                  previousContainerStyles = null;
                };
              }
            }
            function disableParentScroll(disabled) {
              var parent = element.parent();
              if (disabled && !lastParentOverFlow) {
                lastParentOverFlow = parent.css('overflow');
                parent.css('overflow', 'hidden');
              } else if (angular.isDefined(lastParentOverFlow)) {
                parent.css('overflow', lastParentOverFlow);
                lastParentOverFlow = undefined;
              }
            }
            function toggleOpen(isOpen) {
              if (scope.isOpen == isOpen) {
                return $q.when(true);
              } else {
                if (scope.isOpen && sidenavCtrl.onCloseCb)
                  sidenavCtrl.onCloseCb();
                return $q(function(resolve) {
                  scope.isOpen = isOpen;
                  $mdUtil.nextTick(function() {
                    promise.then(function(result) {
                      if (!scope.isOpen) {
                        triggeringElement && triggeringElement.focus();
                        triggeringElement = null;
                      }
                      resolve(result);
                    });
                  });
                });
              }
            }
            function onKeyDown(ev) {
              var isEscape = (ev.keyCode === $mdConstant.KEY_CODE.ESCAPE);
              return isEscape ? close(ev) : $q.when(true);
            }
            function close(ev) {
              ev.preventDefault();
              return sidenavCtrl.close();
            }
          }
        }
        SidenavDirective.$inject = ["$mdMedia", "$mdUtil", "$mdConstant", "$mdTheming", "$animate", "$compile", "$parse", "$log", "$q", "$document"];
        function SidenavController($scope, $element, $attrs, $mdComponentRegistry, $q) {
          var self = this;
          self.isOpen = function() {
            return !!$scope.isOpen;
          };
          self.isLockedOpen = function() {
            return !!$scope.isLockedOpen;
          };
          self.onClose = function(callback) {
            self.onCloseCb = callback;
            return self;
          };
          self.open = function() {
            return self.$toggleOpen(true);
          };
          self.close = function() {
            return self.$toggleOpen(false);
          };
          self.toggle = function() {
            return self.$toggleOpen(!$scope.isOpen);
          };
          self.$toggleOpen = function(value) {
            return $q.when($scope.isOpen = value);
          };
          self.destroy = $mdComponentRegistry.register(self, $attrs.mdComponentId);
        }
        SidenavController.$inject = ["$scope", "$element", "$attrs", "$mdComponentRegistry", "$q"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.slider', ['material.core']).directive('mdSlider', SliderDirective).directive('mdSliderContainer', SliderContainerDirective);
        function SliderContainerDirective() {
          return {
            controller: function() {},
            compile: function(elem) {
              var slider = elem.find('md-slider');
              if (!slider) {
                return;
              }
              var vertical = slider.attr('md-vertical');
              if (vertical !== undefined) {
                elem.attr('md-vertical', '');
              }
              if (!slider.attr('flex')) {
                slider.attr('flex', '');
              }
              return function postLink(scope, element, attr, ctrl) {
                element.addClass('_md');
                function setDisable(value) {
                  element.children().attr('disabled', value);
                  element.find('input').attr('disabled', value);
                }
                var stopDisabledWatch = angular.noop;
                if (attr.disabled) {
                  setDisable(true);
                } else if (attr.ngDisabled) {
                  stopDisabledWatch = scope.$watch(attr.ngDisabled, function(value) {
                    setDisable(value);
                  });
                }
                scope.$on('$destroy', function() {
                  stopDisabledWatch();
                });
                var initialMaxWidth;
                ctrl.fitInputWidthToTextLength = function(length) {
                  var input = element[0].querySelector('md-input-container');
                  if (input) {
                    var computedStyle = getComputedStyle(input);
                    var minWidth = parseInt(computedStyle.minWidth);
                    var padding = parseInt(computedStyle.padding) * 2;
                    initialMaxWidth = initialMaxWidth || parseInt(computedStyle.maxWidth);
                    var newMaxWidth = Math.max(initialMaxWidth, minWidth + padding + (minWidth / 2 * length));
                    input.style.maxWidth = newMaxWidth + 'px';
                  }
                };
              };
            }
          };
        }
        function SliderDirective($$rAF, $window, $mdAria, $mdUtil, $mdConstant, $mdTheming, $mdGesture, $parse, $log, $timeout) {
          return {
            scope: {},
            require: ['?ngModel', '?^mdSliderContainer'],
            template: '<div class="_md-slider-wrapper">' + '<div class="_md-slider-content">' + '<div class="_md-track-container">' + '<div class="_md-track"></div>' + '<div class="_md-track _md-track-fill"></div>' + '<div class="_md-track-ticks"></div>' + '</div>' + '<div class="_md-thumb-container">' + '<div class="_md-thumb"></div>' + '<div class="_md-focus-thumb"></div>' + '<div class="_md-focus-ring"></div>' + '<div class="_md-sign">' + '<span class="_md-thumb-text"></span>' + '</div>' + '<div class="_md-disabled-thumb"></div>' + '</div>' + '</div>' + '</div>',
            compile: compile
          };
          function compile(tElement, tAttrs) {
            var wrapper = angular.element(tElement[0].getElementsByClassName('_md-slider-wrapper'));
            var tabIndex = tAttrs.tabindex || 0;
            wrapper.attr('tabindex', tabIndex);
            if (tAttrs.disabled || tAttrs.ngDisabled)
              wrapper.attr('tabindex', -1);
            wrapper.attr('role', 'slider');
            $mdAria.expect(tElement, 'aria-label');
            return postLink;
          }
          function postLink(scope, element, attr, ctrls) {
            $mdTheming(element);
            var ngModelCtrl = ctrls[0] || {
              $setViewValue: function(val) {
                this.$viewValue = val;
                this.$viewChangeListeners.forEach(function(cb) {
                  cb();
                });
              },
              $parsers: [],
              $formatters: [],
              $viewChangeListeners: []
            };
            var containerCtrl = ctrls[1];
            var container = angular.element($mdUtil.getClosest(element, '_md-slider-container', true));
            var isDisabled = attr.ngDisabled ? angular.bind(null, $parse(attr.ngDisabled), scope.$parent) : function() {
              return element[0].hasAttribute('disabled');
            };
            var thumb = angular.element(element[0].querySelector('._md-thumb'));
            var thumbText = angular.element(element[0].querySelector('._md-thumb-text'));
            var thumbContainer = thumb.parent();
            var trackContainer = angular.element(element[0].querySelector('._md-track-container'));
            var activeTrack = angular.element(element[0].querySelector('._md-track-fill'));
            var tickContainer = angular.element(element[0].querySelector('._md-track-ticks'));
            var wrapper = angular.element(element[0].getElementsByClassName('_md-slider-wrapper'));
            var content = angular.element(element[0].getElementsByClassName('_md-slider-content'));
            var throttledRefreshDimensions = $mdUtil.throttle(refreshSliderDimensions, 5000);
            var DEFAULT_ROUND = 3;
            var vertical = angular.isDefined(attr.mdVertical);
            var discrete = angular.isDefined(attr.mdDiscrete);
            var invert = angular.isDefined(attr.mdInvert);
            angular.isDefined(attr.min) ? attr.$observe('min', updateMin) : updateMin(0);
            angular.isDefined(attr.max) ? attr.$observe('max', updateMax) : updateMax(100);
            angular.isDefined(attr.step) ? attr.$observe('step', updateStep) : updateStep(1);
            angular.isDefined(attr.round) ? attr.$observe('round', updateRound) : updateRound(DEFAULT_ROUND);
            var stopDisabledWatch = angular.noop;
            if (attr.ngDisabled) {
              stopDisabledWatch = scope.$parent.$watch(attr.ngDisabled, updateAriaDisabled);
            }
            $mdGesture.register(wrapper, 'drag', {horizontal: !vertical});
            scope.mouseActive = false;
            wrapper.on('keydown', keydownListener).on('mousedown', mouseDownListener).on('focus', focusListener).on('blur', blurListener).on('$md.pressdown', onPressDown).on('$md.pressup', onPressUp).on('$md.dragstart', onDragStart).on('$md.drag', onDrag).on('$md.dragend', onDragEnd);
            function updateAll() {
              refreshSliderDimensions();
              ngModelRender();
            }
            setTimeout(updateAll, 0);
            var debouncedUpdateAll = $$rAF.throttle(updateAll);
            angular.element($window).on('resize', debouncedUpdateAll);
            scope.$on('$destroy', function() {
              angular.element($window).off('resize', debouncedUpdateAll);
            });
            ngModelCtrl.$render = ngModelRender;
            ngModelCtrl.$viewChangeListeners.push(ngModelRender);
            ngModelCtrl.$formatters.push(minMaxValidator);
            ngModelCtrl.$formatters.push(stepValidator);
            var min;
            var max;
            var step;
            var round;
            function updateMin(value) {
              min = parseFloat(value);
              element.attr('aria-valuemin', value);
              updateAll();
            }
            function updateMax(value) {
              max = parseFloat(value);
              element.attr('aria-valuemax', value);
              updateAll();
            }
            function updateStep(value) {
              step = parseFloat(value);
            }
            function updateRound(value) {
              round = minMaxValidator(parseInt(value), 0, 6);
            }
            function updateAriaDisabled() {
              element.attr('aria-disabled', !!isDisabled());
            }
            var tickCanvas,
                tickCtx;
            function redrawTicks() {
              if (!discrete || isDisabled())
                return;
              if (angular.isUndefined(step))
                return;
              if (step <= 0) {
                var msg = 'Slider step value must be greater than zero when in discrete mode';
                $log.error(msg);
                throw new Error(msg);
              }
              var numSteps = Math.floor((max - min) / step);
              if (!tickCanvas) {
                tickCanvas = angular.element('<canvas>').css('position', 'absolute');
                tickContainer.append(tickCanvas);
                tickCtx = tickCanvas[0].getContext('2d');
              }
              var dimensions = getSliderDimensions();
              if (dimensions && !dimensions.height && !dimensions.width) {
                refreshSliderDimensions();
                dimensions = sliderDimensions;
              }
              tickCanvas[0].width = dimensions.width;
              tickCanvas[0].height = dimensions.height;
              var distance;
              for (var i = 0; i <= numSteps; i++) {
                var trackTicksStyle = $window.getComputedStyle(tickContainer[0]);
                tickCtx.fillStyle = trackTicksStyle.color || 'black';
                distance = Math.floor((vertical ? dimensions.height : dimensions.width) * (i / numSteps));
                tickCtx.fillRect(vertical ? 0 : distance - 1, vertical ? distance - 1 : 0, vertical ? dimensions.width : 2, vertical ? 2 : dimensions.height);
              }
            }
            function clearTicks() {
              if (tickCanvas && tickCtx) {
                var dimensions = getSliderDimensions();
                tickCtx.clearRect(0, 0, dimensions.width, dimensions.height);
              }
            }
            var sliderDimensions = {};
            refreshSliderDimensions();
            function refreshSliderDimensions() {
              sliderDimensions = trackContainer[0].getBoundingClientRect();
            }
            function getSliderDimensions() {
              throttledRefreshDimensions();
              return sliderDimensions;
            }
            function keydownListener(ev) {
              if (isDisabled())
                return;
              var changeAmount;
              if (vertical ? ev.keyCode === $mdConstant.KEY_CODE.DOWN_ARROW : ev.keyCode === $mdConstant.KEY_CODE.LEFT_ARROW) {
                changeAmount = -step;
              } else if (vertical ? ev.keyCode === $mdConstant.KEY_CODE.UP_ARROW : ev.keyCode === $mdConstant.KEY_CODE.RIGHT_ARROW) {
                changeAmount = step;
              }
              changeAmount = invert ? -changeAmount : changeAmount;
              if (changeAmount) {
                if (ev.metaKey || ev.ctrlKey || ev.altKey) {
                  changeAmount *= 4;
                }
                ev.preventDefault();
                ev.stopPropagation();
                scope.$evalAsync(function() {
                  setModelValue(ngModelCtrl.$viewValue + changeAmount);
                });
              }
            }
            function mouseDownListener() {
              redrawTicks();
              scope.mouseActive = true;
              wrapper.removeClass('md-focused');
              $timeout(function() {
                scope.mouseActive = false;
              }, 100);
            }
            function focusListener() {
              if (scope.mouseActive === false) {
                wrapper.addClass('md-focused');
              }
            }
            function blurListener() {
              wrapper.removeClass('md-focused');
              element.removeClass('_md-active');
              clearTicks();
            }
            function setModelValue(value) {
              ngModelCtrl.$setViewValue(minMaxValidator(stepValidator(value)));
            }
            function ngModelRender() {
              if (isNaN(ngModelCtrl.$viewValue)) {
                ngModelCtrl.$viewValue = ngModelCtrl.$modelValue;
              }
              ngModelCtrl.$viewValue = minMaxValidator(ngModelCtrl.$viewValue);
              var percent = valueToPercent(ngModelCtrl.$viewValue);
              scope.modelValue = ngModelCtrl.$viewValue;
              element.attr('aria-valuenow', ngModelCtrl.$viewValue);
              setSliderPercent(percent);
              thumbText.text(ngModelCtrl.$viewValue);
            }
            function minMaxValidator(value, minValue, maxValue) {
              if (angular.isNumber(value)) {
                minValue = angular.isNumber(minValue) ? minValue : min;
                maxValue = angular.isNumber(maxValue) ? maxValue : max;
                return Math.max(minValue, Math.min(maxValue, value));
              }
            }
            function stepValidator(value) {
              if (angular.isNumber(value)) {
                var formattedValue = (Math.round((value - min) / step) * step + min);
                formattedValue = (Math.round(formattedValue * Math.pow(10, round)) / Math.pow(10, round));
                if (containerCtrl && containerCtrl.fitInputWidthToTextLength) {
                  $mdUtil.debounce(function() {
                    containerCtrl.fitInputWidthToTextLength(formattedValue.toString().length);
                  }, 100)();
                }
                return formattedValue;
              }
            }
            function setSliderPercent(percent) {
              percent = clamp(percent);
              var thumbPosition = (percent * 100) + '%';
              var activeTrackPercent = invert ? (1 - percent) * 100 + '%' : thumbPosition;
              if (vertical) {
                thumbContainer.css('bottom', thumbPosition);
              } else {
                $mdUtil.bidiProperty(thumbContainer, 'left', 'right', thumbPosition);
              }
              activeTrack.css(vertical ? 'height' : 'width', activeTrackPercent);
              element.toggleClass((invert ? '_md-max' : '_md-min'), percent === 0);
              element.toggleClass((invert ? '_md-min' : '_md-max'), percent === 1);
            }
            var isDragging = false;
            function onPressDown(ev) {
              if (isDisabled())
                return;
              element.addClass('_md-active');
              element[0].focus();
              refreshSliderDimensions();
              var exactVal = percentToValue(positionToPercent(vertical ? ev.pointer.y : ev.pointer.x));
              var closestVal = minMaxValidator(stepValidator(exactVal));
              scope.$apply(function() {
                setModelValue(closestVal);
                setSliderPercent(valueToPercent(closestVal));
              });
            }
            function onPressUp(ev) {
              if (isDisabled())
                return;
              element.removeClass('_md-dragging');
              var exactVal = percentToValue(positionToPercent(vertical ? ev.pointer.y : ev.pointer.x));
              var closestVal = minMaxValidator(stepValidator(exactVal));
              scope.$apply(function() {
                setModelValue(closestVal);
                ngModelRender();
              });
            }
            function onDragStart(ev) {
              if (isDisabled())
                return;
              isDragging = true;
              ev.stopPropagation();
              element.addClass('_md-dragging');
              setSliderFromEvent(ev);
            }
            function onDrag(ev) {
              if (!isDragging)
                return;
              ev.stopPropagation();
              setSliderFromEvent(ev);
            }
            function onDragEnd(ev) {
              if (!isDragging)
                return;
              ev.stopPropagation();
              isDragging = false;
            }
            function setSliderFromEvent(ev) {
              if (discrete)
                adjustThumbPosition(vertical ? ev.pointer.y : ev.pointer.x);
              else
                doSlide(vertical ? ev.pointer.y : ev.pointer.x);
            }
            function doSlide(x) {
              scope.$evalAsync(function() {
                setModelValue(percentToValue(positionToPercent(x)));
              });
            }
            function adjustThumbPosition(x) {
              var exactVal = percentToValue(positionToPercent(x));
              var closestVal = minMaxValidator(stepValidator(exactVal));
              setSliderPercent(positionToPercent(x));
              thumbText.text(closestVal);
            }
            function clamp(value) {
              return Math.max(0, Math.min(value || 0, 1));
            }
            function positionToPercent(position) {
              var offset = vertical ? sliderDimensions.top : sliderDimensions.left;
              var size = vertical ? sliderDimensions.height : sliderDimensions.width;
              var calc = (position - offset) / size;
              if (!vertical && $mdUtil.bidi() === 'rtl') {
                calc = 1 - calc;
              }
              return Math.max(0, Math.min(1, vertical ? 1 - calc : calc));
            }
            function percentToValue(percent) {
              var adjustedPercent = invert ? (1 - percent) : percent;
              return (min + adjustedPercent * (max - min));
            }
            function valueToPercent(val) {
              var percent = (val - min) / (max - min);
              return invert ? (1 - percent) : percent;
            }
          }
        }
        SliderDirective.$inject = ["$$rAF", "$window", "$mdAria", "$mdUtil", "$mdConstant", "$mdTheming", "$mdGesture", "$parse", "$log", "$timeout"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.sticky', ['material.core', 'material.components.content']).factory('$mdSticky', MdSticky);
        function MdSticky($mdConstant, $$rAF, $mdUtil, $compile) {
          var browserStickySupport = $mdUtil.checkStickySupport();
          return function registerStickyElement(scope, element, stickyClone) {
            var contentCtrl = element.controller('mdContent');
            if (!contentCtrl)
              return;
            if (browserStickySupport) {
              element.css({
                position: browserStickySupport,
                top: 0,
                'z-index': 2
              });
            } else {
              var $$sticky = contentCtrl.$element.data('$$sticky');
              if (!$$sticky) {
                $$sticky = setupSticky(contentCtrl);
                contentCtrl.$element.data('$$sticky', $$sticky);
              }
              var cloneElement = stickyClone || $compile(element.clone())(scope);
              var deregister = $$sticky.add(element, cloneElement);
              scope.$on('$destroy', deregister);
            }
          };
          function setupSticky(contentCtrl) {
            var contentEl = contentCtrl.$element;
            var debouncedRefreshElements = $$rAF.throttle(refreshElements);
            setupAugmentedScrollEvents(contentEl);
            contentEl.on('$scrollstart', debouncedRefreshElements);
            contentEl.on('$scroll', onScroll);
            var self;
            return self = {
              prev: null,
              current: null,
              next: null,
              items: [],
              add: add,
              refreshElements: refreshElements
            };
            function add(element, stickyClone) {
              stickyClone.addClass('_md-sticky-clone');
              var item = {
                element: element,
                clone: stickyClone
              };
              self.items.push(item);
              $mdUtil.nextTick(function() {
                contentEl.prepend(item.clone);
              });
              debouncedRefreshElements();
              return function remove() {
                self.items.forEach(function(item, index) {
                  if (item.element[0] === element[0]) {
                    self.items.splice(index, 1);
                    item.clone.remove();
                  }
                });
                debouncedRefreshElements();
              };
            }
            function refreshElements() {
              self.items.forEach(refreshPosition);
              self.items = self.items.sort(function(a, b) {
                return a.top < b.top ? -1 : 1;
              });
              var item;
              var currentScrollTop = contentEl.prop('scrollTop');
              for (var i = self.items.length - 1; i >= 0; i--) {
                if (currentScrollTop > self.items[i].top) {
                  item = self.items[i];
                  break;
                }
              }
              setCurrentItem(item);
            }
            function refreshPosition(item) {
              var current = item.element[0];
              item.top = 0;
              item.left = 0;
              item.right = 0;
              while (current && current !== contentEl[0]) {
                item.top += current.offsetTop;
                item.left += current.offsetLeft;
                if (current.offsetParent) {
                  item.right += current.offsetParent.offsetWidth - current.offsetWidth - current.offsetLeft;
                }
                current = current.offsetParent;
              }
              item.height = item.element.prop('offsetHeight');
              var defaultVal = $mdUtil.floatingScrollbars() ? '0' : undefined;
              $mdUtil.bidi(item.clone, 'margin-left', item.left, defaultVal);
              $mdUtil.bidi(item.clone, 'margin-right', defaultVal, item.right);
            }
            function onScroll() {
              var scrollTop = contentEl.prop('scrollTop');
              var isScrollingDown = scrollTop > (onScroll.prevScrollTop || 0);
              onScroll.prevScrollTop = scrollTop;
              if (scrollTop === 0) {
                setCurrentItem(null);
                return;
              }
              if (isScrollingDown) {
                if (self.next && self.next.top <= scrollTop) {
                  setCurrentItem(self.next);
                  return;
                }
                if (self.current && self.next && self.next.top - scrollTop <= self.next.height) {
                  translate(self.current, scrollTop + (self.next.top - self.next.height - scrollTop));
                  return;
                }
              }
              if (!isScrollingDown) {
                if (self.current && self.prev && scrollTop < self.current.top) {
                  setCurrentItem(self.prev);
                  return;
                }
                if (self.next && self.current && (scrollTop >= (self.next.top - self.current.height))) {
                  translate(self.current, scrollTop + (self.next.top - scrollTop - self.current.height));
                  return;
                }
              }
              if (self.current) {
                translate(self.current, scrollTop);
              }
            }
            function setCurrentItem(item) {
              if (self.current === item)
                return;
              if (self.current) {
                translate(self.current, null);
                setStickyState(self.current, null);
              }
              if (item) {
                setStickyState(item, 'active');
              }
              self.current = item;
              var index = self.items.indexOf(item);
              self.next = self.items[index + 1];
              self.prev = self.items[index - 1];
              setStickyState(self.next, 'next');
              setStickyState(self.prev, 'prev');
            }
            function setStickyState(item, state) {
              if (!item || item.state === state)
                return;
              if (item.state) {
                item.clone.attr('sticky-prev-state', item.state);
                item.element.attr('sticky-prev-state', item.state);
              }
              item.clone.attr('sticky-state', state);
              item.element.attr('sticky-state', state);
              item.state = state;
            }
            function translate(item, amount) {
              if (!item)
                return;
              if (amount === null || amount === undefined) {
                if (item.translateY) {
                  item.translateY = null;
                  item.clone.css($mdConstant.CSS.TRANSFORM, '');
                }
              } else {
                item.translateY = amount;
                $mdUtil.bidi(item.clone, $mdConstant.CSS.TRANSFORM, 'translate3d(' + item.left + 'px,' + amount + 'px,0)', 'translateY(' + amount + 'px)');
              }
            }
          }
          function setupAugmentedScrollEvents(element) {
            var SCROLL_END_DELAY = 200;
            var isScrolling;
            var lastScrollTime;
            element.on('scroll touchmove', function() {
              if (!isScrolling) {
                isScrolling = true;
                $$rAF.throttle(loopScrollEvent);
                element.triggerHandler('$scrollstart');
              }
              element.triggerHandler('$scroll');
              lastScrollTime = +$mdUtil.now();
            });
            function loopScrollEvent() {
              if (+$mdUtil.now() - lastScrollTime > SCROLL_END_DELAY) {
                isScrolling = false;
                element.triggerHandler('$scrollend');
              } else {
                element.triggerHandler('$scroll');
                $$rAF.throttle(loopScrollEvent);
              }
            }
          }
        }
        MdSticky.$inject = ["$mdConstant", "$$rAF", "$mdUtil", "$compile"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.subheader', ['material.core', 'material.components.sticky']).directive('mdSubheader', MdSubheaderDirective);
        function MdSubheaderDirective($mdSticky, $compile, $mdTheming, $mdUtil) {
          return {
            restrict: 'E',
            replace: true,
            transclude: true,
            template: ('<div class="md-subheader _md">' + '  <div class="_md-subheader-inner">' + '    <div class="_md-subheader-content"></div>' + '  </div>' + '</div>'),
            link: function postLink(scope, element, attr, controllers, transclude) {
              $mdTheming(element);
              element.addClass('_md');
              var outerHTML = element[0].outerHTML;
              function getContent(el) {
                return angular.element(el[0].querySelector('._md-subheader-content'));
              }
              transclude(scope, function(clone) {
                getContent(element).append(clone);
              });
              if (!element.hasClass('md-no-sticky')) {
                transclude(scope, function(clone) {
                  var wrapper = $compile('<div class="_md-subheader-wrapper">' + outerHTML + '</div>')(scope);
                  $mdUtil.nextTick(function() {
                    getContent(wrapper).append(clone);
                  });
                  $mdSticky(scope, element, wrapper);
                });
              }
            }
          };
        }
        MdSubheaderDirective.$inject = ["$mdSticky", "$compile", "$mdTheming", "$mdUtil"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.swipe', ['material.core']).directive('mdSwipeLeft', getDirective('SwipeLeft')).directive('mdSwipeRight', getDirective('SwipeRight')).directive('mdSwipeUp', getDirective('SwipeUp')).directive('mdSwipeDown', getDirective('SwipeDown'));
        function getDirective(name) {
          var directiveName = 'md' + name;
          var eventName = '$md.' + name.toLowerCase();
          DirectiveFactory.$inject = ["$parse"];
          return DirectiveFactory;
          function DirectiveFactory($parse) {
            return {
              restrict: 'A',
              link: postLink
            };
            function postLink(scope, element, attr) {
              var fn = $parse(attr[directiveName]);
              element.on(eventName, function(ev) {
                scope.$applyAsync(function() {
                  fn(scope, {$event: ev});
                });
              });
            }
          }
        }
      })();
      (function() {
        "use strict";
        angular.module('material.components.switch', ['material.core', 'material.components.checkbox']).directive('mdSwitch', MdSwitch);
        function MdSwitch(mdCheckboxDirective, $mdUtil, $mdConstant, $parse, $$rAF, $mdGesture, $timeout) {
          var checkboxDirective = mdCheckboxDirective[0];
          return {
            restrict: 'E',
            priority: 210,
            transclude: true,
            template: '<div class="_md-container">' + '<div class="_md-bar"></div>' + '<div class="_md-thumb-container">' + '<div class="_md-thumb" md-ink-ripple md-ink-ripple-checkbox></div>' + '</div>' + '</div>' + '<div ng-transclude class="_md-label"></div>',
            require: '?ngModel',
            compile: mdSwitchCompile
          };
          function mdSwitchCompile(element, attr) {
            var checkboxLink = checkboxDirective.compile(element, attr);
            element.addClass('_md-dragging');
            return function(scope, element, attr, ngModel) {
              ngModel = ngModel || $mdUtil.fakeNgModel();
              var disabledGetter = null;
              if (attr.disabled != null) {
                disabledGetter = function() {
                  return true;
                };
              } else if (attr.ngDisabled) {
                disabledGetter = $parse(attr.ngDisabled);
              }
              var thumbContainer = angular.element(element[0].querySelector('._md-thumb-container'));
              var switchContainer = angular.element(element[0].querySelector('._md-container'));
              $$rAF(function() {
                element.removeClass('_md-dragging');
              });
              checkboxLink(scope, element, attr, ngModel);
              if (disabledGetter) {
                scope.$watch(disabledGetter, function(isDisabled) {
                  element.attr('tabindex', isDisabled ? -1 : 0);
                });
              }
              $mdGesture.register(switchContainer, 'drag');
              switchContainer.on('$md.dragstart', onDragStart).on('$md.drag', onDrag).on('$md.dragend', onDragEnd);
              var drag;
              function onDragStart(ev) {
                if (disabledGetter && disabledGetter(scope))
                  return;
                ev.stopPropagation();
                element.addClass('_md-dragging');
                drag = {width: thumbContainer.prop('offsetWidth')};
              }
              function onDrag(ev) {
                if (!drag)
                  return;
                ev.stopPropagation();
                ev.srcEvent && ev.srcEvent.preventDefault();
                var percent = ev.pointer.distanceX / drag.width;
                var translate = ngModel.$viewValue ? 1 + percent : percent;
                translate = Math.max(0, Math.min(1, translate));
                thumbContainer.css($mdConstant.CSS.TRANSFORM, 'translate3d(' + (100 * translate) + '%,0,0)');
                drag.translate = translate;
              }
              function onDragEnd(ev) {
                if (!drag)
                  return;
                ev.stopPropagation();
                element.removeClass('_md-dragging');
                thumbContainer.css($mdConstant.CSS.TRANSFORM, '');
                var isChanged = ngModel.$viewValue ? drag.translate < 0.5 : drag.translate > 0.5;
                if (isChanged) {
                  applyModelValue(!ngModel.$viewValue);
                }
                drag = null;
                scope.skipToggle = true;
                $timeout(function() {
                  scope.skipToggle = false;
                }, 1);
              }
              function applyModelValue(newValue) {
                scope.$apply(function() {
                  ngModel.$setViewValue(newValue);
                  ngModel.$render();
                });
              }
            };
          }
        }
        MdSwitch.$inject = ["mdCheckboxDirective", "$mdUtil", "$mdConstant", "$parse", "$$rAF", "$mdGesture", "$timeout"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.tabs', ['material.core', 'material.components.icon']);
      })();
      (function() {
        "use strict";
        angular.module('material.components.toast', ['material.core', 'material.components.button']).directive('mdToast', MdToastDirective).provider('$mdToast', MdToastProvider);
        function MdToastDirective($mdToast) {
          return {
            restrict: 'E',
            link: function postLink(scope, element) {
              element.addClass('_md');
              scope.$on('$destroy', function() {
                $mdToast.destroy();
              });
            }
          };
        }
        MdToastDirective.$inject = ["$mdToast"];
        function MdToastProvider($$interimElementProvider) {
          var ACTION_RESOLVE = 'ok';
          var activeToastContent;
          var $mdToast = $$interimElementProvider('$mdToast').setDefaults({
            methods: ['position', 'hideDelay', 'capsule', 'parent', 'position'],
            options: toastDefaultOptions
          }).addPreset('simple', {
            argOption: 'textContent',
            methods: ['textContent', 'content', 'action', 'highlightAction', 'highlightClass', 'theme', 'parent'],
            options: ["$mdToast", "$mdTheming", function($mdToast, $mdTheming) {
              return {
                template: '<md-toast md-theme="{{ toast.theme }}" ng-class="{\'md-capsule\': toast.capsule}">' + '  <div class="md-toast-content">' + '    <span flex class="md-toast-text" role="alert" aria-relevant="all" aria-atomic="true">' + '      {{ toast.content }}' + '    </span>' + '    <md-button class="md-action" ng-if="toast.action" ng-click="toast.resolve()" ' + '        ng-class="highlightClasses">' + '      {{ toast.action }}' + '    </md-button>' + '  </div>' + '</md-toast>',
                controller: ["$scope", function mdToastCtrl($scope) {
                  var self = this;
                  if (self.highlightAction) {
                    $scope.highlightClasses = ['md-highlight', self.highlightClass];
                  }
                  $scope.$watch(function() {
                    return activeToastContent;
                  }, function() {
                    self.content = activeToastContent;
                  });
                  this.resolve = function() {
                    $mdToast.hide(ACTION_RESOLVE);
                  };
                }],
                theme: $mdTheming.defaultTheme(),
                controllerAs: 'toast',
                bindToController: true
              };
            }]
          }).addMethod('updateTextContent', updateTextContent).addMethod('updateContent', updateTextContent);
          function updateTextContent(newContent) {
            activeToastContent = newContent;
          }
          toastDefaultOptions.$inject = ["$animate", "$mdToast", "$mdUtil", "$mdMedia"];
          return $mdToast;
          function toastDefaultOptions($animate, $mdToast, $mdUtil, $mdMedia) {
            var SWIPE_EVENTS = '$md.swipeleft $md.swiperight $md.swipeup $md.swipedown';
            return {
              onShow: onShow,
              onRemove: onRemove,
              position: 'bottom left',
              themable: true,
              hideDelay: 3000,
              autoWrap: true,
              transformTemplate: function(template, options) {
                var shouldAddWrapper = options.autoWrap && template && !/md-toast-content/g.test(template);
                if (shouldAddWrapper) {
                  var templateRoot = document.createElement('md-template');
                  templateRoot.innerHTML = template;
                  for (var i = 0; i < templateRoot.children.length; i++) {
                    if (templateRoot.children[i].nodeName === 'MD-TOAST') {
                      var wrapper = angular.element('<div class="md-toast-content">');
                      wrapper.append(angular.element(templateRoot.children[i].childNodes));
                      templateRoot.children[i].appendChild(wrapper[0]);
                    }
                  }
                  return templateRoot.innerHTML;
                }
                return template || '';
              }
            };
            function onShow(scope, element, options) {
              activeToastContent = options.textContent || options.content;
              var isSmScreen = !$mdMedia('gt-sm');
              element = $mdUtil.extractElementByName(element, 'md-toast', true);
              options.element = element;
              options.onSwipe = function(ev, gesture) {
                var swipe = ev.type.replace('$md.', '');
                var direction = swipe.replace('swipe', '');
                if ((direction === 'down' && options.position.indexOf('top') != -1 && !isSmScreen) || (direction === 'up' && (options.position.indexOf('bottom') != -1 || isSmScreen))) {
                  return;
                }
                if ((direction === 'left' || direction === 'right') && isSmScreen) {
                  return;
                }
                element.addClass('_md-' + swipe);
                $mdUtil.nextTick($mdToast.cancel);
              };
              options.openClass = toastOpenClass(options.position);
              options.parent.addClass(options.openClass);
              if ($mdUtil.hasComputedStyle(options.parent, 'position', 'static')) {
                options.parent.css('position', 'relative');
              }
              element.on(SWIPE_EVENTS, options.onSwipe);
              element.addClass(isSmScreen ? '_md-bottom' : options.position.split(' ').map(function(pos) {
                return '_md-' + pos;
              }).join(' '));
              if (options.parent)
                options.parent.addClass('_md-toast-animating');
              return $animate.enter(element, options.parent).then(function() {
                if (options.parent)
                  options.parent.removeClass('_md-toast-animating');
              });
            }
            function onRemove(scope, element, options) {
              element.off(SWIPE_EVENTS, options.onSwipe);
              if (options.parent)
                options.parent.addClass('_md-toast-animating');
              if (options.openClass)
                options.parent.removeClass(options.openClass);
              return ((options.$destroy == true) ? element.remove() : $animate.leave(element)).then(function() {
                if (options.parent)
                  options.parent.removeClass('_md-toast-animating');
                if ($mdUtil.hasComputedStyle(options.parent, 'position', 'static')) {
                  options.parent.css('position', '');
                }
              });
            }
            function toastOpenClass(position) {
              if (!$mdMedia('gt-xs')) {
                return '_md-toast-open-bottom';
              }
              return '_md-toast-open-' + (position.indexOf('top') > -1 ? 'top' : 'bottom');
            }
          }
        }
        MdToastProvider.$inject = ["$$interimElementProvider"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.toolbar', ['material.core', 'material.components.content']).directive('mdToolbar', mdToolbarDirective);
        function mdToolbarDirective($$rAF, $mdConstant, $mdUtil, $mdTheming, $animate) {
          var translateY = angular.bind(null, $mdUtil.supplant, 'translate3d(0,{0}px,0)');
          return {
            template: '',
            restrict: 'E',
            link: function(scope, element, attr) {
              element.addClass('_md');
              $mdTheming(element);
              $mdUtil.nextTick(function() {
                element.addClass('_md-toolbar-transitions');
              }, false);
              if (angular.isDefined(attr.mdScrollShrink)) {
                setupScrollShrink();
              }
              function setupScrollShrink() {
                var toolbarHeight;
                var contentElement;
                var disableScrollShrink = angular.noop;
                var y = 0;
                var prevScrollTop = 0;
                var shrinkSpeedFactor = attr.mdShrinkSpeedFactor || 0.5;
                var debouncedContentScroll = $$rAF.throttle(onContentScroll);
                var debouncedUpdateHeight = $mdUtil.debounce(updateToolbarHeight, 5 * 1000);
                scope.$on('$mdContentLoaded', onMdContentLoad);
                attr.$observe('mdScrollShrink', onChangeScrollShrink);
                if (attr.ngShow) {
                  scope.$watch(attr.ngShow, updateToolbarHeight);
                }
                if (attr.ngHide) {
                  scope.$watch(attr.ngHide, updateToolbarHeight);
                }
                scope.$on('$destroy', disableScrollShrink);
                function onChangeScrollShrink(shrinkWithScroll) {
                  var closestContent = element.parent().find('md-content');
                  if (!contentElement && closestContent.length) {
                    onMdContentLoad(null, closestContent);
                  }
                  shrinkWithScroll = scope.$eval(shrinkWithScroll);
                  if (shrinkWithScroll === false) {
                    disableScrollShrink();
                  } else {
                    disableScrollShrink = enableScrollShrink();
                  }
                }
                function onMdContentLoad($event, newContentEl) {
                  if (newContentEl && element.parent()[0] === newContentEl.parent()[0]) {
                    if (contentElement) {
                      contentElement.off('scroll', debouncedContentScroll);
                    }
                    contentElement = newContentEl;
                    disableScrollShrink = enableScrollShrink();
                  }
                }
                function onContentScroll(e) {
                  var scrollTop = e ? e.target.scrollTop : prevScrollTop;
                  debouncedUpdateHeight();
                  y = Math.min(toolbarHeight / shrinkSpeedFactor, Math.max(0, y + scrollTop - prevScrollTop));
                  element.css($mdConstant.CSS.TRANSFORM, translateY([-y * shrinkSpeedFactor]));
                  contentElement.css($mdConstant.CSS.TRANSFORM, translateY([(toolbarHeight - y) * shrinkSpeedFactor]));
                  prevScrollTop = scrollTop;
                  $mdUtil.nextTick(function() {
                    var hasWhiteFrame = element.hasClass('md-whiteframe-z1');
                    if (hasWhiteFrame && !y) {
                      $animate.removeClass(element, 'md-whiteframe-z1');
                    } else if (!hasWhiteFrame && y) {
                      $animate.addClass(element, 'md-whiteframe-z1');
                    }
                  });
                }
                function enableScrollShrink() {
                  if (!contentElement)
                    return angular.noop;
                  contentElement.on('scroll', debouncedContentScroll);
                  contentElement.attr('scroll-shrink', 'true');
                  $mdUtil.nextTick(updateToolbarHeight, false);
                  return function disableScrollShrink() {
                    contentElement.off('scroll', debouncedContentScroll);
                    contentElement.attr('scroll-shrink', 'false');
                    updateToolbarHeight();
                  };
                }
                function updateToolbarHeight() {
                  toolbarHeight = element.prop('offsetHeight');
                  var margin = (-toolbarHeight * shrinkSpeedFactor) + 'px';
                  contentElement.css({
                    "margin-top": margin,
                    "margin-bottom": margin
                  });
                  onContentScroll();
                }
              }
            }
          };
        }
        mdToolbarDirective.$inject = ["$$rAF", "$mdConstant", "$mdUtil", "$mdTheming", "$animate"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.tooltip', ['material.core']).directive('mdTooltip', MdTooltipDirective);
        function MdTooltipDirective($timeout, $window, $$rAF, $document, $mdUtil, $mdTheming, $rootElement, $animate, $q, $interpolate) {
          var ENTER_EVENTS = 'focus touchstart mouseenter';
          var LEAVE_EVENTS = 'blur touchcancel mouseleave';
          var TOOLTIP_SHOW_DELAY = 0;
          var TOOLTIP_WINDOW_EDGE_SPACE = 8;
          return {
            restrict: 'E',
            transclude: true,
            priority: 210,
            template: '<div class="_md-content _md" ng-transclude></div>',
            scope: {
              delay: '=?mdDelay',
              visible: '=?mdVisible',
              autohide: '=?mdAutohide',
              direction: '@?mdDirection'
            },
            compile: function(tElement, tAttr) {
              if (!tAttr.mdDirection) {
                tAttr.$set('mdDirection', 'bottom');
              }
              return postLink;
            }
          };
          function postLink(scope, element, attr) {
            $mdTheming(element);
            var parent = $mdUtil.getParentWithPointerEvents(element),
                content = angular.element(element[0].getElementsByClassName('_md-content')[0]),
                tooltipParent = angular.element(document.body),
                showTimeout = null,
                debouncedOnResize = $$rAF.throttle(function() {
                  updatePosition();
                });
            if ($animate.pin)
              $animate.pin(element, parent);
            setDefaults();
            manipulateElement();
            bindEvents();
            updateContentOrigin();
            configureWatchers();
            addAriaLabel();
            function setDefaults() {
              scope.delay = scope.delay || TOOLTIP_SHOW_DELAY;
            }
            function updateContentOrigin() {
              var origin = 'center top';
              switch (scope.direction) {
                case 'left':
                  origin = 'right center';
                  break;
                case 'right':
                  origin = 'left center';
                  break;
                case 'top':
                  origin = 'center bottom';
                  break;
                case 'bottom':
                  origin = 'center top';
                  break;
              }
              content.css('transform-origin', origin);
            }
            function onVisibleChanged(isVisible) {
              if (isVisible)
                showTooltip();
              else
                hideTooltip();
            }
            function configureWatchers() {
              if (element[0] && 'MutationObserver' in $window) {
                var attributeObserver = new MutationObserver(function(mutations) {
                  mutations.forEach(function(mutation) {
                    if (mutation.attributeName === 'md-visible') {
                      if (!scope.visibleWatcher)
                        scope.visibleWatcher = scope.$watch('visible', onVisibleChanged);
                    }
                    if (mutation.attributeName === 'md-direction') {
                      updatePosition(scope.direction);
                    }
                  });
                });
                attributeObserver.observe(element[0], {attributes: true});
                if (attr.hasOwnProperty('mdVisible')) {
                  scope.visibleWatcher = scope.$watch('visible', onVisibleChanged);
                }
              } else {
                scope.visibleWatcher = scope.$watch('visible', onVisibleChanged);
                scope.$watch('direction', updatePosition);
              }
              var onElementDestroy = function() {
                scope.$destroy();
              };
              element.one('$destroy', onElementDestroy);
              parent.one('$destroy', onElementDestroy);
              scope.$on('$destroy', function() {
                setVisible(false);
                element.remove();
                attributeObserver && attributeObserver.disconnect();
              });
              if (element.text().indexOf($interpolate.startSymbol()) > -1) {
                scope.$watch(function() {
                  return element.text().trim();
                }, addAriaLabel);
              }
            }
            function addAriaLabel(override) {
              if ((override || !parent.attr('aria-label')) && !parent.text().trim()) {
                var rawText = override || element.text().trim();
                var interpolatedText = $interpolate(rawText)(parent.scope());
                parent.attr('aria-label', interpolatedText);
              }
            }
            function manipulateElement() {
              element.detach();
              element.attr('role', 'tooltip');
            }
            function bindEvents() {
              var mouseActive = false;
              if (parent[0] && 'MutationObserver' in $window) {
                var attributeObserver = new MutationObserver(function(mutations) {
                  if (mutations.some(function(mutation) {
                    return (mutation.attributeName === 'disabled' && parent[0].disabled);
                  })) {
                    $mdUtil.nextTick(function() {
                      setVisible(false);
                    });
                  }
                });
                attributeObserver.observe(parent[0], {attributes: true});
              }
              var windowBlurHandler = function() {
                elementFocusedOnWindowBlur = document.activeElement === parent[0];
              };
              var elementFocusedOnWindowBlur = false;
              function windowScrollHandler() {
                setVisible(false);
              }
              angular.element($window).on('blur', windowBlurHandler).on('resize', debouncedOnResize);
              document.addEventListener('scroll', windowScrollHandler, true);
              scope.$on('$destroy', function() {
                angular.element($window).off('blur', windowBlurHandler).off('resize', debouncedOnResize);
                parent.off(ENTER_EVENTS, enterHandler).off(LEAVE_EVENTS, leaveHandler).off('mousedown', mousedownHandler);
                leaveHandler();
                document.removeEventListener('scroll', windowScrollHandler, true);
                attributeObserver && attributeObserver.disconnect();
              });
              var enterHandler = function(e) {
                if (e.type === 'focus' && elementFocusedOnWindowBlur) {
                  elementFocusedOnWindowBlur = false;
                } else if (!scope.visible) {
                  parent.on(LEAVE_EVENTS, leaveHandler);
                  setVisible(true);
                  if (e.type === 'touchstart') {
                    parent.one('touchend', function() {
                      $mdUtil.nextTick(function() {
                        $document.one('touchend', leaveHandler);
                      }, false);
                    });
                  }
                }
              };
              var leaveHandler = function() {
                var autohide = scope.hasOwnProperty('autohide') ? scope.autohide : attr.hasOwnProperty('mdAutohide');
                if (autohide || mouseActive || $document[0].activeElement !== parent[0]) {
                  if (showTimeout) {
                    $timeout.cancel(showTimeout);
                    setVisible.queued = false;
                    showTimeout = null;
                  }
                  parent.off(LEAVE_EVENTS, leaveHandler);
                  parent.triggerHandler('blur');
                  setVisible(false);
                }
                mouseActive = false;
              };
              var mousedownHandler = function() {
                mouseActive = true;
              };
              parent.on('mousedown', mousedownHandler);
              parent.on(ENTER_EVENTS, enterHandler);
            }
            function setVisible(value) {
              if (setVisible.queued && setVisible.value === !!value || !setVisible.queued && scope.visible === !!value)
                return;
              setVisible.value = !!value;
              if (!setVisible.queued) {
                if (value) {
                  setVisible.queued = true;
                  showTimeout = $timeout(function() {
                    scope.visible = setVisible.value;
                    setVisible.queued = false;
                    showTimeout = null;
                    if (!scope.visibleWatcher) {
                      onVisibleChanged(scope.visible);
                    }
                  }, scope.delay);
                } else {
                  $mdUtil.nextTick(function() {
                    scope.visible = false;
                    if (!scope.visibleWatcher)
                      onVisibleChanged(false);
                  });
                }
              }
            }
            function showTooltip() {
              if (!element[0].textContent.trim())
                return;
              element.css({
                top: 0,
                left: 0
              });
              tooltipParent.append(element);
              if ($mdUtil.hasComputedStyle(element, 'display', 'none')) {
                scope.visible = false;
                element.detach();
                return;
              }
              updatePosition();
              angular.forEach([element, content], function(element) {
                $animate.addClass(element, '_md-show');
              });
            }
            function hideTooltip() {
              var promises = [];
              angular.forEach([element, content], function(it) {
                if (it.parent() && it.hasClass('_md-show')) {
                  promises.push($animate.removeClass(it, '_md-show'));
                }
              });
              $q.all(promises).then(function() {
                if (!scope.visible)
                  element.detach();
              });
            }
            function updatePosition() {
              if (!scope.visible)
                return;
              updateContentOrigin();
              positionTooltip();
            }
            function positionTooltip() {
              var tipRect = $mdUtil.offsetRect(element, tooltipParent);
              var parentRect = $mdUtil.offsetRect(parent, tooltipParent);
              var newPosition = getPosition(scope.direction);
              var offsetParent = element.prop('offsetParent');
              if (scope.direction) {
                newPosition = fitInParent(newPosition);
              } else if (offsetParent && newPosition.top > offsetParent.scrollHeight - tipRect.height - TOOLTIP_WINDOW_EDGE_SPACE) {
                newPosition = fitInParent(getPosition('top'));
              }
              element.css({
                left: newPosition.left + 'px',
                top: newPosition.top + 'px'
              });
              function fitInParent(pos) {
                var newPosition = {
                  left: pos.left,
                  top: pos.top
                };
                newPosition.left = Math.min(newPosition.left, tooltipParent.prop('scrollWidth') - tipRect.width - TOOLTIP_WINDOW_EDGE_SPACE);
                newPosition.left = Math.max(newPosition.left, TOOLTIP_WINDOW_EDGE_SPACE);
                newPosition.top = Math.min(newPosition.top, tooltipParent.prop('scrollHeight') - tipRect.height - TOOLTIP_WINDOW_EDGE_SPACE);
                newPosition.top = Math.max(newPosition.top, TOOLTIP_WINDOW_EDGE_SPACE);
                return newPosition;
              }
              function getPosition(dir) {
                return dir === 'left' ? {
                  left: parentRect.left - tipRect.width - TOOLTIP_WINDOW_EDGE_SPACE,
                  top: parentRect.top + parentRect.height / 2 - tipRect.height / 2
                } : dir === 'right' ? {
                  left: parentRect.left + parentRect.width + TOOLTIP_WINDOW_EDGE_SPACE,
                  top: parentRect.top + parentRect.height / 2 - tipRect.height / 2
                } : dir === 'top' ? {
                  left: parentRect.left + parentRect.width / 2 - tipRect.width / 2,
                  top: parentRect.top - tipRect.height - TOOLTIP_WINDOW_EDGE_SPACE
                } : {
                  left: parentRect.left + parentRect.width / 2 - tipRect.width / 2,
                  top: parentRect.top + parentRect.height + TOOLTIP_WINDOW_EDGE_SPACE
                };
              }
            }
          }
        }
        MdTooltipDirective.$inject = ["$timeout", "$window", "$$rAF", "$document", "$mdUtil", "$mdTheming", "$rootElement", "$animate", "$q", "$interpolate"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.virtualRepeat', ['material.core', 'material.components.showHide']).directive('mdVirtualRepeatContainer', VirtualRepeatContainerDirective).directive('mdVirtualRepeat', VirtualRepeatDirective);
        function VirtualRepeatContainerDirective() {
          return {
            controller: VirtualRepeatContainerController,
            template: virtualRepeatContainerTemplate,
            compile: function virtualRepeatContainerCompile($element, $attrs) {
              $element.addClass('md-virtual-repeat-container').addClass($attrs.hasOwnProperty('mdOrientHorizontal') ? 'md-orient-horizontal' : 'md-orient-vertical');
            }
          };
        }
        function virtualRepeatContainerTemplate($element) {
          return '<div class="md-virtual-repeat-scroller">' + '<div class="md-virtual-repeat-sizer"></div>' + '<div class="md-virtual-repeat-offsetter">' + $element[0].innerHTML + '</div></div>';
        }
        var MAX_ELEMENT_SIZE = 1533917;
        var NUM_EXTRA = 3;
        function VirtualRepeatContainerController($$rAF, $mdUtil, $parse, $rootScope, $window, $scope, $element, $attrs) {
          this.$rootScope = $rootScope;
          this.$scope = $scope;
          this.$element = $element;
          this.$attrs = $attrs;
          this.size = 0;
          this.scrollSize = 0;
          this.scrollOffset = 0;
          this.horizontal = this.$attrs.hasOwnProperty('mdOrientHorizontal');
          this.repeater = null;
          this.autoShrink = this.$attrs.hasOwnProperty('mdAutoShrink');
          this.autoShrinkMin = parseInt(this.$attrs.mdAutoShrinkMin, 10) || 0;
          this.originalSize = null;
          this.offsetSize = parseInt(this.$attrs.mdOffsetSize, 10) || 0;
          this.oldElementSize = null;
          if (this.$attrs.mdTopIndex) {
            this.bindTopIndex = $parse(this.$attrs.mdTopIndex);
            this.topIndex = this.bindTopIndex(this.$scope);
            if (!angular.isDefined(this.topIndex)) {
              this.topIndex = 0;
              this.bindTopIndex.assign(this.$scope, 0);
            }
            this.$scope.$watch(this.bindTopIndex, angular.bind(this, function(newIndex) {
              if (newIndex !== this.topIndex) {
                this.scrollToIndex(newIndex);
              }
            }));
          } else {
            this.topIndex = 0;
          }
          this.scroller = $element[0].getElementsByClassName('md-virtual-repeat-scroller')[0];
          this.sizer = this.scroller.getElementsByClassName('md-virtual-repeat-sizer')[0];
          this.offsetter = this.scroller.getElementsByClassName('md-virtual-repeat-offsetter')[0];
          var boundUpdateSize = angular.bind(this, this.updateSize);
          $$rAF(angular.bind(this, function() {
            boundUpdateSize();
            var debouncedUpdateSize = $mdUtil.debounce(boundUpdateSize, 10, null, false);
            var jWindow = angular.element($window);
            if (!this.size) {
              debouncedUpdateSize();
            }
            jWindow.on('resize', debouncedUpdateSize);
            $scope.$on('$destroy', function() {
              jWindow.off('resize', debouncedUpdateSize);
            });
            $scope.$emit('$md-resize-enable');
            $scope.$on('$md-resize', boundUpdateSize);
          }));
        }
        VirtualRepeatContainerController.$inject = ["$$rAF", "$mdUtil", "$parse", "$rootScope", "$window", "$scope", "$element", "$attrs"];
        VirtualRepeatContainerController.prototype.register = function(repeaterCtrl) {
          this.repeater = repeaterCtrl;
          angular.element(this.scroller).on('scroll wheel touchmove touchend', angular.bind(this, this.handleScroll_));
        };
        VirtualRepeatContainerController.prototype.isHorizontal = function() {
          return this.horizontal;
        };
        VirtualRepeatContainerController.prototype.getSize = function() {
          return this.size;
        };
        VirtualRepeatContainerController.prototype.setSize_ = function(size) {
          var dimension = this.getDimensionName_();
          this.size = size;
          this.$element[0].style[dimension] = size + 'px';
        };
        VirtualRepeatContainerController.prototype.unsetSize_ = function() {
          this.$element[0].style[this.getDimensionName_()] = this.oldElementSize;
          this.oldElementSize = null;
        };
        VirtualRepeatContainerController.prototype.updateSize = function() {
          if (this.originalSize)
            return;
          this.size = this.isHorizontal() ? this.$element[0].clientWidth : this.$element[0].clientHeight;
          this.handleScroll_();
          this.repeater && this.repeater.containerUpdated();
        };
        VirtualRepeatContainerController.prototype.getScrollSize = function() {
          return this.scrollSize;
        };
        VirtualRepeatContainerController.prototype.getDimensionName_ = function() {
          return this.isHorizontal() ? 'width' : 'height';
        };
        VirtualRepeatContainerController.prototype.sizeScroller_ = function(size) {
          var dimension = this.getDimensionName_();
          var crossDimension = this.isHorizontal() ? 'height' : 'width';
          this.sizer.innerHTML = '';
          if (size < MAX_ELEMENT_SIZE) {
            this.sizer.style[dimension] = size + 'px';
          } else {
            this.sizer.style[dimension] = 'auto';
            this.sizer.style[crossDimension] = 'auto';
            var numChildren = Math.floor(size / MAX_ELEMENT_SIZE);
            var sizerChild = document.createElement('div');
            sizerChild.style[dimension] = MAX_ELEMENT_SIZE + 'px';
            sizerChild.style[crossDimension] = '1px';
            for (var i = 0; i < numChildren; i++) {
              this.sizer.appendChild(sizerChild.cloneNode(false));
            }
            sizerChild.style[dimension] = (size - (numChildren * MAX_ELEMENT_SIZE)) + 'px';
            this.sizer.appendChild(sizerChild);
          }
        };
        VirtualRepeatContainerController.prototype.autoShrink_ = function(size) {
          var shrinkSize = Math.max(size, this.autoShrinkMin * this.repeater.getItemSize());
          if (this.autoShrink && shrinkSize !== this.size) {
            if (this.oldElementSize === null) {
              this.oldElementSize = this.$element[0].style[this.getDimensionName_()];
            }
            var currentSize = this.originalSize || this.size;
            if (!currentSize || shrinkSize < currentSize) {
              if (!this.originalSize) {
                this.originalSize = this.size;
              }
              this.setSize_(shrinkSize);
            } else if (this.originalSize !== null) {
              this.unsetSize_();
              var _originalSize = this.originalSize;
              this.originalSize = null;
              if (!_originalSize)
                this.updateSize();
              this.setSize_(_originalSize || this.size);
            }
            this.repeater.containerUpdated();
          }
        };
        VirtualRepeatContainerController.prototype.setScrollSize = function(itemsSize) {
          var size = itemsSize + this.offsetSize;
          if (this.scrollSize === size)
            return;
          this.sizeScroller_(size);
          this.autoShrink_(size);
          this.scrollSize = size;
        };
        VirtualRepeatContainerController.prototype.getScrollOffset = function() {
          return this.scrollOffset;
        };
        VirtualRepeatContainerController.prototype.scrollTo = function(position) {
          this.scroller[this.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = position;
          this.handleScroll_();
        };
        VirtualRepeatContainerController.prototype.scrollToIndex = function(index) {
          var itemSize = this.repeater.getItemSize();
          var itemsLength = this.repeater.itemsLength;
          if (index > itemsLength) {
            index = itemsLength - 1;
          }
          this.scrollTo(itemSize * index);
        };
        VirtualRepeatContainerController.prototype.resetScroll = function() {
          this.scrollTo(0);
        };
        VirtualRepeatContainerController.prototype.handleScroll_ = function() {
          var doc = angular.element(document)[0];
          var ltr = doc.dir != 'rtl' && doc.body.dir != 'rtl';
          if (!ltr && !this.maxSize) {
            this.scroller.scrollLeft = this.scrollSize;
            this.maxSize = this.scroller.scrollLeft;
          }
          var offset = this.isHorizontal() ? (ltr ? this.scroller.scrollLeft : this.maxSize - this.scroller.scrollLeft) : this.scroller.scrollTop;
          if (offset === this.scrollOffset || offset > this.scrollSize - this.size)
            return;
          var itemSize = this.repeater.getItemSize();
          if (!itemSize)
            return;
          var numItems = Math.max(0, Math.floor(offset / itemSize) - NUM_EXTRA);
          var transform = (this.isHorizontal() ? 'translateX(' : 'translateY(') + (!this.isHorizontal() || ltr ? (numItems * itemSize) : -(numItems * itemSize)) + 'px)';
          this.scrollOffset = offset;
          this.offsetter.style.webkitTransform = transform;
          this.offsetter.style.transform = transform;
          if (this.bindTopIndex) {
            var topIndex = Math.floor(offset / itemSize);
            if (topIndex !== this.topIndex && topIndex < this.repeater.getItemCount()) {
              this.topIndex = topIndex;
              this.bindTopIndex.assign(this.$scope, topIndex);
              if (!this.$rootScope.$$phase)
                this.$scope.$digest();
            }
          }
          this.repeater.containerUpdated();
        };
        function VirtualRepeatDirective($parse) {
          return {
            controller: VirtualRepeatController,
            priority: 1000,
            require: ['mdVirtualRepeat', '^^mdVirtualRepeatContainer'],
            restrict: 'A',
            terminal: true,
            transclude: 'element',
            compile: function VirtualRepeatCompile($element, $attrs) {
              var expression = $attrs.mdVirtualRepeat;
              var match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)\s*$/);
              var repeatName = match[1];
              var repeatListExpression = $parse(match[2]);
              var extraName = $attrs.mdExtraName && $parse($attrs.mdExtraName);
              return function VirtualRepeatLink($scope, $element, $attrs, ctrl, $transclude) {
                ctrl[0].link_(ctrl[1], $transclude, repeatName, repeatListExpression, extraName);
              };
            }
          };
        }
        VirtualRepeatDirective.$inject = ["$parse"];
        function VirtualRepeatController($scope, $element, $attrs, $browser, $document, $rootScope, $$rAF, $mdUtil) {
          this.$scope = $scope;
          this.$element = $element;
          this.$attrs = $attrs;
          this.$browser = $browser;
          this.$document = $document;
          this.$rootScope = $rootScope;
          this.$$rAF = $$rAF;
          this.onDemand = $mdUtil.parseAttributeBoolean($attrs.mdOnDemand);
          this.browserCheckUrlChange = $browser.$$checkUrlChange;
          this.newStartIndex = 0;
          this.newEndIndex = 0;
          this.newVisibleEnd = 0;
          this.startIndex = 0;
          this.endIndex = 0;
          this.itemSize = $scope.$eval($attrs.mdItemSize) || null;
          this.isFirstRender = true;
          this.isVirtualRepeatUpdating_ = false;
          this.itemsLength = 0;
          this.unwatchItemSize_ = angular.noop;
          this.blocks = {};
          this.pooledBlocks = [];
          $scope.$on('$destroy', angular.bind(this, this.cleanupBlocks_));
        }
        VirtualRepeatController.$inject = ["$scope", "$element", "$attrs", "$browser", "$document", "$rootScope", "$$rAF", "$mdUtil"];
        VirtualRepeatController.Block;
        VirtualRepeatController.prototype.link_ = function(container, transclude, repeatName, repeatListExpression, extraName) {
          this.container = container;
          this.transclude = transclude;
          this.repeatName = repeatName;
          this.rawRepeatListExpression = repeatListExpression;
          this.extraName = extraName;
          this.sized = false;
          this.repeatListExpression = angular.bind(this, this.repeatListExpression_);
          this.container.register(this);
        };
        VirtualRepeatController.prototype.cleanupBlocks_ = function() {
          angular.forEach(this.pooledBlocks, function cleanupBlock(block) {
            block.element.remove();
          });
        };
        VirtualRepeatController.prototype.readItemSize_ = function() {
          if (this.itemSize) {
            return;
          }
          this.items = this.repeatListExpression(this.$scope);
          this.parentNode = this.$element[0].parentNode;
          var block = this.getBlock_(0);
          if (!block.element[0].parentNode) {
            this.parentNode.appendChild(block.element[0]);
          }
          this.itemSize = block.element[0][this.container.isHorizontal() ? 'offsetWidth' : 'offsetHeight'] || null;
          this.blocks[0] = block;
          this.poolBlock_(0);
          if (this.itemSize) {
            this.containerUpdated();
          }
        };
        VirtualRepeatController.prototype.repeatListExpression_ = function(scope) {
          var repeatList = this.rawRepeatListExpression(scope);
          if (this.onDemand && repeatList) {
            var virtualList = new VirtualRepeatModelArrayLike(repeatList);
            virtualList.$$includeIndexes(this.newStartIndex, this.newVisibleEnd);
            return virtualList;
          } else {
            return repeatList;
          }
        };
        VirtualRepeatController.prototype.containerUpdated = function() {
          if (!this.itemSize) {
            if (this.unwatchItemSize_ && this.unwatchItemSize_ !== angular.noop) {
              this.unwatchItemSize_();
            }
            this.unwatchItemSize_ = this.$scope.$watchCollection(this.repeatListExpression, angular.bind(this, function(items) {
              if (items && items.length) {
                this.$$rAF(angular.bind(this, this.readItemSize_));
              }
            }));
            if (!this.$rootScope.$$phase)
              this.$scope.$digest();
            return;
          } else if (!this.sized) {
            this.items = this.repeatListExpression(this.$scope);
          }
          if (!this.sized) {
            this.unwatchItemSize_();
            this.sized = true;
            this.$scope.$watchCollection(this.repeatListExpression, angular.bind(this, function(items, oldItems) {
              if (!this.isVirtualRepeatUpdating_) {
                this.virtualRepeatUpdate_(items, oldItems);
              }
            }));
          }
          this.updateIndexes_();
          if (this.newStartIndex !== this.startIndex || this.newEndIndex !== this.endIndex || this.container.getScrollOffset() > this.container.getScrollSize()) {
            if (this.items instanceof VirtualRepeatModelArrayLike) {
              this.items.$$includeIndexes(this.newStartIndex, this.newEndIndex);
            }
            this.virtualRepeatUpdate_(this.items, this.items);
          }
        };
        VirtualRepeatController.prototype.getItemSize = function() {
          return this.itemSize;
        };
        VirtualRepeatController.prototype.getItemCount = function() {
          return this.itemsLength;
        };
        VirtualRepeatController.prototype.virtualRepeatUpdate_ = function(items, oldItems) {
          this.isVirtualRepeatUpdating_ = true;
          var itemsLength = items && items.length || 0;
          var lengthChanged = false;
          if (this.items && itemsLength < this.items.length && this.container.getScrollOffset() !== 0) {
            this.items = items;
            var previousScrollOffset = this.container.getScrollOffset();
            this.container.resetScroll();
            this.container.scrollTo(previousScrollOffset);
            return;
          }
          if (itemsLength !== this.itemsLength) {
            lengthChanged = true;
            this.itemsLength = itemsLength;
          }
          this.items = items;
          if (items !== oldItems || lengthChanged) {
            this.updateIndexes_();
          }
          this.parentNode = this.$element[0].parentNode;
          if (lengthChanged) {
            this.container.setScrollSize(itemsLength * this.itemSize);
          }
          if (this.isFirstRender) {
            this.isFirstRender = false;
            var startIndex = this.$attrs.mdStartIndex ? this.$scope.$eval(this.$attrs.mdStartIndex) : this.container.topIndex;
            this.container.scrollToIndex(startIndex);
          }
          Object.keys(this.blocks).forEach(function(blockIndex) {
            var index = parseInt(blockIndex, 10);
            if (index < this.newStartIndex || index >= this.newEndIndex) {
              this.poolBlock_(index);
            }
          }, this);
          this.$browser.$$checkUrlChange = angular.noop;
          var i,
              block,
              newStartBlocks = [],
              newEndBlocks = [];
          for (i = this.newStartIndex; i < this.newEndIndex && this.blocks[i] == null; i++) {
            block = this.getBlock_(i);
            this.updateBlock_(block, i);
            newStartBlocks.push(block);
          }
          for (; this.blocks[i] != null; i++) {
            this.updateBlock_(this.blocks[i], i);
          }
          var maxIndex = i - 1;
          for (; i < this.newEndIndex; i++) {
            block = this.getBlock_(i);
            this.updateBlock_(block, i);
            newEndBlocks.push(block);
          }
          if (newStartBlocks.length) {
            this.parentNode.insertBefore(this.domFragmentFromBlocks_(newStartBlocks), this.$element[0].nextSibling);
          }
          if (newEndBlocks.length) {
            this.parentNode.insertBefore(this.domFragmentFromBlocks_(newEndBlocks), this.blocks[maxIndex] && this.blocks[maxIndex].element[0].nextSibling);
          }
          this.$browser.$$checkUrlChange = this.browserCheckUrlChange;
          this.startIndex = this.newStartIndex;
          this.endIndex = this.newEndIndex;
          this.isVirtualRepeatUpdating_ = false;
        };
        VirtualRepeatController.prototype.getBlock_ = function(index) {
          if (this.pooledBlocks.length) {
            return this.pooledBlocks.pop();
          }
          var block;
          this.transclude(angular.bind(this, function(clone, scope) {
            block = {
              element: clone,
              new: true,
              scope: scope
            };
            this.updateScope_(scope, index);
            this.parentNode.appendChild(clone[0]);
          }));
          return block;
        };
        VirtualRepeatController.prototype.updateBlock_ = function(block, index) {
          this.blocks[index] = block;
          if (!block.new && (block.scope.$index === index && block.scope[this.repeatName] === this.items[index])) {
            return;
          }
          block.new = false;
          this.updateScope_(block.scope, index);
          if (!this.$rootScope.$$phase) {
            block.scope.$digest();
          }
        };
        VirtualRepeatController.prototype.updateScope_ = function(scope, index) {
          scope.$index = index;
          scope[this.repeatName] = this.items && this.items[index];
          if (this.extraName)
            scope[this.extraName(this.$scope)] = this.items[index];
        };
        VirtualRepeatController.prototype.poolBlock_ = function(index) {
          this.pooledBlocks.push(this.blocks[index]);
          this.parentNode.removeChild(this.blocks[index].element[0]);
          delete this.blocks[index];
        };
        VirtualRepeatController.prototype.domFragmentFromBlocks_ = function(blocks) {
          var fragment = this.$document[0].createDocumentFragment();
          blocks.forEach(function(block) {
            fragment.appendChild(block.element[0]);
          });
          return fragment;
        };
        VirtualRepeatController.prototype.updateIndexes_ = function() {
          var itemsLength = this.items ? this.items.length : 0;
          var containerLength = Math.ceil(this.container.getSize() / this.itemSize);
          this.newStartIndex = Math.max(0, Math.min(itemsLength - containerLength, Math.floor(this.container.getScrollOffset() / this.itemSize)));
          this.newVisibleEnd = this.newStartIndex + containerLength + NUM_EXTRA;
          this.newEndIndex = Math.min(itemsLength, this.newVisibleEnd);
          this.newStartIndex = Math.max(0, this.newStartIndex - NUM_EXTRA);
        };
        function VirtualRepeatModelArrayLike(model) {
          if (!angular.isFunction(model.getItemAtIndex) || !angular.isFunction(model.getLength)) {
            throw Error('When md-on-demand is enabled, the Object passed to md-virtual-repeat must implement ' + 'functions getItemAtIndex() and getLength() ');
          }
          this.model = model;
        }
        VirtualRepeatModelArrayLike.prototype.$$includeIndexes = function(start, end) {
          for (var i = start; i < end; i++) {
            if (!this.hasOwnProperty(i)) {
              this[i] = this.model.getItemAtIndex(i);
            }
          }
          this.length = this.model.getLength();
        };
        function abstractMethod() {
          throw Error('Non-overridden abstract method called.');
        }
      })();
      (function() {
        "use strict";
        angular.module('material.components.whiteframe', ['material.core']).directive('mdWhiteframe', MdWhiteframeDirective);
        function MdWhiteframeDirective($log) {
          var DISABLE_DP = -1;
          var MIN_DP = 1;
          var MAX_DP = 24;
          var DEFAULT_DP = 4;
          return {link: postLink};
          function postLink(scope, element, attr) {
            var oldClass = '';
            attr.$observe('mdWhiteframe', function(elevation) {
              elevation = parseInt(elevation, 10) || DEFAULT_DP;
              if (elevation != DISABLE_DP && (elevation > MAX_DP || elevation < MIN_DP)) {
                $log.warn('md-whiteframe attribute value is invalid. It should be a number between ' + MIN_DP + ' and ' + MAX_DP, element[0]);
                elevation = DEFAULT_DP;
              }
              var newClass = elevation == DISABLE_DP ? '' : 'md-whiteframe-' + elevation + 'dp';
              attr.$updateClass(newClass, oldClass);
              oldClass = newClass;
            });
          }
        }
        MdWhiteframeDirective.$inject = ["$log"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.autocomplete').controller('MdAutocompleteCtrl', MdAutocompleteCtrl);
        var ITEM_HEIGHT = 41,
            MAX_HEIGHT = 5.5 * ITEM_HEIGHT,
            MENU_PADDING = 8,
            INPUT_PADDING = 2;
        function MdAutocompleteCtrl($scope, $element, $mdUtil, $mdConstant, $mdTheming, $window, $animate, $rootElement, $attrs, $q) {
          var ctrl = this,
              itemParts = $scope.itemsExpr.split(/ in /i),
              itemExpr = itemParts[1],
              elements = null,
              cache = {},
              noBlur = false,
              selectedItemWatchers = [],
              hasFocus = false,
              lastCount = 0,
              fetchesInProgress = 0,
              enableWrapScroll = null;
          defineProperty('hidden', handleHiddenChange, true);
          ctrl.scope = $scope;
          ctrl.parent = $scope.$parent;
          ctrl.itemName = itemParts[0];
          ctrl.matches = [];
          ctrl.loading = false;
          ctrl.hidden = true;
          ctrl.index = null;
          ctrl.messages = [];
          ctrl.id = $mdUtil.nextUid();
          ctrl.isDisabled = null;
          ctrl.isRequired = null;
          ctrl.isReadonly = null;
          ctrl.hasNotFound = false;
          ctrl.keydown = keydown;
          ctrl.blur = blur;
          ctrl.focus = focus;
          ctrl.clear = clearValue;
          ctrl.select = select;
          ctrl.listEnter = onListEnter;
          ctrl.listLeave = onListLeave;
          ctrl.mouseUp = onMouseup;
          ctrl.getCurrentDisplayValue = getCurrentDisplayValue;
          ctrl.registerSelectedItemWatcher = registerSelectedItemWatcher;
          ctrl.unregisterSelectedItemWatcher = unregisterSelectedItemWatcher;
          ctrl.notFoundVisible = notFoundVisible;
          ctrl.loadingIsVisible = loadingIsVisible;
          return init();
          function init() {
            $mdUtil.initOptionalProperties($scope, $attrs, {
              searchText: '',
              selectedItem: null
            });
            $mdTheming($element);
            configureWatchers();
            $mdUtil.nextTick(function() {
              gatherElements();
              moveDropdown();
              focusElement();
              $element.on('focus', focusElement);
            });
          }
          function positionDropdown() {
            if (!elements)
              return $mdUtil.nextTick(positionDropdown, false, $scope);
            var hrect = elements.wrap.getBoundingClientRect(),
                vrect = elements.snap.getBoundingClientRect(),
                root = elements.root.getBoundingClientRect(),
                top = vrect.bottom - root.top,
                bot = root.bottom - vrect.top,
                left = hrect.left - root.left,
                width = hrect.width,
                offset = getVerticalOffset(),
                styles;
            if ($attrs.mdFloatingLabel) {
              left += INPUT_PADDING;
              width -= INPUT_PADDING * 2;
            }
            styles = {
              left: left + 'px',
              minWidth: width + 'px',
              maxWidth: Math.max(hrect.right - root.left, root.right - hrect.left) - MENU_PADDING + 'px'
            };
            if (top > bot && root.height - hrect.bottom - MENU_PADDING < MAX_HEIGHT) {
              styles.top = 'auto';
              styles.bottom = bot + 'px';
              styles.maxHeight = Math.min(MAX_HEIGHT, hrect.top - root.top - MENU_PADDING) + 'px';
            } else {
              styles.top = (top - offset) + 'px';
              styles.bottom = 'auto';
              styles.maxHeight = Math.min(MAX_HEIGHT, root.bottom + $mdUtil.scrollTop() - hrect.bottom - MENU_PADDING) + 'px';
            }
            elements.$.scrollContainer.css(styles);
            $mdUtil.nextTick(correctHorizontalAlignment, false);
            function getVerticalOffset() {
              var offset = 0;
              var inputContainer = $element.find('md-input-container');
              if (inputContainer.length) {
                var input = inputContainer.find('input');
                offset = inputContainer.prop('offsetHeight');
                offset -= input.prop('offsetTop');
                offset -= input.prop('offsetHeight');
                offset += inputContainer.prop('offsetTop');
              }
              return offset;
            }
            function correctHorizontalAlignment() {
              var dropdown = elements.scrollContainer.getBoundingClientRect(),
                  styles = {};
              if (dropdown.right > root.right - MENU_PADDING) {
                styles.left = (hrect.right - dropdown.width) + 'px';
              }
              elements.$.scrollContainer.css(styles);
            }
          }
          function moveDropdown() {
            if (!elements.$.root.length)
              return;
            $mdTheming(elements.$.scrollContainer);
            elements.$.scrollContainer.detach();
            elements.$.root.append(elements.$.scrollContainer);
            if ($animate.pin)
              $animate.pin(elements.$.scrollContainer, $rootElement);
          }
          function focusElement() {
            if ($scope.autofocus)
              elements.input.focus();
          }
          function configureWatchers() {
            var wait = parseInt($scope.delay, 10) || 0;
            $attrs.$observe('disabled', function(value) {
              ctrl.isDisabled = $mdUtil.parseAttributeBoolean(value, false);
            });
            $attrs.$observe('required', function(value) {
              ctrl.isRequired = $mdUtil.parseAttributeBoolean(value, false);
            });
            $attrs.$observe('readonly', function(value) {
              ctrl.isReadonly = $mdUtil.parseAttributeBoolean(value, false);
            });
            $scope.$watch('searchText', wait ? $mdUtil.debounce(handleSearchText, wait) : handleSearchText);
            $scope.$watch('selectedItem', selectedItemChange);
            angular.element($window).on('resize', positionDropdown);
            $scope.$on('$destroy', cleanup);
          }
          function cleanup() {
            if (!ctrl.hidden) {
              $mdUtil.enableScrolling();
            }
            angular.element($window).off('resize', positionDropdown);
            if (elements) {
              var items = 'ul scroller scrollContainer input'.split(' ');
              angular.forEach(items, function(key) {
                elements.$[key].remove();
              });
            }
          }
          function gatherElements() {
            elements = {
              main: $element[0],
              scrollContainer: $element[0].getElementsByClassName('md-virtual-repeat-container')[0],
              scroller: $element[0].getElementsByClassName('md-virtual-repeat-scroller')[0],
              ul: $element.find('ul')[0],
              input: $element.find('input')[0],
              wrap: $element.find('md-autocomplete-wrap')[0],
              root: document.body
            };
            elements.li = elements.ul.getElementsByTagName('li');
            elements.snap = getSnapTarget();
            elements.$ = getAngularElements(elements);
          }
          function getSnapTarget() {
            for (var element = $element; element.length; element = element.parent()) {
              if (angular.isDefined(element.attr('md-autocomplete-snap')))
                return element[0];
            }
            return elements.wrap;
          }
          function getAngularElements(elements) {
            var obj = {};
            for (var key in elements) {
              if (elements.hasOwnProperty(key))
                obj[key] = angular.element(elements[key]);
            }
            return obj;
          }
          function handleHiddenChange(hidden, oldHidden) {
            if (!hidden && oldHidden) {
              positionDropdown();
              if (elements) {
                $mdUtil.nextTick(function() {
                  $mdUtil.disableScrollAround(elements.ul);
                  enableWrapScroll = disableElementScrollEvents(angular.element(elements.wrap));
                }, false, $scope);
              }
            } else if (hidden && !oldHidden) {
              $mdUtil.nextTick(function() {
                $mdUtil.enableScrolling();
                if (enableWrapScroll) {
                  enableWrapScroll();
                  enableWrapScroll = null;
                }
              }, false, $scope);
            }
          }
          function disableElementScrollEvents(element) {
            function preventDefault(e) {
              e.preventDefault();
            }
            element.on('wheel', preventDefault);
            element.on('touchmove', preventDefault);
            return function() {
              element.off('wheel', preventDefault);
              element.off('touchmove', preventDefault);
            };
          }
          function onListEnter() {
            noBlur = true;
          }
          function onListLeave() {
            if (!hasFocus && !ctrl.hidden)
              elements.input.focus();
            noBlur = false;
            ctrl.hidden = shouldHide();
          }
          function onMouseup() {
            elements.input.focus();
          }
          function selectedItemChange(selectedItem, previousSelectedItem) {
            if (selectedItem) {
              getDisplayValue(selectedItem).then(function(val) {
                $scope.searchText = val;
                handleSelectedItemChange(selectedItem, previousSelectedItem);
              });
            }
            if (selectedItem !== previousSelectedItem)
              announceItemChange();
          }
          function announceItemChange() {
            angular.isFunction($scope.itemChange) && $scope.itemChange(getItemAsNameVal($scope.selectedItem));
          }
          function announceTextChange() {
            angular.isFunction($scope.textChange) && $scope.textChange();
          }
          function handleSelectedItemChange(selectedItem, previousSelectedItem) {
            selectedItemWatchers.forEach(function(watcher) {
              watcher(selectedItem, previousSelectedItem);
            });
          }
          function registerSelectedItemWatcher(cb) {
            if (selectedItemWatchers.indexOf(cb) == -1) {
              selectedItemWatchers.push(cb);
            }
          }
          function unregisterSelectedItemWatcher(cb) {
            var i = selectedItemWatchers.indexOf(cb);
            if (i != -1) {
              selectedItemWatchers.splice(i, 1);
            }
          }
          function handleSearchText(searchText, previousSearchText) {
            ctrl.index = getDefaultIndex();
            if (searchText === previousSearchText)
              return;
            getDisplayValue($scope.selectedItem).then(function(val) {
              if (searchText !== val) {
                $scope.selectedItem = null;
                if (searchText !== previousSearchText)
                  announceTextChange();
                if (!isMinLengthMet()) {
                  ctrl.matches = [];
                  setLoading(false);
                  updateMessages();
                } else {
                  handleQuery();
                }
              }
            });
          }
          function blur() {
            hasFocus = false;
            if (!noBlur) {
              ctrl.hidden = shouldHide();
            }
          }
          function doBlur(forceBlur) {
            if (forceBlur) {
              noBlur = false;
              hasFocus = false;
            }
            elements.input.blur();
          }
          function focus($event) {
            hasFocus = true;
            if (!angular.isString($scope.searchText))
              $scope.searchText = '';
            ctrl.hidden = shouldHide();
            if (!ctrl.hidden)
              handleQuery();
          }
          function keydown(event) {
            switch (event.keyCode) {
              case $mdConstant.KEY_CODE.DOWN_ARROW:
                if (ctrl.loading)
                  return;
                event.stopPropagation();
                event.preventDefault();
                ctrl.index = Math.min(ctrl.index + 1, ctrl.matches.length - 1);
                updateScroll();
                updateMessages();
                break;
              case $mdConstant.KEY_CODE.UP_ARROW:
                if (ctrl.loading)
                  return;
                event.stopPropagation();
                event.preventDefault();
                ctrl.index = ctrl.index < 0 ? ctrl.matches.length - 1 : Math.max(0, ctrl.index - 1);
                updateScroll();
                updateMessages();
                break;
              case $mdConstant.KEY_CODE.TAB:
                onListLeave();
                if (ctrl.hidden || ctrl.loading || ctrl.index < 0 || ctrl.matches.length < 1)
                  return;
                select(ctrl.index);
                break;
              case $mdConstant.KEY_CODE.ENTER:
                if (ctrl.hidden || ctrl.loading || ctrl.index < 0 || ctrl.matches.length < 1)
                  return;
                if (hasSelection())
                  return;
                event.stopPropagation();
                event.preventDefault();
                select(ctrl.index);
                break;
              case $mdConstant.KEY_CODE.ESCAPE:
                if (!shouldProcessEscape())
                  return;
                event.stopPropagation();
                event.preventDefault();
                clearSelectedItem();
                if ($scope.searchText && hasEscapeOption('clear')) {
                  clearSearchText();
                }
                if (hasEscapeOption('blur')) {
                  doBlur(true);
                } else {
                  ctrl.hidden = true;
                }
                break;
              default:
            }
          }
          function getMinLength() {
            return angular.isNumber($scope.minLength) ? $scope.minLength : 1;
          }
          function getDisplayValue(item) {
            return $q.when(getItemText(item) || item);
            function getItemText(item) {
              return (item && $scope.itemText) ? $scope.itemText(getItemAsNameVal(item)) : null;
            }
          }
          function getItemAsNameVal(item) {
            if (!item)
              return undefined;
            var locals = {};
            if (ctrl.itemName)
              locals[ctrl.itemName] = item;
            return locals;
          }
          function getDefaultIndex() {
            return $scope.autoselect ? 0 : -1;
          }
          function setLoading(value) {
            if (ctrl.loading != value) {
              ctrl.loading = value;
            }
            ctrl.hidden = shouldHide();
          }
          function shouldHide() {
            if (ctrl.loading && !hasMatches())
              return true;
            else if (hasSelection())
              return true;
            else if (!hasFocus)
              return true;
            else
              return !shouldShow();
          }
          function shouldProcessEscape() {
            return hasEscapeOption('blur') || !ctrl.hidden || ctrl.loading || hasEscapeOption('clear') && $scope.searchText;
          }
          function hasEscapeOption(option) {
            return !$scope.escapeOptions || $scope.escapeOptions.toLowerCase().indexOf(option) !== -1;
          }
          function shouldShow() {
            return (isMinLengthMet() && hasMatches()) || notFoundVisible();
          }
          function hasMatches() {
            return ctrl.matches.length ? true : false;
          }
          function hasSelection() {
            return ctrl.scope.selectedItem ? true : false;
          }
          function loadingIsVisible() {
            return ctrl.loading && !hasSelection();
          }
          function getCurrentDisplayValue() {
            return getDisplayValue(ctrl.matches[ctrl.index]);
          }
          function isMinLengthMet() {
            return ($scope.searchText || '').length >= getMinLength();
          }
          function defineProperty(key, handler, value) {
            Object.defineProperty(ctrl, key, {
              get: function() {
                return value;
              },
              set: function(newValue) {
                var oldValue = value;
                value = newValue;
                handler(newValue, oldValue);
              }
            });
          }
          function select(index) {
            $mdUtil.nextTick(function() {
              getDisplayValue(ctrl.matches[index]).then(function(val) {
                var ngModel = elements.$.input.controller('ngModel');
                ngModel.$setViewValue(val);
                ngModel.$render();
              }).finally(function() {
                $scope.selectedItem = ctrl.matches[index];
                setLoading(false);
              });
            }, false);
          }
          function clearValue() {
            clearSelectedItem();
            clearSearchText();
          }
          function clearSelectedItem() {
            ctrl.index = 0;
            ctrl.matches = [];
          }
          function clearSearchText() {
            setLoading(true);
            $scope.searchText = '';
            var eventObj = document.createEvent('CustomEvent');
            eventObj.initCustomEvent('input', true, true, {value: ''});
            elements.input.dispatchEvent(eventObj);
            elements.input.blur();
            $scope.searchText = '';
            elements.input.focus();
          }
          function fetchResults(searchText) {
            var items = $scope.$parent.$eval(itemExpr),
                term = searchText.toLowerCase(),
                isList = angular.isArray(items),
                isPromise = !!items.then;
            if (isList)
              handleResults(items);
            else if (isPromise)
              handleAsyncResults(items);
            function handleAsyncResults(items) {
              if (!items)
                return;
              items = $q.when(items);
              fetchesInProgress++;
              setLoading(true);
              $mdUtil.nextTick(function() {
                items.then(handleResults).finally(function() {
                  if (--fetchesInProgress === 0) {
                    setLoading(false);
                  }
                });
              }, true, $scope);
            }
            function handleResults(matches) {
              cache[term] = matches;
              if ((searchText || '') !== ($scope.searchText || ''))
                return;
              ctrl.matches = matches;
              ctrl.hidden = shouldHide();
              if (ctrl.loading)
                setLoading(false);
              if ($scope.selectOnMatch)
                selectItemOnMatch();
              updateMessages();
              positionDropdown();
            }
          }
          function updateMessages() {
            getCurrentDisplayValue().then(function(msg) {
              ctrl.messages = [getCountMessage(), msg];
            });
          }
          function getCountMessage() {
            if (lastCount === ctrl.matches.length)
              return '';
            lastCount = ctrl.matches.length;
            switch (ctrl.matches.length) {
              case 0:
                return 'There are no matches available.';
              case 1:
                return 'There is 1 match available.';
              default:
                return 'There are ' + ctrl.matches.length + ' matches available.';
            }
          }
          function updateScroll() {
            if (!elements.li[0])
              return;
            var height = elements.li[0].offsetHeight,
                top = height * ctrl.index,
                bot = top + height,
                hgt = elements.scroller.clientHeight,
                scrollTop = elements.scroller.scrollTop;
            if (top < scrollTop) {
              scrollTo(top);
            } else if (bot > scrollTop + hgt) {
              scrollTo(bot - hgt);
            }
          }
          function isPromiseFetching() {
            return fetchesInProgress !== 0;
          }
          function scrollTo(offset) {
            elements.$.scrollContainer.controller('mdVirtualRepeatContainer').scrollTo(offset);
          }
          function notFoundVisible() {
            var textLength = (ctrl.scope.searchText || '').length;
            return ctrl.hasNotFound && !hasMatches() && (!ctrl.loading || isPromiseFetching()) && textLength >= getMinLength() && (hasFocus || noBlur) && !hasSelection();
          }
          function handleQuery() {
            var searchText = $scope.searchText || '',
                term = searchText.toLowerCase();
            if (!$scope.noCache && cache[term]) {
              ctrl.matches = cache[term];
              updateMessages();
              setLoading(false);
            } else {
              fetchResults(searchText);
            }
            ctrl.hidden = shouldHide();
          }
          function selectItemOnMatch() {
            var searchText = $scope.searchText,
                matches = ctrl.matches,
                item = matches[0];
            if (matches.length === 1)
              getDisplayValue(item).then(function(displayValue) {
                var isMatching = searchText == displayValue;
                if ($scope.matchInsensitive && !isMatching) {
                  isMatching = searchText.toLowerCase() == displayValue.toLowerCase();
                }
                if (isMatching)
                  select(0);
              });
          }
        }
        MdAutocompleteCtrl.$inject = ["$scope", "$element", "$mdUtil", "$mdConstant", "$mdTheming", "$window", "$animate", "$rootElement", "$attrs", "$q"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.autocomplete').directive('mdAutocomplete', MdAutocomplete);
        function MdAutocomplete($$mdSvgRegistry) {
          return {
            controller: 'MdAutocompleteCtrl',
            controllerAs: '$mdAutocompleteCtrl',
            scope: {
              inputName: '@mdInputName',
              inputMinlength: '@mdInputMinlength',
              inputMaxlength: '@mdInputMaxlength',
              searchText: '=?mdSearchText',
              selectedItem: '=?mdSelectedItem',
              itemsExpr: '@mdItems',
              itemText: '&mdItemText',
              placeholder: '@placeholder',
              noCache: '=?mdNoCache',
              selectOnMatch: '=?mdSelectOnMatch',
              matchInsensitive: '=?mdMatchCaseInsensitive',
              itemChange: '&?mdSelectedItemChange',
              textChange: '&?mdSearchTextChange',
              minLength: '=?mdMinLength',
              delay: '=?mdDelay',
              autofocus: '=?mdAutofocus',
              floatingLabel: '@?mdFloatingLabel',
              autoselect: '=?mdAutoselect',
              menuClass: '@?mdMenuClass',
              inputId: '@?mdInputId',
              escapeOptions: '@?mdEscapeOptions'
            },
            link: function(scope, element, attrs, controller) {
              controller.hasNotFound = !!element.attr('md-has-not-found');
            },
            template: function(element, attr) {
              var noItemsTemplate = getNoItemsTemplate(),
                  itemTemplate = getItemTemplate(),
                  leftover = element.html(),
                  tabindex = attr.tabindex;
              if (noItemsTemplate)
                element.attr('md-has-not-found', true);
              element.attr('tabindex', '-1');
              return '\
        <md-autocomplete-wrap\
            layout="row"\
            ng-class="{ \'md-whiteframe-z1\': !floatingLabel, \'md-menu-showing\': !$mdAutocompleteCtrl.hidden }">\
          ' + getInputElement() + '\
          <md-progress-linear\
              class="' + (attr.mdFloatingLabel ? 'md-inline' : '') + '"\
              ng-if="$mdAutocompleteCtrl.loadingIsVisible()"\
              md-mode="indeterminate"></md-progress-linear>\
          <md-virtual-repeat-container\
              md-auto-shrink\
              md-auto-shrink-min="1"\
              ng-mouseenter="$mdAutocompleteCtrl.listEnter()"\
              ng-mouseleave="$mdAutocompleteCtrl.listLeave()"\
              ng-mouseup="$mdAutocompleteCtrl.mouseUp()"\
              ng-hide="$mdAutocompleteCtrl.hidden"\
              class="md-autocomplete-suggestions-container md-whiteframe-z1"\
              ng-class="{ \'md-not-found\': $mdAutocompleteCtrl.notFoundVisible() }"\
              role="presentation">\
            <ul class="md-autocomplete-suggestions"\
                ng-class="::menuClass"\
                id="ul-{{$mdAutocompleteCtrl.id}}">\
              <li md-virtual-repeat="item in $mdAutocompleteCtrl.matches"\
                  ng-class="{ selected: $index === $mdAutocompleteCtrl.index }"\
                  ng-click="$mdAutocompleteCtrl.select($index)"\
                  md-extra-name="$mdAutocompleteCtrl.itemName">\
                  ' + itemTemplate + '\
                  </li>' + noItemsTemplate + '\
            </ul>\
          </md-virtual-repeat-container>\
        </md-autocomplete-wrap>\
        <aria-status\
            class="_md-visually-hidden"\
            role="status"\
            aria-live="assertive">\
          <p ng-repeat="message in $mdAutocompleteCtrl.messages track by $index" ng-if="message">{{message}}</p>\
        </aria-status>';
              function getItemTemplate() {
                var templateTag = element.find('md-item-template').detach(),
                    html = templateTag.length ? templateTag.html() : element.html();
                if (!templateTag.length)
                  element.empty();
                return '<md-autocomplete-parent-scope md-autocomplete-replace>' + html + '</md-autocomplete-parent-scope>';
              }
              function getNoItemsTemplate() {
                var templateTag = element.find('md-not-found').detach(),
                    template = templateTag.length ? templateTag.html() : '';
                return template ? '<li ng-if="$mdAutocompleteCtrl.notFoundVisible()"\
                         md-autocomplete-parent-scope>' + template + '</li>' : '';
              }
              function getInputElement() {
                if (attr.mdFloatingLabel) {
                  return '\
            <md-input-container flex ng-if="floatingLabel">\
              <label>{{floatingLabel}}</label>\
              <input type="search"\
                  ' + (tabindex != null ? 'tabindex="' + tabindex + '"' : '') + '\
                  id="{{ inputId || \'fl-input-\' + $mdAutocompleteCtrl.id }}"\
                  name="{{inputName}}"\
                  autocomplete="off"\
                  ng-required="$mdAutocompleteCtrl.isRequired"\
                  ng-readonly="$mdAutocompleteCtrl.isReadonly"\
                  ng-minlength="inputMinlength"\
                  ng-maxlength="inputMaxlength"\
                  ng-disabled="$mdAutocompleteCtrl.isDisabled"\
                  ng-model="$mdAutocompleteCtrl.scope.searchText"\
                  ng-keydown="$mdAutocompleteCtrl.keydown($event)"\
                  ng-blur="$mdAutocompleteCtrl.blur()"\
                  ' + (attr.mdNoAsterisk != null ? 'md-no-asterisk="' + attr.mdNoAsterisk + '"' : '') + '\
                  ng-focus="$mdAutocompleteCtrl.focus($event)"\
                  aria-owns="ul-{{$mdAutocompleteCtrl.id}}"\
                  ' + (attr.mdSelectOnFocus != null ? 'md-select-on-focus=""' : '') + '\
                  aria-label="{{floatingLabel}}"\
                  aria-autocomplete="list"\
                  role="combobox"\
                  aria-haspopup="true"\
                  aria-activedescendant=""\
                  aria-expanded="{{!$mdAutocompleteCtrl.hidden}}"/>\
              <div md-autocomplete-parent-scope md-autocomplete-replace>' + leftover + '</div>\
            </md-input-container>';
                } else {
                  return '\
            <input flex type="search"\
                ' + (tabindex != null ? 'tabindex="' + tabindex + '"' : '') + '\
                id="{{ inputId || \'input-\' + $mdAutocompleteCtrl.id }}"\
                name="{{inputName}}"\
                ng-if="!floatingLabel"\
                autocomplete="off"\
                ng-required="$mdAutocompleteCtrl.isRequired"\
                ng-disabled="$mdAutocompleteCtrl.isDisabled"\
                ng-readonly="$mdAutocompleteCtrl.isReadonly"\
                ng-model="$mdAutocompleteCtrl.scope.searchText"\
                ng-keydown="$mdAutocompleteCtrl.keydown($event)"\
                ng-blur="$mdAutocompleteCtrl.blur()"\
                ng-focus="$mdAutocompleteCtrl.focus($event)"\
                placeholder="{{placeholder}}"\
                aria-owns="ul-{{$mdAutocompleteCtrl.id}}"\
                ' + (attr.mdSelectOnFocus != null ? 'md-select-on-focus=""' : '') + '\
                aria-label="{{placeholder}}"\
                aria-autocomplete="list"\
                role="combobox"\
                aria-haspopup="true"\
                aria-activedescendant=""\
                aria-expanded="{{!$mdAutocompleteCtrl.hidden}}"/>\
            <button\
                type="button"\
                tabindex="-1"\
                ng-if="$mdAutocompleteCtrl.scope.searchText && !$mdAutocompleteCtrl.isDisabled"\
                ng-click="$mdAutocompleteCtrl.clear($event)">\
              <md-icon md-svg-src="' + $$mdSvgRegistry.mdClose + '"></md-icon>\
              <span class="_md-visually-hidden">Clear</span>\
            </button>\
                ';
                }
              }
            }
          };
        }
        MdAutocomplete.$inject = ["$$mdSvgRegistry"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.autocomplete').directive('mdAutocompleteParentScope', MdAutocompleteItemScopeDirective);
        function MdAutocompleteItemScopeDirective($compile, $mdUtil) {
          return {
            restrict: 'AE',
            compile: compile,
            terminal: true,
            transclude: 'element'
          };
          function compile(tElement, tAttr, transclude) {
            return function postLink(scope, element, attr) {
              var ctrl = scope.$mdAutocompleteCtrl;
              var newScope = ctrl.parent.$new();
              var itemName = ctrl.itemName;
              watchVariable('$index', '$index');
              watchVariable('item', itemName);
              connectScopes();
              transclude(newScope, function(clone) {
                element.after(clone);
              });
              function watchVariable(variable, alias) {
                newScope[alias] = scope[variable];
                scope.$watch(variable, function(value) {
                  $mdUtil.nextTick(function() {
                    newScope[alias] = value;
                  });
                });
              }
              function connectScopes() {
                var scopeDigesting = false;
                var newScopeDigesting = false;
                scope.$watch(function() {
                  if (newScopeDigesting || scopeDigesting) {
                    return;
                  }
                  scopeDigesting = true;
                  scope.$$postDigest(function() {
                    if (!newScopeDigesting) {
                      newScope.$digest();
                    }
                    scopeDigesting = newScopeDigesting = false;
                  });
                });
                newScope.$watch(function() {
                  newScopeDigesting = true;
                });
              }
            };
          }
        }
        MdAutocompleteItemScopeDirective.$inject = ["$compile", "$mdUtil"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.autocomplete').controller('MdHighlightCtrl', MdHighlightCtrl);
        function MdHighlightCtrl($scope, $element, $attrs) {
          this.init = init;
          function init(termExpr, unsafeTextExpr) {
            var text = null,
                regex = null,
                flags = $attrs.mdHighlightFlags || '',
                watcher = $scope.$watch(function($scope) {
                  return {
                    term: termExpr($scope),
                    unsafeText: unsafeTextExpr($scope)
                  };
                }, function(state, prevState) {
                  if (text === null || state.unsafeText !== prevState.unsafeText) {
                    text = angular.element('<div>').text(state.unsafeText).html();
                  }
                  if (regex === null || state.term !== prevState.term) {
                    regex = getRegExp(state.term, flags);
                  }
                  $element.html(text.replace(regex, '<span class="highlight">$&</span>'));
                }, true);
            $element.on('$destroy', watcher);
          }
          function sanitize(term) {
            return term && term.replace(/[\\\^\$\*\+\?\.\(\)\|\{}\[\]]/g, '\\$&');
          }
          function getRegExp(text, flags) {
            var startFlag = '',
                endFlag = '';
            if (flags.indexOf('^') >= 0)
              startFlag = '^';
            if (flags.indexOf('$') >= 0)
              endFlag = '$';
            return new RegExp(startFlag + sanitize(text) + endFlag, flags.replace(/[\$\^]/g, ''));
          }
        }
        MdHighlightCtrl.$inject = ["$scope", "$element", "$attrs"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.autocomplete').directive('mdHighlightText', MdHighlight);
        function MdHighlight($interpolate, $parse) {
          return {
            terminal: true,
            controller: 'MdHighlightCtrl',
            compile: function mdHighlightCompile(tElement, tAttr) {
              var termExpr = $parse(tAttr.mdHighlightText);
              var unsafeTextExpr = $interpolate(tElement.html());
              return function mdHighlightLink(scope, element, attr, ctrl) {
                ctrl.init(termExpr, unsafeTextExpr);
              };
            }
          };
        }
        MdHighlight.$inject = ["$interpolate", "$parse"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.chips').controller('MdChipCtrl', MdChipCtrl);
        function MdChipCtrl($scope, $element, $mdConstant, $timeout, $mdUtil) {
          this.$scope = $scope;
          this.$element = $element;
          this.$mdConstant = $mdConstant;
          this.$timeout = $timeout;
          this.$mdUtil = $mdUtil;
          this.isEditting = false;
          this.parentController = undefined;
          this.enableChipEdit = false;
        }
        MdChipCtrl.$inject = ["$scope", "$element", "$mdConstant", "$timeout", "$mdUtil"];
        MdChipCtrl.prototype.init = function(controller) {
          this.parentController = controller;
          this.enableChipEdit = this.parentController.enableChipEdit;
          if (this.enableChipEdit) {
            this.$element.on('keydown', this.chipKeyDown.bind(this));
            this.$element.on('mousedown', this.chipMouseDown.bind(this));
            this.getChipContent().addClass('_md-chip-content-edit-is-enabled');
          }
        };
        MdChipCtrl.prototype.getChipContent = function() {
          var chipContents = this.$element[0].getElementsByClassName('_md-chip-content');
          return angular.element(chipContents[0]);
        };
        MdChipCtrl.prototype.getContentElement = function() {
          return angular.element(this.getChipContent().children()[0]);
        };
        MdChipCtrl.prototype.getChipIndex = function() {
          return parseInt(this.$element.attr('index'));
        };
        MdChipCtrl.prototype.goOutOfEditMode = function() {
          if (!this.isEditting)
            return;
          this.isEditting = false;
          this.$element.removeClass('_md-chip-editing');
          this.getChipContent()[0].contentEditable = 'false';
          var chipIndex = this.getChipIndex();
          var content = this.getContentElement().text();
          if (content) {
            this.parentController.updateChipContents(chipIndex, this.getContentElement().text());
            this.$mdUtil.nextTick(function() {
              if (this.parentController.selectedChip === chipIndex) {
                this.parentController.focusChip(chipIndex);
              }
            }.bind(this));
          } else {
            this.parentController.removeChipAndFocusInput(chipIndex);
          }
        };
        MdChipCtrl.prototype.selectNodeContents = function(node) {
          var range,
              selection;
          if (document.body.createTextRange) {
            range = document.body.createTextRange();
            range.moveToElementText(node);
            range.select();
          } else if (window.getSelection) {
            selection = window.getSelection();
            range = document.createRange();
            range.selectNodeContents(node);
            selection.removeAllRanges();
            selection.addRange(range);
          }
        };
        MdChipCtrl.prototype.goInEditMode = function() {
          this.isEditting = true;
          this.$element.addClass('_md-chip-editing');
          this.getChipContent()[0].contentEditable = 'true';
          this.getChipContent().on('blur', function() {
            this.goOutOfEditMode();
          }.bind(this));
          this.selectNodeContents(this.getChipContent()[0]);
        };
        MdChipCtrl.prototype.chipKeyDown = function(event) {
          if (!this.isEditting && (event.keyCode === this.$mdConstant.KEY_CODE.ENTER || event.keyCode === this.$mdConstant.KEY_CODE.SPACE)) {
            event.preventDefault();
            this.goInEditMode();
          } else if (this.isEditting && event.keyCode === this.$mdConstant.KEY_CODE.ENTER) {
            event.preventDefault();
            this.goOutOfEditMode();
          }
        };
        MdChipCtrl.prototype.chipMouseDown = function() {
          if (this.getChipIndex() == this.parentController.selectedChip && this.enableChipEdit && !this.isEditting) {
            this.goInEditMode();
          }
        };
      })();
      (function() {
        "use strict";
        angular.module('material.components.chips').directive('mdChip', MdChip);
        var DELETE_HINT_TEMPLATE = '\
    <span ng-if="!$mdChipsCtrl.readonly" class="_md-visually-hidden">\
      {{$mdChipsCtrl.deleteHint}}\
    </span>';
        function MdChip($mdTheming, $mdUtil) {
          var hintTemplate = $mdUtil.processTemplate(DELETE_HINT_TEMPLATE);
          return {
            restrict: 'E',
            require: ['^?mdChips', 'mdChip'],
            compile: compile,
            controller: 'MdChipCtrl'
          };
          function compile(element, attr) {
            element.append($mdUtil.processTemplate(hintTemplate));
            return function postLink(scope, element, attr, ctrls) {
              var chipsController = ctrls.shift();
              var chipController = ctrls.shift();
              $mdTheming(element);
              if (chipsController) {
                chipController.init(chipsController);
                angular.element(element[0].querySelector('._md-chip-content')).on('blur', function() {
                  chipsController.resetSelectedChip();
                  chipsController.$scope.$applyAsync();
                });
              }
            };
          }
        }
        MdChip.$inject = ["$mdTheming", "$mdUtil"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.chips').directive('mdChipRemove', MdChipRemove);
        function MdChipRemove($timeout) {
          return {
            restrict: 'A',
            require: '^mdChips',
            scope: false,
            link: postLink
          };
          function postLink(scope, element, attr, ctrl) {
            element.on('click', function(event) {
              scope.$apply(function() {
                ctrl.removeChip(scope.$$replacedScope.$index);
              });
            });
            $timeout(function() {
              element.attr({
                tabindex: -1,
                'aria-hidden': true
              });
              element.find('button').attr('tabindex', '-1');
            });
          }
        }
        MdChipRemove.$inject = ["$timeout"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.chips').directive('mdChipTransclude', MdChipTransclude);
        function MdChipTransclude($compile) {
          return {
            restrict: 'EA',
            terminal: true,
            link: link,
            scope: false
          };
          function link(scope, element, attr) {
            var ctrl = scope.$parent.$mdChipsCtrl,
                newScope = ctrl.parent.$new(false, ctrl.parent);
            newScope.$$replacedScope = scope;
            newScope.$chip = scope.$chip;
            newScope.$index = scope.$index;
            newScope.$mdChipsCtrl = ctrl;
            var newHtml = ctrl.$scope.$eval(attr.mdChipTransclude);
            element.html(newHtml);
            $compile(element.contents())(newScope);
          }
        }
        MdChipTransclude.$inject = ["$compile"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.chips').controller('MdChipsCtrl', MdChipsCtrl);
        function MdChipsCtrl($scope, $mdConstant, $log, $element, $timeout, $mdUtil) {
          this.$timeout = $timeout;
          this.$mdConstant = $mdConstant;
          this.$scope = $scope;
          this.parent = $scope.$parent;
          this.$log = $log;
          this.$element = $element;
          this.ngModelCtrl = null;
          this.userInputNgModelCtrl = null;
          this.userInputElement = null;
          this.items = [];
          this.selectedChip = -1;
          this.hasAutocomplete = false;
          this.enableChipEdit = $mdUtil.parseAttributeBoolean(this.mdEnableChipEdit);
          this.deleteHint = 'Press delete to remove this chip.';
          this.deleteButtonLabel = 'Remove';
          this.chipBuffer = '';
          this.useTransformChip = false;
          this.useOnAdd = false;
          this.useOnRemove = false;
        }
        MdChipsCtrl.$inject = ["$scope", "$mdConstant", "$log", "$element", "$timeout", "$mdUtil"];
        MdChipsCtrl.prototype.inputKeydown = function(event) {
          var chipBuffer = this.getChipBuffer();
          if (this.hasAutocomplete && event.isDefaultPrevented && event.isDefaultPrevented()) {
            return;
          }
          if (event.keyCode === this.$mdConstant.KEY_CODE.BACKSPACE) {
            if (getCursorPosition(event.target) !== 0) {
              return;
            }
            event.preventDefault();
            event.stopPropagation();
            if (this.items.length) {
              this.selectAndFocusChipSafe(this.items.length - 1);
            }
            return;
          }
          if (!this.separatorKeys || this.separatorKeys.length < 1) {
            this.separatorKeys = [this.$mdConstant.KEY_CODE.ENTER];
          }
          if (this.separatorKeys.indexOf(event.keyCode) !== -1) {
            if ((this.hasAutocomplete && this.requireMatch) || !chipBuffer)
              return;
            event.preventDefault();
            if (this.hasMaxChipsReached())
              return;
            this.appendChip(chipBuffer.trim());
            this.resetChipBuffer();
          }
        };
        function getCursorPosition(element) {
          if (element.selectionStart === element.selectionEnd) {
            return element.selectionStart;
          }
          return -1;
        }
        MdChipsCtrl.prototype.updateChipContents = function(chipIndex, chipContents) {
          if (chipIndex >= 0 && chipIndex < this.items.length) {
            this.items[chipIndex] = chipContents;
            this.ngModelCtrl.$setDirty();
          }
        };
        MdChipsCtrl.prototype.isEditingChip = function() {
          return !!this.$element[0].getElementsByClassName('_md-chip-editing').length;
        };
        MdChipsCtrl.prototype.isRemovable = function() {
          if (!this.ngModelCtrl) {
            return false;
          }
          return this.readonly ? this.removable : angular.isDefined(this.removable) ? this.removable : true;
        };
        MdChipsCtrl.prototype.chipKeydown = function(event) {
          if (this.getChipBuffer())
            return;
          if (this.isEditingChip())
            return;
          switch (event.keyCode) {
            case this.$mdConstant.KEY_CODE.BACKSPACE:
            case this.$mdConstant.KEY_CODE.DELETE:
              if (this.selectedChip < 0)
                return;
              event.preventDefault();
              if (!this.isRemovable())
                return;
              this.removeAndSelectAdjacentChip(this.selectedChip);
              break;
            case this.$mdConstant.KEY_CODE.LEFT_ARROW:
              event.preventDefault();
              if (this.selectedChip < 0)
                this.selectedChip = this.items.length;
              if (this.items.length)
                this.selectAndFocusChipSafe(this.selectedChip - 1);
              break;
            case this.$mdConstant.KEY_CODE.RIGHT_ARROW:
              event.preventDefault();
              this.selectAndFocusChipSafe(this.selectedChip + 1);
              break;
            case this.$mdConstant.KEY_CODE.ESCAPE:
            case this.$mdConstant.KEY_CODE.TAB:
              if (this.selectedChip < 0)
                return;
              event.preventDefault();
              this.onFocus();
              break;
          }
        };
        MdChipsCtrl.prototype.getPlaceholder = function() {
          var useSecondary = (this.items && this.items.length && (this.secondaryPlaceholder == '' || this.secondaryPlaceholder));
          return useSecondary ? this.secondaryPlaceholder : this.placeholder;
        };
        MdChipsCtrl.prototype.removeAndSelectAdjacentChip = function(index) {
          var selIndex = this.getAdjacentChipIndex(index);
          this.removeChip(index);
          this.$timeout(angular.bind(this, function() {
            this.selectAndFocusChipSafe(selIndex);
          }));
        };
        MdChipsCtrl.prototype.resetSelectedChip = function() {
          this.selectedChip = -1;
        };
        MdChipsCtrl.prototype.getAdjacentChipIndex = function(index) {
          var len = this.items.length - 1;
          return (len == 0) ? -1 : (index == len) ? index - 1 : index;
        };
        MdChipsCtrl.prototype.appendChip = function(newChip) {
          if (this.useTransformChip && this.transformChip) {
            var transformedChip = this.transformChip({'$chip': newChip});
            if (angular.isDefined(transformedChip)) {
              newChip = transformedChip;
            }
          }
          if (angular.isObject(newChip)) {
            var identical = this.items.some(function(item) {
              return angular.equals(newChip, item);
            });
            if (identical)
              return;
          }
          if (newChip == null || this.items.indexOf(newChip) + 1)
            return;
          var index = this.items.push(newChip);
          this.ngModelCtrl.$setDirty();
          this.validateModel();
          if (this.useOnAdd && this.onAdd) {
            this.onAdd({
              '$chip': newChip,
              '$index': index
            });
          }
        };
        MdChipsCtrl.prototype.useTransformChipExpression = function() {
          this.useTransformChip = true;
        };
        MdChipsCtrl.prototype.useOnAddExpression = function() {
          this.useOnAdd = true;
        };
        MdChipsCtrl.prototype.useOnRemoveExpression = function() {
          this.useOnRemove = true;
        };
        MdChipsCtrl.prototype.useOnSelectExpression = function() {
          this.useOnSelect = true;
        };
        MdChipsCtrl.prototype.getChipBuffer = function() {
          return !this.userInputElement ? this.chipBuffer : this.userInputNgModelCtrl ? this.userInputNgModelCtrl.$viewValue : this.userInputElement[0].value;
        };
        MdChipsCtrl.prototype.resetChipBuffer = function() {
          if (this.userInputElement) {
            if (this.userInputNgModelCtrl) {
              this.userInputNgModelCtrl.$setViewValue('');
              this.userInputNgModelCtrl.$render();
            } else {
              this.userInputElement[0].value = '';
            }
          } else {
            this.chipBuffer = '';
          }
        };
        MdChipsCtrl.prototype.hasMaxChipsReached = function() {
          if (angular.isString(this.maxChips))
            this.maxChips = parseInt(this.maxChips, 10) || 0;
          return this.maxChips > 0 && this.items.length >= this.maxChips;
        };
        MdChipsCtrl.prototype.validateModel = function() {
          this.ngModelCtrl.$setValidity('md-max-chips', !this.hasMaxChipsReached());
        };
        MdChipsCtrl.prototype.removeChip = function(index) {
          var removed = this.items.splice(index, 1);
          this.ngModelCtrl.$setDirty();
          this.validateModel();
          if (removed && removed.length && this.useOnRemove && this.onRemove) {
            this.onRemove({
              '$chip': removed[0],
              '$index': index
            });
          }
        };
        MdChipsCtrl.prototype.removeChipAndFocusInput = function(index) {
          this.removeChip(index);
          this.onFocus();
        };
        MdChipsCtrl.prototype.selectAndFocusChipSafe = function(index) {
          if (!this.items.length) {
            this.selectChip(-1);
            this.onFocus();
            return;
          }
          if (index === this.items.length)
            return this.onFocus();
          index = Math.max(index, 0);
          index = Math.min(index, this.items.length - 1);
          this.selectChip(index);
          this.focusChip(index);
        };
        MdChipsCtrl.prototype.selectChip = function(index) {
          if (index >= -1 && index <= this.items.length) {
            this.selectedChip = index;
            if (this.useOnSelect && this.onSelect) {
              this.onSelect({'$chip': this.items[this.selectedChip]});
            }
          } else {
            this.$log.warn('Selected Chip index out of bounds; ignoring.');
          }
        };
        MdChipsCtrl.prototype.selectAndFocusChip = function(index) {
          this.selectChip(index);
          if (index != -1) {
            this.focusChip(index);
          }
        };
        MdChipsCtrl.prototype.focusChip = function(index) {
          this.$element[0].querySelector('md-chip[index="' + index + '"] ._md-chip-content').focus();
        };
        MdChipsCtrl.prototype.configureNgModel = function(ngModelCtrl) {
          this.ngModelCtrl = ngModelCtrl;
          var self = this;
          ngModelCtrl.$render = function() {
            self.items = self.ngModelCtrl.$viewValue;
          };
        };
        MdChipsCtrl.prototype.onFocus = function() {
          var input = this.$element[0].querySelector('input');
          input && input.focus();
          this.resetSelectedChip();
        };
        MdChipsCtrl.prototype.onInputFocus = function() {
          this.inputHasFocus = true;
          this.resetSelectedChip();
        };
        MdChipsCtrl.prototype.onInputBlur = function() {
          this.inputHasFocus = false;
        };
        MdChipsCtrl.prototype.configureUserInput = function(inputElement) {
          this.userInputElement = inputElement;
          var ngModelCtrl = inputElement.controller('ngModel');
          if (ngModelCtrl != this.ngModelCtrl) {
            this.userInputNgModelCtrl = ngModelCtrl;
          }
          var scope = this.$scope;
          var ctrl = this;
          var scopeApplyFn = function(event, fn) {
            scope.$evalAsync(angular.bind(ctrl, fn, event));
          };
          inputElement.attr({tabindex: 0}).on('keydown', function(event) {
            scopeApplyFn(event, ctrl.inputKeydown);
          }).on('focus', function(event) {
            scopeApplyFn(event, ctrl.onInputFocus);
          }).on('blur', function(event) {
            scopeApplyFn(event, ctrl.onInputBlur);
          });
        };
        MdChipsCtrl.prototype.configureAutocomplete = function(ctrl) {
          if (ctrl) {
            this.hasAutocomplete = true;
            ctrl.registerSelectedItemWatcher(angular.bind(this, function(item) {
              if (item) {
                if (this.hasMaxChipsReached())
                  return;
                this.appendChip(item);
                this.resetChipBuffer();
              }
            }));
            this.$element.find('input').on('focus', angular.bind(this, this.onInputFocus)).on('blur', angular.bind(this, this.onInputBlur));
          }
        };
        MdChipsCtrl.prototype.hasFocus = function() {
          return this.inputHasFocus || this.selectedChip >= 0;
        };
      })();
      (function() {
        "use strict";
        angular.module('material.components.chips').directive('mdChips', MdChips);
        var MD_CHIPS_TEMPLATE = '\
      <md-chips-wrap\
          ng-keydown="$mdChipsCtrl.chipKeydown($event)"\
          ng-class="{ \'md-focused\': $mdChipsCtrl.hasFocus(), \
                      \'md-readonly\': !$mdChipsCtrl.ngModelCtrl || $mdChipsCtrl.readonly,\
                      \'md-removable\': $mdChipsCtrl.isRemovable() }"\
          class="md-chips">\
        <md-chip ng-repeat="$chip in $mdChipsCtrl.items"\
            index="{{$index}}"\
            ng-class="{\'md-focused\': $mdChipsCtrl.selectedChip == $index, \'md-readonly\': !$mdChipsCtrl.ngModelCtrl || $mdChipsCtrl.readonly}">\
          <div class="_md-chip-content"\
              tabindex="-1"\
              aria-hidden="true"\
              ng-click="!$mdChipsCtrl.readonly && $mdChipsCtrl.focusChip($index)"\
              ng-focus="!$mdChipsCtrl.readonly && $mdChipsCtrl.selectChip($index)"\
              md-chip-transclude="$mdChipsCtrl.chipContentsTemplate"></div>\
          <div ng-if="$mdChipsCtrl.isRemovable()"\
               class="_md-chip-remove-container"\
               md-chip-transclude="$mdChipsCtrl.chipRemoveTemplate"></div>\
        </md-chip>\
        <div class="_md-chip-input-container">\
          <div ng-if="!$mdChipsCtrl.readonly && $mdChipsCtrl.ngModelCtrl"\
               md-chip-transclude="$mdChipsCtrl.chipInputTemplate"></div>\
        </div>\
      </md-chips-wrap>';
        var CHIP_INPUT_TEMPLATE = '\
        <input\
            class="md-input"\
            tabindex="0"\
            placeholder="{{$mdChipsCtrl.getPlaceholder()}}"\
            aria-label="{{$mdChipsCtrl.getPlaceholder()}}"\
            ng-model="$mdChipsCtrl.chipBuffer"\
            ng-focus="$mdChipsCtrl.onInputFocus()"\
            ng-blur="$mdChipsCtrl.onInputBlur()"\
            ng-keydown="$mdChipsCtrl.inputKeydown($event)">';
        var CHIP_DEFAULT_TEMPLATE = '\
      <span>{{$chip}}</span>';
        var CHIP_REMOVE_TEMPLATE = '\
      <button\
          class="_md-chip-remove"\
          ng-if="$mdChipsCtrl.isRemovable()"\
          ng-click="$mdChipsCtrl.removeChipAndFocusInput($$replacedScope.$index)"\
          type="button"\
          aria-hidden="true"\
          tabindex="-1">\
        <md-icon md-svg-src="{{ $mdChipsCtrl.mdCloseIcon }}"></md-icon>\
        <span class="_md-visually-hidden">\
          {{$mdChipsCtrl.deleteButtonLabel}}\
        </span>\
      </button>';
        function MdChips($mdTheming, $mdUtil, $compile, $log, $timeout, $$mdSvgRegistry) {
          var templates = getTemplates();
          return {
            template: function(element, attrs) {
              attrs['$mdUserTemplate'] = element.clone();
              return templates.chips;
            },
            require: ['mdChips'],
            restrict: 'E',
            controller: 'MdChipsCtrl',
            controllerAs: '$mdChipsCtrl',
            bindToController: true,
            compile: compile,
            scope: {
              readonly: '=readonly',
              removable: '=mdRemovable',
              placeholder: '@',
              mdEnableChipEdit: '@',
              secondaryPlaceholder: '@',
              maxChips: '@mdMaxChips',
              transformChip: '&mdTransformChip',
              onAppend: '&mdOnAppend',
              onAdd: '&mdOnAdd',
              onRemove: '&mdOnRemove',
              onSelect: '&mdOnSelect',
              deleteHint: '@',
              deleteButtonLabel: '@',
              separatorKeys: '=?mdSeparatorKeys',
              requireMatch: '=?mdRequireMatch'
            }
          };
          function compile(element, attr) {
            var userTemplate = attr['$mdUserTemplate'];
            attr['$mdUserTemplate'] = null;
            var chipTemplate = getTemplateByQuery('md-chips>md-chip-template');
            var chipRemoveSelector = $mdUtil.prefixer().buildList('md-chip-remove').map(function(attr) {
              return 'md-chips>*[' + attr + ']';
            }).join(',');
            var chipRemoveTemplate = getTemplateByQuery(chipRemoveSelector) || templates.remove,
                chipContentsTemplate = chipTemplate || templates.default,
                chipInputTemplate = getTemplateByQuery('md-chips>md-autocomplete') || getTemplateByQuery('md-chips>input') || templates.input,
                staticChips = userTemplate.find('md-chip');
            if (userTemplate[0].querySelector('md-chip-template>*[md-chip-remove]')) {
              $log.warn('invalid placement of md-chip-remove within md-chip-template.');
            }
            function getTemplateByQuery(query) {
              if (!attr.ngModel)
                return;
              var element = userTemplate[0].querySelector(query);
              return element && element.outerHTML;
            }
            return function postLink(scope, element, attrs, controllers) {
              $mdUtil.initOptionalProperties(scope, attr);
              $mdTheming(element);
              var mdChipsCtrl = controllers[0];
              if (chipTemplate) {
                mdChipsCtrl.enableChipEdit = false;
              }
              mdChipsCtrl.chipContentsTemplate = chipContentsTemplate;
              mdChipsCtrl.chipRemoveTemplate = chipRemoveTemplate;
              mdChipsCtrl.chipInputTemplate = chipInputTemplate;
              mdChipsCtrl.mdCloseIcon = $$mdSvgRegistry.mdClose;
              element.attr({
                'aria-hidden': true,
                tabindex: -1
              }).on('focus', function() {
                mdChipsCtrl.onFocus();
              });
              if (attr.ngModel) {
                mdChipsCtrl.configureNgModel(element.controller('ngModel'));
                if (attrs.mdTransformChip)
                  mdChipsCtrl.useTransformChipExpression();
                if (attrs.mdOnAppend)
                  mdChipsCtrl.useOnAppendExpression();
                if (attrs.mdOnAdd)
                  mdChipsCtrl.useOnAddExpression();
                if (attrs.mdOnRemove)
                  mdChipsCtrl.useOnRemoveExpression();
                if (attrs.mdOnSelect)
                  mdChipsCtrl.useOnSelectExpression();
                if (chipInputTemplate != templates.input) {
                  scope.$watch('$mdChipsCtrl.readonly', function(readonly) {
                    if (!readonly) {
                      $mdUtil.nextTick(function() {
                        if (chipInputTemplate.indexOf('<md-autocomplete') === 0)
                          mdChipsCtrl.configureAutocomplete(element.find('md-autocomplete').controller('mdAutocomplete'));
                        mdChipsCtrl.configureUserInput(element.find('input'));
                      });
                    }
                  });
                }
                $mdUtil.nextTick(function() {
                  var input = element.find('input');
                  input && input.toggleClass('md-input', true);
                });
              }
              if (staticChips.length > 0) {
                var compiledStaticChips = $compile(staticChips.clone())(scope.$parent);
                $timeout(function() {
                  element.find('md-chips-wrap').prepend(compiledStaticChips);
                });
              }
            };
          }
          function getTemplates() {
            return {
              chips: $mdUtil.processTemplate(MD_CHIPS_TEMPLATE),
              input: $mdUtil.processTemplate(CHIP_INPUT_TEMPLATE),
              default: $mdUtil.processTemplate(CHIP_DEFAULT_TEMPLATE),
              remove: $mdUtil.processTemplate(CHIP_REMOVE_TEMPLATE)
            };
          }
        }
        MdChips.$inject = ["$mdTheming", "$mdUtil", "$compile", "$log", "$timeout", "$$mdSvgRegistry"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.chips').controller('MdContactChipsCtrl', MdContactChipsCtrl);
        function MdContactChipsCtrl() {
          this.selectedItem = null;
          this.searchText = '';
        }
        MdContactChipsCtrl.prototype.queryContact = function(searchText) {
          var results = this.contactQuery({'$query': searchText});
          return this.filterSelected ? results.filter(angular.bind(this, this.filterSelectedContacts)) : results;
        };
        MdContactChipsCtrl.prototype.itemName = function(item) {
          return item[this.contactName];
        };
        MdContactChipsCtrl.prototype.filterSelectedContacts = function(contact) {
          return this.contacts.indexOf(contact) == -1;
        };
      })();
      (function() {
        "use strict";
        angular.module('material.components.chips').directive('mdContactChips', MdContactChips);
        var MD_CONTACT_CHIPS_TEMPLATE = '\
      <md-chips class="md-contact-chips"\
          ng-model="$mdContactChipsCtrl.contacts"\
          md-require-match="$mdContactChipsCtrl.requireMatch"\
          md-autocomplete-snap>\
          <md-autocomplete\
              md-menu-class="md-contact-chips-suggestions"\
              md-selected-item="$mdContactChipsCtrl.selectedItem"\
              md-search-text="$mdContactChipsCtrl.searchText"\
              md-items="item in $mdContactChipsCtrl.queryContact($mdContactChipsCtrl.searchText)"\
              md-item-text="$mdContactChipsCtrl.itemName(item)"\
              md-no-cache="true"\
              md-autoselect\
              placeholder="{{$mdContactChipsCtrl.contacts.length == 0 ?\
                  $mdContactChipsCtrl.placeholder : $mdContactChipsCtrl.secondaryPlaceholder}}">\
            <div class="md-contact-suggestion">\
              <img \
                  ng-src="{{item[$mdContactChipsCtrl.contactImage]}}"\
                  alt="{{item[$mdContactChipsCtrl.contactName]}}"\
                  ng-if="item[$mdContactChipsCtrl.contactImage]" />\
              <span class="md-contact-name" md-highlight-text="$mdContactChipsCtrl.searchText"\
                    md-highlight-flags="{{$mdContactChipsCtrl.highlightFlags}}">\
                {{item[$mdContactChipsCtrl.contactName]}}\
              </span>\
              <span class="md-contact-email" >{{item[$mdContactChipsCtrl.contactEmail]}}</span>\
            </div>\
          </md-autocomplete>\
          <md-chip-template>\
            <div class="md-contact-avatar">\
              <img \
                  ng-src="{{$chip[$mdContactChipsCtrl.contactImage]}}"\
                  alt="{{$chip[$mdContactChipsCtrl.contactName]}}"\
                  ng-if="$chip[$mdContactChipsCtrl.contactImage]" />\
            </div>\
            <div class="md-contact-name">\
              {{$chip[$mdContactChipsCtrl.contactName]}}\
            </div>\
          </md-chip-template>\
      </md-chips>';
        function MdContactChips($mdTheming, $mdUtil) {
          return {
            template: function(element, attrs) {
              return MD_CONTACT_CHIPS_TEMPLATE;
            },
            restrict: 'E',
            controller: 'MdContactChipsCtrl',
            controllerAs: '$mdContactChipsCtrl',
            bindToController: true,
            compile: compile,
            scope: {
              contactQuery: '&mdContacts',
              placeholder: '@',
              secondaryPlaceholder: '@',
              contactName: '@mdContactName',
              contactImage: '@mdContactImage',
              contactEmail: '@mdContactEmail',
              contacts: '=ngModel',
              requireMatch: '=?mdRequireMatch',
              highlightFlags: '@?mdHighlightFlags'
            }
          };
          function compile(element, attr) {
            return function postLink(scope, element, attrs, controllers) {
              $mdUtil.initOptionalProperties(scope, attr);
              $mdTheming(element);
              element.attr('tabindex', '-1');
            };
          }
        }
        MdContactChips.$inject = ["$mdTheming", "$mdUtil"];
      })();
      (function() {
        "use strict";
        (function() {
          'use strict';
          angular.module('material.components.datepicker').directive('mdCalendar', calendarDirective);
          function calendarDirective() {
            return {
              template: function(tElement, tAttr) {
                var extraAttrs = tAttr.hasOwnProperty('ngIf') ? '' : 'ng-if="calendarCtrl.isInitialized"';
                var template = '' + '<div ng-switch="calendarCtrl.currentView" ' + extraAttrs + '>' + '<md-calendar-year ng-switch-when="year"></md-calendar-year>' + '<md-calendar-month ng-switch-default></md-calendar-month>' + '</div>';
                return template;
              },
              scope: {
                minDate: '=mdMinDate',
                maxDate: '=mdMaxDate',
                dateFilter: '=mdDateFilter'
              },
              require: ['ngModel', 'mdCalendar'],
              controller: CalendarCtrl,
              controllerAs: 'calendarCtrl',
              bindToController: true,
              link: function(scope, element, attrs, controllers) {
                var ngModelCtrl = controllers[0];
                var mdCalendarCtrl = controllers[1];
                mdCalendarCtrl.configureNgModel(ngModelCtrl);
              }
            };
          }
          var FALLBACK_WIDTH = 340;
          var nextUniqueId = 0;
          function CalendarCtrl($element, $scope, $$mdDateUtil, $mdUtil, $mdConstant, $mdTheming, $$rAF, $attrs) {
            $mdTheming($element);
            this.$element = $element;
            this.$scope = $scope;
            this.dateUtil = $$mdDateUtil;
            this.$mdUtil = $mdUtil;
            this.keyCode = $mdConstant.KEY_CODE;
            this.$$rAF = $$rAF;
            this.today = this.dateUtil.createDateAtMidnight();
            this.ngModelCtrl = null;
            this.currentView = 'month';
            this.SELECTED_DATE_CLASS = 'md-calendar-selected-date';
            this.TODAY_CLASS = 'md-calendar-date-today';
            this.FOCUSED_DATE_CLASS = 'md-focus';
            this.id = nextUniqueId++;
            this.displayDate = null;
            this.selectedDate = null;
            this.isInitialized = false;
            this.width = 0;
            this.scrollbarWidth = 0;
            if (!$attrs.tabindex) {
              $element.attr('tabindex', '-1');
            }
            $element.on('keydown', angular.bind(this, this.handleKeyEvent));
          }
          CalendarCtrl.$inject = ["$element", "$scope", "$$mdDateUtil", "$mdUtil", "$mdConstant", "$mdTheming", "$$rAF", "$attrs"];
          CalendarCtrl.prototype.configureNgModel = function(ngModelCtrl) {
            var self = this;
            self.ngModelCtrl = ngModelCtrl;
            self.$mdUtil.nextTick(function() {
              self.isInitialized = true;
            });
            ngModelCtrl.$render = function() {
              var value = this.$viewValue;
              self.$scope.$broadcast('md-calendar-parent-changed', value);
              if (!self.selectedDate) {
                self.selectedDate = value;
              }
              if (!self.displayDate) {
                self.displayDate = self.selectedDate || self.today;
              }
            };
          };
          CalendarCtrl.prototype.setNgModelValue = function(date) {
            var value = this.dateUtil.createDateAtMidnight(date);
            this.focus(value);
            this.$scope.$emit('md-calendar-change', value);
            this.ngModelCtrl.$setViewValue(value);
            this.ngModelCtrl.$render();
            return value;
          };
          CalendarCtrl.prototype.setCurrentView = function(newView, time) {
            var self = this;
            self.$mdUtil.nextTick(function() {
              self.currentView = newView;
              if (time) {
                self.displayDate = angular.isDate(time) ? time : new Date(time);
              }
            });
          };
          CalendarCtrl.prototype.focus = function(date) {
            if (this.dateUtil.isValidDate(date)) {
              var previousFocus = this.$element[0].querySelector('.md-focus');
              if (previousFocus) {
                previousFocus.classList.remove(this.FOCUSED_DATE_CLASS);
              }
              var cellId = this.getDateId(date, this.currentView);
              var cell = document.getElementById(cellId);
              if (cell) {
                cell.classList.add(this.FOCUSED_DATE_CLASS);
                cell.focus();
                this.displayDate = date;
              }
            } else {
              var rootElement = this.$element[0].querySelector('[ng-switch]');
              if (rootElement) {
                rootElement.focus();
              }
            }
          };
          CalendarCtrl.prototype.getActionFromKeyEvent = function(event) {
            var keyCode = this.keyCode;
            switch (event.which) {
              case keyCode.ENTER:
                return 'select';
              case keyCode.RIGHT_ARROW:
                return 'move-right';
              case keyCode.LEFT_ARROW:
                return 'move-left';
              case keyCode.DOWN_ARROW:
                return event.metaKey ? 'move-page-down' : 'move-row-down';
              case keyCode.UP_ARROW:
                return event.metaKey ? 'move-page-up' : 'move-row-up';
              case keyCode.PAGE_DOWN:
                return 'move-page-down';
              case keyCode.PAGE_UP:
                return 'move-page-up';
              case keyCode.HOME:
                return 'start';
              case keyCode.END:
                return 'end';
              default:
                return null;
            }
          };
          CalendarCtrl.prototype.handleKeyEvent = function(event) {
            var self = this;
            this.$scope.$apply(function() {
              if (event.which == self.keyCode.ESCAPE || event.which == self.keyCode.TAB) {
                self.$scope.$emit('md-calendar-close');
                if (event.which == self.keyCode.TAB) {
                  event.preventDefault();
                }
                return;
              }
              var action = self.getActionFromKeyEvent(event);
              if (action) {
                event.preventDefault();
                event.stopPropagation();
                self.$scope.$broadcast('md-calendar-parent-action', action);
              }
            });
          };
          CalendarCtrl.prototype.hideVerticalScrollbar = function(childCtrl) {
            var self = this;
            var element = childCtrl.$element[0];
            var scrollMask = element.querySelector('.md-calendar-scroll-mask');
            if (self.width > 0) {
              setWidth();
            } else {
              self.$$rAF(function() {
                var scroller = childCtrl.calendarScroller;
                self.scrollbarWidth = scroller.offsetWidth - scroller.clientWidth;
                self.width = element.querySelector('table').offsetWidth;
                setWidth();
              });
            }
            function setWidth() {
              var width = self.width || FALLBACK_WIDTH;
              var scrollbarWidth = self.scrollbarWidth;
              var scroller = childCtrl.calendarScroller;
              scrollMask.style.width = width + 'px';
              scroller.style.width = (width + scrollbarWidth) + 'px';
              scroller.style.paddingRight = scrollbarWidth + 'px';
            }
          };
          CalendarCtrl.prototype.getDateId = function(date, namespace) {
            if (!namespace) {
              throw new Error('A namespace for the date id has to be specified.');
            }
            return ['md', this.id, namespace, date.getFullYear(), date.getMonth(), date.getDate()].join('-');
          };
        })();
      })();
      (function() {
        "use strict";
        (function() {
          'use strict';
          angular.module('material.components.datepicker').directive('mdCalendarMonth', calendarDirective);
          var TBODY_HEIGHT = 265;
          var TBODY_SINGLE_ROW_HEIGHT = 45;
          function calendarDirective() {
            return {
              template: '<table aria-hidden="true" class="md-calendar-day-header"><thead></thead></table>' + '<div class="md-calendar-scroll-mask">' + '<md-virtual-repeat-container class="md-calendar-scroll-container" ' + 'md-offset-size="' + (TBODY_SINGLE_ROW_HEIGHT - TBODY_HEIGHT) + '">' + '<table role="grid" tabindex="0" class="md-calendar" aria-readonly="true">' + '<tbody ' + 'md-calendar-month-body ' + 'role="rowgroup" ' + 'md-virtual-repeat="i in monthCtrl.items" ' + 'md-month-offset="$index" ' + 'class="md-calendar-month" ' + 'md-start-index="monthCtrl.getSelectedMonthIndex()" ' + 'md-item-size="' + TBODY_HEIGHT + '"></tbody>' + '</table>' + '</md-virtual-repeat-container>' + '</div>',
              require: ['^^mdCalendar', 'mdCalendarMonth'],
              controller: CalendarMonthCtrl,
              controllerAs: 'monthCtrl',
              bindToController: true,
              link: function(scope, element, attrs, controllers) {
                var calendarCtrl = controllers[0];
                var monthCtrl = controllers[1];
                monthCtrl.initialize(calendarCtrl);
              }
            };
          }
          function CalendarMonthCtrl($element, $scope, $animate, $q, $$mdDateUtil, $mdDateLocale) {
            this.$element = $element;
            this.$scope = $scope;
            this.$animate = $animate;
            this.$q = $q;
            this.dateUtil = $$mdDateUtil;
            this.dateLocale = $mdDateLocale;
            this.calendarScroller = $element[0].querySelector('.md-virtual-repeat-scroller');
            this.firstRenderableDate = null;
            this.isInitialized = false;
            this.isMonthTransitionInProgress = false;
            var self = this;
            this.cellClickHandler = function() {
              var timestamp = $$mdDateUtil.getTimestampFromNode(this);
              self.$scope.$apply(function() {
                self.calendarCtrl.setNgModelValue(timestamp);
              });
            };
            this.headerClickHandler = function() {
              self.calendarCtrl.setCurrentView('year', $$mdDateUtil.getTimestampFromNode(this));
            };
          }
          CalendarMonthCtrl.$inject = ["$element", "$scope", "$animate", "$q", "$$mdDateUtil", "$mdDateLocale"];
          CalendarMonthCtrl.prototype.initialize = function(calendarCtrl) {
            var minDate = calendarCtrl.minDate;
            var maxDate = calendarCtrl.maxDate;
            this.calendarCtrl = calendarCtrl;
            this.items = {length: 2000};
            if (maxDate && minDate) {
              var numMonths = this.dateUtil.getMonthDistance(minDate, maxDate) + 1;
              numMonths = Math.max(numMonths, 1);
              numMonths += 1;
              this.items.length = numMonths;
            }
            this.firstRenderableDate = this.dateUtil.incrementMonths(calendarCtrl.today, -this.items.length / 2);
            if (minDate && minDate > this.firstRenderableDate) {
              this.firstRenderableDate = minDate;
            } else if (maxDate) {
              var monthDifference = this.items.length - 2;
              this.firstRenderableDate = this.dateUtil.incrementMonths(maxDate, -(this.items.length - 2));
            }
            this.attachScopeListeners();
            calendarCtrl.ngModelCtrl && calendarCtrl.ngModelCtrl.$render();
          };
          CalendarMonthCtrl.prototype.getSelectedMonthIndex = function() {
            var calendarCtrl = this.calendarCtrl;
            return this.dateUtil.getMonthDistance(this.firstRenderableDate, calendarCtrl.displayDate || calendarCtrl.selectedDate || calendarCtrl.today);
          };
          CalendarMonthCtrl.prototype.changeSelectedDate = function(date) {
            var self = this;
            var calendarCtrl = self.calendarCtrl;
            var previousSelectedDate = calendarCtrl.selectedDate;
            calendarCtrl.selectedDate = date;
            this.changeDisplayDate(date).then(function() {
              var selectedDateClass = calendarCtrl.SELECTED_DATE_CLASS;
              var namespace = 'month';
              if (previousSelectedDate) {
                var prevDateCell = document.getElementById(calendarCtrl.getDateId(previousSelectedDate, namespace));
                if (prevDateCell) {
                  prevDateCell.classList.remove(selectedDateClass);
                  prevDateCell.setAttribute('aria-selected', 'false');
                }
              }
              if (date) {
                var dateCell = document.getElementById(calendarCtrl.getDateId(date, namespace));
                if (dateCell) {
                  dateCell.classList.add(selectedDateClass);
                  dateCell.setAttribute('aria-selected', 'true');
                }
              }
            });
          };
          CalendarMonthCtrl.prototype.changeDisplayDate = function(date) {
            if (!this.isInitialized) {
              this.buildWeekHeader();
              this.calendarCtrl.hideVerticalScrollbar(this);
              this.isInitialized = true;
              return this.$q.when();
            }
            if (!this.dateUtil.isValidDate(date) || this.isMonthTransitionInProgress) {
              return this.$q.when();
            }
            this.isMonthTransitionInProgress = true;
            var animationPromise = this.animateDateChange(date);
            this.calendarCtrl.displayDate = date;
            var self = this;
            animationPromise.then(function() {
              self.isMonthTransitionInProgress = false;
            });
            return animationPromise;
          };
          CalendarMonthCtrl.prototype.animateDateChange = function(date) {
            if (this.dateUtil.isValidDate(date)) {
              var monthDistance = this.dateUtil.getMonthDistance(this.firstRenderableDate, date);
              this.calendarScroller.scrollTop = monthDistance * TBODY_HEIGHT;
            }
            return this.$q.when();
          };
          CalendarMonthCtrl.prototype.buildWeekHeader = function() {
            var firstDayOfWeek = this.dateLocale.firstDayOfWeek;
            var shortDays = this.dateLocale.shortDays;
            var row = document.createElement('tr');
            for (var i = 0; i < 7; i++) {
              var th = document.createElement('th');
              th.textContent = shortDays[(i + firstDayOfWeek) % 7];
              row.appendChild(th);
            }
            this.$element.find('thead').append(row);
          };
          CalendarMonthCtrl.prototype.attachScopeListeners = function() {
            var self = this;
            self.$scope.$on('md-calendar-parent-changed', function(event, value) {
              self.changeSelectedDate(value);
            });
            self.$scope.$on('md-calendar-parent-action', angular.bind(this, this.handleKeyEvent));
          };
          CalendarMonthCtrl.prototype.handleKeyEvent = function(event, action) {
            var calendarCtrl = this.calendarCtrl;
            var displayDate = calendarCtrl.displayDate;
            if (action === 'select') {
              calendarCtrl.setNgModelValue(displayDate);
            } else {
              var date = null;
              var dateUtil = this.dateUtil;
              switch (action) {
                case 'move-right':
                  date = dateUtil.incrementDays(displayDate, 1);
                  break;
                case 'move-left':
                  date = dateUtil.incrementDays(displayDate, -1);
                  break;
                case 'move-page-down':
                  date = dateUtil.incrementMonths(displayDate, 1);
                  break;
                case 'move-page-up':
                  date = dateUtil.incrementMonths(displayDate, -1);
                  break;
                case 'move-row-down':
                  date = dateUtil.incrementDays(displayDate, 7);
                  break;
                case 'move-row-up':
                  date = dateUtil.incrementDays(displayDate, -7);
                  break;
                case 'start':
                  date = dateUtil.getFirstDateOfMonth(displayDate);
                  break;
                case 'end':
                  date = dateUtil.getLastDateOfMonth(displayDate);
                  break;
              }
              if (date) {
                date = this.dateUtil.clampDate(date, calendarCtrl.minDate, calendarCtrl.maxDate);
                this.changeDisplayDate(date).then(function() {
                  calendarCtrl.focus(date);
                });
              }
            }
          };
        })();
      })();
      (function() {
        "use strict";
        (function() {
          'use strict';
          angular.module('material.components.datepicker').directive('mdCalendarMonthBody', mdCalendarMonthBodyDirective);
          function mdCalendarMonthBodyDirective() {
            return {
              require: ['^^mdCalendar', '^^mdCalendarMonth', 'mdCalendarMonthBody'],
              scope: {offset: '=mdMonthOffset'},
              controller: CalendarMonthBodyCtrl,
              controllerAs: 'mdMonthBodyCtrl',
              bindToController: true,
              link: function(scope, element, attrs, controllers) {
                var calendarCtrl = controllers[0];
                var monthCtrl = controllers[1];
                var monthBodyCtrl = controllers[2];
                monthBodyCtrl.calendarCtrl = calendarCtrl;
                monthBodyCtrl.monthCtrl = monthCtrl;
                monthBodyCtrl.generateContent();
                scope.$watch(function() {
                  return monthBodyCtrl.offset;
                }, function(offset, oldOffset) {
                  if (offset != oldOffset) {
                    monthBodyCtrl.generateContent();
                  }
                });
              }
            };
          }
          function CalendarMonthBodyCtrl($element, $$mdDateUtil, $mdDateLocale) {
            this.$element = $element;
            this.dateUtil = $$mdDateUtil;
            this.dateLocale = $mdDateLocale;
            this.monthCtrl = null;
            this.calendarCtrl = null;
            this.offset = null;
            this.focusAfterAppend = null;
          }
          CalendarMonthBodyCtrl.$inject = ["$element", "$$mdDateUtil", "$mdDateLocale"];
          CalendarMonthBodyCtrl.prototype.generateContent = function() {
            var date = this.dateUtil.incrementMonths(this.monthCtrl.firstRenderableDate, this.offset);
            this.$element.empty();
            this.$element.append(this.buildCalendarForMonth(date));
            if (this.focusAfterAppend) {
              this.focusAfterAppend.classList.add(this.calendarCtrl.FOCUSED_DATE_CLASS);
              this.focusAfterAppend.focus();
              this.focusAfterAppend = null;
            }
          };
          CalendarMonthBodyCtrl.prototype.buildDateCell = function(opt_date) {
            var monthCtrl = this.monthCtrl;
            var calendarCtrl = this.calendarCtrl;
            var cell = document.createElement('td');
            cell.tabIndex = -1;
            cell.classList.add('md-calendar-date');
            cell.setAttribute('role', 'gridcell');
            if (opt_date) {
              cell.setAttribute('tabindex', '-1');
              cell.setAttribute('aria-label', this.dateLocale.longDateFormatter(opt_date));
              cell.id = calendarCtrl.getDateId(opt_date, 'month');
              cell.setAttribute('data-timestamp', opt_date.getTime());
              if (this.dateUtil.isSameDay(opt_date, calendarCtrl.today)) {
                cell.classList.add(calendarCtrl.TODAY_CLASS);
              }
              if (this.dateUtil.isValidDate(calendarCtrl.selectedDate) && this.dateUtil.isSameDay(opt_date, calendarCtrl.selectedDate)) {
                cell.classList.add(calendarCtrl.SELECTED_DATE_CLASS);
                cell.setAttribute('aria-selected', 'true');
              }
              var cellText = this.dateLocale.dates[opt_date.getDate()];
              if (this.isDateEnabled(opt_date)) {
                var selectionIndicator = document.createElement('span');
                selectionIndicator.classList.add('md-calendar-date-selection-indicator');
                selectionIndicator.textContent = cellText;
                cell.appendChild(selectionIndicator);
                cell.addEventListener('click', monthCtrl.cellClickHandler);
                if (calendarCtrl.displayDate && this.dateUtil.isSameDay(opt_date, calendarCtrl.displayDate)) {
                  this.focusAfterAppend = cell;
                }
              } else {
                cell.classList.add('md-calendar-date-disabled');
                cell.textContent = cellText;
              }
            }
            return cell;
          };
          CalendarMonthBodyCtrl.prototype.isDateEnabled = function(opt_date) {
            return this.dateUtil.isDateWithinRange(opt_date, this.calendarCtrl.minDate, this.calendarCtrl.maxDate) && (!angular.isFunction(this.calendarCtrl.dateFilter) || this.calendarCtrl.dateFilter(opt_date));
          };
          CalendarMonthBodyCtrl.prototype.buildDateRow = function(rowNumber) {
            var row = document.createElement('tr');
            row.setAttribute('role', 'row');
            row.setAttribute('aria-label', this.dateLocale.weekNumberFormatter(rowNumber));
            return row;
          };
          CalendarMonthBodyCtrl.prototype.buildCalendarForMonth = function(opt_dateInMonth) {
            var date = this.dateUtil.isValidDate(opt_dateInMonth) ? opt_dateInMonth : new Date();
            var firstDayOfMonth = this.dateUtil.getFirstDateOfMonth(date);
            var firstDayOfTheWeek = this.getLocaleDay_(firstDayOfMonth);
            var numberOfDaysInMonth = this.dateUtil.getNumberOfDaysInMonth(date);
            var monthBody = document.createDocumentFragment();
            var rowNumber = 1;
            var row = this.buildDateRow(rowNumber);
            monthBody.appendChild(row);
            var isFinalMonth = this.offset === this.monthCtrl.items.length - 1;
            var blankCellOffset = 0;
            var monthLabelCell = document.createElement('td');
            monthLabelCell.textContent = this.dateLocale.monthHeaderFormatter(date);
            monthLabelCell.classList.add('md-calendar-month-label');
            if (this.calendarCtrl.maxDate && firstDayOfMonth > this.calendarCtrl.maxDate) {
              monthLabelCell.classList.add('md-calendar-month-label-disabled');
            } else {
              monthLabelCell.addEventListener('click', this.monthCtrl.headerClickHandler);
              monthLabelCell.setAttribute('data-timestamp', firstDayOfMonth.getTime());
              monthLabelCell.setAttribute('aria-label', this.dateLocale.monthFormatter(date));
            }
            if (firstDayOfTheWeek <= 2) {
              monthLabelCell.setAttribute('colspan', '7');
              var monthLabelRow = this.buildDateRow();
              monthLabelRow.appendChild(monthLabelCell);
              monthBody.insertBefore(monthLabelRow, row);
              if (isFinalMonth) {
                return monthBody;
              }
            } else {
              blankCellOffset = 2;
              monthLabelCell.setAttribute('colspan', '2');
              row.appendChild(monthLabelCell);
            }
            for (var i = blankCellOffset; i < firstDayOfTheWeek; i++) {
              row.appendChild(this.buildDateCell());
            }
            var dayOfWeek = firstDayOfTheWeek;
            var iterationDate = firstDayOfMonth;
            for (var d = 1; d <= numberOfDaysInMonth; d++) {
              if (dayOfWeek === 7) {
                if (isFinalMonth) {
                  return monthBody;
                }
                dayOfWeek = 0;
                rowNumber++;
                row = this.buildDateRow(rowNumber);
                monthBody.appendChild(row);
              }
              iterationDate.setDate(d);
              var cell = this.buildDateCell(iterationDate);
              row.appendChild(cell);
              dayOfWeek++;
            }
            while (row.childNodes.length < 7) {
              row.appendChild(this.buildDateCell());
            }
            while (monthBody.childNodes.length < 6) {
              var whitespaceRow = this.buildDateRow();
              for (var j = 0; j < 7; j++) {
                whitespaceRow.appendChild(this.buildDateCell());
              }
              monthBody.appendChild(whitespaceRow);
            }
            return monthBody;
          };
          CalendarMonthBodyCtrl.prototype.getLocaleDay_ = function(date) {
            return (date.getDay() + (7 - this.dateLocale.firstDayOfWeek)) % 7;
          };
        })();
      })();
      (function() {
        "use strict";
        (function() {
          'use strict';
          angular.module('material.components.datepicker').directive('mdCalendarYear', calendarDirective);
          var TBODY_HEIGHT = 88;
          function calendarDirective() {
            return {
              template: '<div class="md-calendar-scroll-mask">' + '<md-virtual-repeat-container class="md-calendar-scroll-container">' + '<table role="grid" tabindex="0" class="md-calendar" aria-readonly="true">' + '<tbody ' + 'md-calendar-year-body ' + 'role="rowgroup" ' + 'md-virtual-repeat="i in yearCtrl.items" ' + 'md-year-offset="$index" class="md-calendar-year" ' + 'md-start-index="yearCtrl.getFocusedYearIndex()" ' + 'md-item-size="' + TBODY_HEIGHT + '"></tbody>' + '</table>' + '</md-virtual-repeat-container>' + '</div>',
              require: ['^^mdCalendar', 'mdCalendarYear'],
              controller: CalendarYearCtrl,
              controllerAs: 'yearCtrl',
              bindToController: true,
              link: function(scope, element, attrs, controllers) {
                var calendarCtrl = controllers[0];
                var yearCtrl = controllers[1];
                yearCtrl.initialize(calendarCtrl);
              }
            };
          }
          function CalendarYearCtrl($element, $scope, $animate, $q, $$mdDateUtil, $timeout) {
            this.$element = $element;
            this.$scope = $scope;
            this.$animate = $animate;
            this.$q = $q;
            this.dateUtil = $$mdDateUtil;
            this.$timeout = $timeout;
            this.calendarScroller = $element[0].querySelector('.md-virtual-repeat-scroller');
            this.firstRenderableDate = null;
            this.isInitialized = false;
            this.isMonthTransitionInProgress = false;
            var self = this;
            this.cellClickHandler = function() {
              self.calendarCtrl.setCurrentView('month', $$mdDateUtil.getTimestampFromNode(this));
            };
          }
          CalendarYearCtrl.$inject = ["$element", "$scope", "$animate", "$q", "$$mdDateUtil", "$timeout"];
          CalendarYearCtrl.prototype.initialize = function(calendarCtrl) {
            var minDate = calendarCtrl.minDate;
            var maxDate = calendarCtrl.maxDate;
            this.calendarCtrl = calendarCtrl;
            this.items = {length: 400};
            if (maxDate && minDate) {
              var numYears = this.dateUtil.getYearDistance(minDate, maxDate) + 1;
              this.items.length = Math.max(numYears, 1);
            }
            this.firstRenderableDate = this.dateUtil.incrementYears(calendarCtrl.today, -(this.items.length / 2));
            if (minDate && minDate > this.firstRenderableDate) {
              this.firstRenderableDate = minDate;
            } else if (maxDate) {
              this.firstRenderableDate = this.dateUtil.incrementMonths(maxDate, -(this.items.length - 1));
            }
            if (minDate || maxDate)
              this.$timeout();
            this.attachScopeListeners();
            calendarCtrl.ngModelCtrl && calendarCtrl.ngModelCtrl.$render();
          };
          CalendarYearCtrl.prototype.getFocusedYearIndex = function() {
            var calendarCtrl = this.calendarCtrl;
            return this.dateUtil.getYearDistance(this.firstRenderableDate, calendarCtrl.displayDate || calendarCtrl.selectedDate || calendarCtrl.today);
          };
          CalendarYearCtrl.prototype.changeDate = function(date) {
            if (!this.isInitialized) {
              this.calendarCtrl.hideVerticalScrollbar(this);
              this.isInitialized = true;
              return this.$q.when();
            } else if (this.dateUtil.isValidDate(date) && !this.isMonthTransitionInProgress) {
              var self = this;
              var animationPromise = this.animateDateChange(date);
              self.isMonthTransitionInProgress = true;
              self.calendarCtrl.displayDate = date;
              return animationPromise.then(function() {
                self.isMonthTransitionInProgress = false;
              });
            }
          };
          CalendarYearCtrl.prototype.animateDateChange = function(date) {
            if (this.dateUtil.isValidDate(date)) {
              var monthDistance = this.dateUtil.getYearDistance(this.firstRenderableDate, date);
              this.calendarScroller.scrollTop = monthDistance * TBODY_HEIGHT;
            }
            return this.$q.when();
          };
          CalendarYearCtrl.prototype.handleKeyEvent = function(event, action) {
            var calendarCtrl = this.calendarCtrl;
            var displayDate = calendarCtrl.displayDate;
            if (action === 'select') {
              this.changeDate(displayDate).then(function() {
                calendarCtrl.setCurrentView('month', displayDate);
                calendarCtrl.focus(displayDate);
              });
            } else {
              var date = null;
              var dateUtil = this.dateUtil;
              switch (action) {
                case 'move-right':
                  date = dateUtil.incrementMonths(displayDate, 1);
                  break;
                case 'move-left':
                  date = dateUtil.incrementMonths(displayDate, -1);
                  break;
                case 'move-row-down':
                  date = dateUtil.incrementMonths(displayDate, 6);
                  break;
                case 'move-row-up':
                  date = dateUtil.incrementMonths(displayDate, -6);
                  break;
              }
              if (date) {
                var min = calendarCtrl.minDate ? dateUtil.incrementMonths(dateUtil.getFirstDateOfMonth(calendarCtrl.minDate), 1) : null;
                var max = calendarCtrl.maxDate ? dateUtil.getFirstDateOfMonth(calendarCtrl.maxDate) : null;
                date = dateUtil.getFirstDateOfMonth(this.dateUtil.clampDate(date, min, max));
                this.changeDate(date).then(function() {
                  calendarCtrl.focus(date);
                });
              }
            }
          };
          CalendarYearCtrl.prototype.attachScopeListeners = function() {
            var self = this;
            self.$scope.$on('md-calendar-parent-changed', function(event, value) {
              self.changeDate(value);
            });
            self.$scope.$on('md-calendar-parent-action', angular.bind(self, self.handleKeyEvent));
          };
        })();
      })();
      (function() {
        "use strict";
        (function() {
          'use strict';
          angular.module('material.components.datepicker').directive('mdCalendarYearBody', mdCalendarYearDirective);
          function mdCalendarYearDirective() {
            return {
              require: ['^^mdCalendar', '^^mdCalendarYear', 'mdCalendarYearBody'],
              scope: {offset: '=mdYearOffset'},
              controller: CalendarYearBodyCtrl,
              controllerAs: 'mdYearBodyCtrl',
              bindToController: true,
              link: function(scope, element, attrs, controllers) {
                var calendarCtrl = controllers[0];
                var yearCtrl = controllers[1];
                var yearBodyCtrl = controllers[2];
                yearBodyCtrl.calendarCtrl = calendarCtrl;
                yearBodyCtrl.yearCtrl = yearCtrl;
                yearBodyCtrl.generateContent();
                scope.$watch(function() {
                  return yearBodyCtrl.offset;
                }, function(offset, oldOffset) {
                  if (offset != oldOffset) {
                    yearBodyCtrl.generateContent();
                  }
                });
              }
            };
          }
          function CalendarYearBodyCtrl($element, $$mdDateUtil, $mdDateLocale) {
            this.$element = $element;
            this.dateUtil = $$mdDateUtil;
            this.dateLocale = $mdDateLocale;
            this.calendarCtrl = null;
            this.yearCtrl = null;
            this.offset = null;
            this.focusAfterAppend = null;
          }
          CalendarYearBodyCtrl.$inject = ["$element", "$$mdDateUtil", "$mdDateLocale"];
          CalendarYearBodyCtrl.prototype.generateContent = function() {
            var date = this.dateUtil.incrementYears(this.yearCtrl.firstRenderableDate, this.offset);
            this.$element.empty();
            this.$element.append(this.buildCalendarForYear(date));
            if (this.focusAfterAppend) {
              this.focusAfterAppend.classList.add(this.calendarCtrl.FOCUSED_DATE_CLASS);
              this.focusAfterAppend.focus();
              this.focusAfterAppend = null;
            }
          };
          CalendarYearBodyCtrl.prototype.buildMonthCell = function(year, month) {
            var calendarCtrl = this.calendarCtrl;
            var yearCtrl = this.yearCtrl;
            var cell = this.buildBlankCell();
            var firstOfMonth = new Date(year, month, 1);
            cell.setAttribute('aria-label', this.dateLocale.monthFormatter(firstOfMonth));
            cell.id = calendarCtrl.getDateId(firstOfMonth, 'year');
            cell.setAttribute('data-timestamp', firstOfMonth.getTime());
            if (this.dateUtil.isSameMonthAndYear(firstOfMonth, calendarCtrl.today)) {
              cell.classList.add(calendarCtrl.TODAY_CLASS);
            }
            if (this.dateUtil.isValidDate(calendarCtrl.selectedDate) && this.dateUtil.isSameMonthAndYear(firstOfMonth, calendarCtrl.selectedDate)) {
              cell.classList.add(calendarCtrl.SELECTED_DATE_CLASS);
              cell.setAttribute('aria-selected', 'true');
            }
            var cellText = this.dateLocale.shortMonths[month];
            if (this.dateUtil.isDateWithinRange(firstOfMonth, calendarCtrl.minDate, calendarCtrl.maxDate)) {
              var selectionIndicator = document.createElement('span');
              selectionIndicator.classList.add('md-calendar-date-selection-indicator');
              selectionIndicator.textContent = cellText;
              cell.appendChild(selectionIndicator);
              cell.addEventListener('click', yearCtrl.cellClickHandler);
              if (calendarCtrl.displayDate && this.dateUtil.isSameMonthAndYear(firstOfMonth, calendarCtrl.displayDate)) {
                this.focusAfterAppend = cell;
              }
            } else {
              cell.classList.add('md-calendar-date-disabled');
              cell.textContent = cellText;
            }
            return cell;
          };
          CalendarYearBodyCtrl.prototype.buildBlankCell = function() {
            var cell = document.createElement('td');
            cell.tabIndex = -1;
            cell.classList.add('md-calendar-date');
            cell.setAttribute('role', 'gridcell');
            cell.setAttribute('tabindex', '-1');
            return cell;
          };
          CalendarYearBodyCtrl.prototype.buildCalendarForYear = function(date) {
            var year = date.getFullYear();
            var yearBody = document.createDocumentFragment();
            var monthCell,
                i;
            var firstRow = document.createElement('tr');
            var labelCell = document.createElement('td');
            labelCell.className = 'md-calendar-month-label';
            labelCell.textContent = year;
            firstRow.appendChild(labelCell);
            for (i = 0; i < 6; i++) {
              firstRow.appendChild(this.buildMonthCell(year, i));
            }
            yearBody.appendChild(firstRow);
            var secondRow = document.createElement('tr');
            secondRow.appendChild(this.buildBlankCell());
            for (i = 6; i < 12; i++) {
              secondRow.appendChild(this.buildMonthCell(year, i));
            }
            yearBody.appendChild(secondRow);
            return yearBody;
          };
        })();
      })();
      (function() {
        "use strict";
        (function() {
          'use strict';
          angular.module('material.components.datepicker').config(["$provide", function($provide) {
            function DateLocaleProvider() {
              this.months = null;
              this.shortMonths = null;
              this.days = null;
              this.shortDays = null;
              this.dates = null;
              this.firstDayOfWeek = 0;
              this.formatDate = null;
              this.parseDate = null;
              this.monthHeaderFormatter = null;
              this.weekNumberFormatter = null;
              this.longDateFormatter = null;
              this.msgCalendar = '';
              this.msgOpenCalendar = '';
            }
            DateLocaleProvider.prototype.$get = function($locale, $filter) {
              function defaultFormatDate(date) {
                if (!date) {
                  return '';
                }
                var localeTime = date.toLocaleTimeString();
                var formatDate = date;
                if (date.getHours() == 0 && (localeTime.indexOf('11:') !== -1 || localeTime.indexOf('23:') !== -1)) {
                  formatDate = new Date(date.getFullYear(), date.getMonth(), date.getDate(), 1, 0, 0);
                }
                return $filter('date')(formatDate, 'M/d/yyyy');
              }
              function defaultParseDate(dateString) {
                return new Date(dateString);
              }
              function defaultIsDateComplete(dateString) {
                dateString = dateString.trim();
                var re = /^(([a-zA-Z]{3,}|[0-9]{1,4})([ \.,]+|[\/\-])){2}([a-zA-Z]{3,}|[0-9]{1,4})$/;
                return re.test(dateString);
              }
              function defaultMonthHeaderFormatter(date) {
                return service.shortMonths[date.getMonth()] + ' ' + date.getFullYear();
              }
              function defaultMonthFormatter(date) {
                return service.months[date.getMonth()] + ' ' + date.getFullYear();
              }
              function defaultWeekNumberFormatter(number) {
                return 'Week ' + number;
              }
              function defaultLongDateFormatter(date) {
                return [service.days[date.getDay()], service.months[date.getMonth()], service.dates[date.getDate()], date.getFullYear()].join(' ');
              }
              var defaultShortDays = $locale.DATETIME_FORMATS.DAY.map(function(day) {
                return day[0];
              });
              var defaultDates = Array(32);
              for (var i = 1; i <= 31; i++) {
                defaultDates[i] = i;
              }
              var defaultMsgCalendar = 'Calendar';
              var defaultMsgOpenCalendar = 'Open calendar';
              var service = {
                months: this.months || $locale.DATETIME_FORMATS.MONTH,
                shortMonths: this.shortMonths || $locale.DATETIME_FORMATS.SHORTMONTH,
                days: this.days || $locale.DATETIME_FORMATS.DAY,
                shortDays: this.shortDays || defaultShortDays,
                dates: this.dates || defaultDates,
                firstDayOfWeek: this.firstDayOfWeek || 0,
                formatDate: this.formatDate || defaultFormatDate,
                parseDate: this.parseDate || defaultParseDate,
                isDateComplete: this.isDateComplete || defaultIsDateComplete,
                monthHeaderFormatter: this.monthHeaderFormatter || defaultMonthHeaderFormatter,
                monthFormatter: this.monthFormatter || defaultMonthFormatter,
                weekNumberFormatter: this.weekNumberFormatter || defaultWeekNumberFormatter,
                longDateFormatter: this.longDateFormatter || defaultLongDateFormatter,
                msgCalendar: this.msgCalendar || defaultMsgCalendar,
                msgOpenCalendar: this.msgOpenCalendar || defaultMsgOpenCalendar
              };
              return service;
            };
            DateLocaleProvider.prototype.$get.$inject = ["$locale", "$filter"];
            $provide.provider('$mdDateLocale', new DateLocaleProvider());
          }]);
        })();
      })();
      (function() {
        "use strict";
        (function() {
          'use strict';
          angular.module('material.components.datepicker').factory('$$mdDateUtil', function() {
            return {
              getFirstDateOfMonth: getFirstDateOfMonth,
              getNumberOfDaysInMonth: getNumberOfDaysInMonth,
              getDateInNextMonth: getDateInNextMonth,
              getDateInPreviousMonth: getDateInPreviousMonth,
              isInNextMonth: isInNextMonth,
              isInPreviousMonth: isInPreviousMonth,
              getDateMidpoint: getDateMidpoint,
              isSameMonthAndYear: isSameMonthAndYear,
              getWeekOfMonth: getWeekOfMonth,
              incrementDays: incrementDays,
              incrementMonths: incrementMonths,
              getLastDateOfMonth: getLastDateOfMonth,
              isSameDay: isSameDay,
              getMonthDistance: getMonthDistance,
              isValidDate: isValidDate,
              setDateTimeToMidnight: setDateTimeToMidnight,
              createDateAtMidnight: createDateAtMidnight,
              isDateWithinRange: isDateWithinRange,
              incrementYears: incrementYears,
              getYearDistance: getYearDistance,
              clampDate: clampDate,
              getTimestampFromNode: getTimestampFromNode
            };
            function getFirstDateOfMonth(date) {
              return new Date(date.getFullYear(), date.getMonth(), 1);
            }
            function getNumberOfDaysInMonth(date) {
              return new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();
            }
            function getDateInNextMonth(date) {
              return new Date(date.getFullYear(), date.getMonth() + 1, 1);
            }
            function getDateInPreviousMonth(date) {
              return new Date(date.getFullYear(), date.getMonth() - 1, 1);
            }
            function isSameMonthAndYear(d1, d2) {
              return d1.getFullYear() === d2.getFullYear() && d1.getMonth() === d2.getMonth();
            }
            function isSameDay(d1, d2) {
              return d1.getDate() == d2.getDate() && isSameMonthAndYear(d1, d2);
            }
            function isInNextMonth(startDate, endDate) {
              var nextMonth = getDateInNextMonth(startDate);
              return isSameMonthAndYear(nextMonth, endDate);
            }
            function isInPreviousMonth(startDate, endDate) {
              var previousMonth = getDateInPreviousMonth(startDate);
              return isSameMonthAndYear(endDate, previousMonth);
            }
            function getDateMidpoint(d1, d2) {
              return createDateAtMidnight((d1.getTime() + d2.getTime()) / 2);
            }
            function getWeekOfMonth(date) {
              var firstDayOfMonth = getFirstDateOfMonth(date);
              return Math.floor((firstDayOfMonth.getDay() + date.getDate() - 1) / 7);
            }
            function incrementDays(date, numberOfDays) {
              return new Date(date.getFullYear(), date.getMonth(), date.getDate() + numberOfDays);
            }
            function incrementMonths(date, numberOfMonths) {
              var dateInTargetMonth = new Date(date.getFullYear(), date.getMonth() + numberOfMonths, 1);
              var numberOfDaysInMonth = getNumberOfDaysInMonth(dateInTargetMonth);
              if (numberOfDaysInMonth < date.getDate()) {
                dateInTargetMonth.setDate(numberOfDaysInMonth);
              } else {
                dateInTargetMonth.setDate(date.getDate());
              }
              return dateInTargetMonth;
            }
            function getMonthDistance(start, end) {
              return (12 * (end.getFullYear() - start.getFullYear())) + (end.getMonth() - start.getMonth());
            }
            function getLastDateOfMonth(date) {
              return new Date(date.getFullYear(), date.getMonth(), getNumberOfDaysInMonth(date));
            }
            function isValidDate(date) {
              return date != null && date.getTime && !isNaN(date.getTime());
            }
            function setDateTimeToMidnight(date) {
              if (isValidDate(date)) {
                date.setHours(0, 0, 0, 0);
              }
            }
            function createDateAtMidnight(opt_value) {
              var date;
              if (angular.isUndefined(opt_value)) {
                date = new Date();
              } else {
                date = new Date(opt_value);
              }
              setDateTimeToMidnight(date);
              return date;
            }
            function isDateWithinRange(date, minDate, maxDate) {
              var dateAtMidnight = createDateAtMidnight(date);
              var minDateAtMidnight = isValidDate(minDate) ? createDateAtMidnight(minDate) : null;
              var maxDateAtMidnight = isValidDate(maxDate) ? createDateAtMidnight(maxDate) : null;
              return (!minDateAtMidnight || minDateAtMidnight <= dateAtMidnight) && (!maxDateAtMidnight || maxDateAtMidnight >= dateAtMidnight);
            }
            function incrementYears(date, numberOfYears) {
              return incrementMonths(date, numberOfYears * 12);
            }
            function getYearDistance(start, end) {
              return end.getFullYear() - start.getFullYear();
            }
            function clampDate(date, minDate, maxDate) {
              var boundDate = date;
              if (minDate && date < minDate) {
                boundDate = new Date(minDate.getTime());
              }
              if (maxDate && date > maxDate) {
                boundDate = new Date(maxDate.getTime());
              }
              return boundDate;
            }
            function getTimestampFromNode(node) {
              if (node && node.hasAttribute('data-timestamp')) {
                return Number(node.getAttribute('data-timestamp'));
              }
            }
          });
        })();
      })();
      (function() {
        "use strict";
        (function() {
          'use strict';
          angular.module('material.components.datepicker').directive('mdDatepicker', datePickerDirective);
          function datePickerDirective($$mdSvgRegistry) {
            return {
              template: function(tElement, tAttrs) {
                var hiddenIcons = tAttrs.mdHideIcons;
                var calendarButton = (hiddenIcons === 'all' || hiddenIcons === 'calendar') ? '' : '<md-button class="md-datepicker-button md-icon-button" type="button" ' + 'tabindex="-1" aria-hidden="true" ' + 'ng-click="ctrl.openCalendarPane($event)">' + '<md-icon class="md-datepicker-calendar-icon" aria-label="md-calendar" ' + 'md-svg-src="' + $$mdSvgRegistry.mdCalendar + '"></md-icon>' + '</md-button>';
                var triangleButton = (hiddenIcons === 'all' || hiddenIcons === 'triangle') ? '' : '<md-button type="button" md-no-ink ' + 'class="md-datepicker-triangle-button md-icon-button" ' + 'ng-click="ctrl.openCalendarPane($event)" ' + 'aria-label="{{::ctrl.dateLocale.msgOpenCalendar}}">' + '<div class="md-datepicker-expand-triangle"></div>' + '</md-button>';
                return '' + calendarButton + '<div class="md-datepicker-input-container" ' + 'ng-class="{\'md-datepicker-focused\': ctrl.isFocused}">' + '<input class="md-datepicker-input" aria-haspopup="true" ' + 'ng-focus="ctrl.setFocused(true)" ng-blur="ctrl.setFocused(false)">' + triangleButton + '</div>' + '<div class="md-datepicker-calendar-pane md-whiteframe-z1">' + '<div class="md-datepicker-input-mask">' + '<div class="md-datepicker-input-mask-opaque"></div>' + '</div>' + '<div class="md-datepicker-calendar">' + '<md-calendar role="dialog" aria-label="{{::ctrl.dateLocale.msgCalendar}}" ' + 'md-min-date="ctrl.minDate" md-max-date="ctrl.maxDate"' + 'md-date-filter="ctrl.dateFilter"' + 'ng-model="ctrl.date" ng-if="ctrl.isCalendarOpen">' + '</md-calendar>' + '</div>' + '</div>';
              },
              require: ['ngModel', 'mdDatepicker', '?^mdInputContainer'],
              scope: {
                minDate: '=mdMinDate',
                maxDate: '=mdMaxDate',
                placeholder: '@mdPlaceholder',
                dateFilter: '=mdDateFilter',
                isOpen: '=?mdIsOpen'
              },
              controller: DatePickerCtrl,
              controllerAs: 'ctrl',
              bindToController: true,
              link: function(scope, element, attr, controllers) {
                var ngModelCtrl = controllers[0];
                var mdDatePickerCtrl = controllers[1];
                var mdInputContainer = controllers[2];
                mdDatePickerCtrl.configureNgModel(ngModelCtrl, mdInputContainer);
                if (mdInputContainer) {
                  var spacer = element[0].querySelector('.md-errors-spacer');
                  if (spacer) {
                    element.after(angular.element('<div>').append(spacer));
                  }
                  mdInputContainer.setHasPlaceholder(attr.mdPlaceholder);
                  mdInputContainer.element.addClass(INPUT_CONTAINER_CLASS);
                  mdInputContainer.input = element;
                  if (!mdInputContainer.label) {
                    $mdAria.expect(element, 'aria-label', attr.mdPlaceholder);
                  }
                  scope.$watch(mdInputContainer.isErrorGetter || function() {
                    return ngModelCtrl.$invalid && ngModelCtrl.$touched;
                  }, mdInputContainer.setInvalid);
                }
              }
            };
          }
          datePickerDirective.$inject = ["$$mdSvgRegistry"];
          var EXTRA_INPUT_SIZE = 3;
          var INVALID_CLASS = 'md-datepicker-invalid';
          var OPEN_CLASS = 'md-datepicker-open';
          var INPUT_CONTAINER_CLASS = '_md-datepicker-floating-label';
          var DEFAULT_DEBOUNCE_INTERVAL = 500;
          var CALENDAR_PANE_HEIGHT = 368;
          var CALENDAR_PANE_WIDTH = 360;
          function DatePickerCtrl($scope, $element, $attrs, $compile, $timeout, $window, $mdConstant, $mdTheming, $mdUtil, $mdDateLocale, $$mdDateUtil, $$rAF) {
            this.$compile = $compile;
            this.$timeout = $timeout;
            this.$window = $window;
            this.dateLocale = $mdDateLocale;
            this.dateUtil = $$mdDateUtil;
            this.$mdConstant = $mdConstant;
            this.$mdUtil = $mdUtil;
            this.$$rAF = $$rAF;
            this.documentElement = angular.element(document.documentElement);
            this.ngModelCtrl = null;
            this.inputElement = $element[0].querySelector('input');
            this.ngInputElement = angular.element(this.inputElement);
            this.inputContainer = $element[0].querySelector('.md-datepicker-input-container');
            this.calendarPane = $element[0].querySelector('.md-datepicker-calendar-pane');
            this.calendarButton = $element[0].querySelector('.md-datepicker-button');
            this.inputMask = $element[0].querySelector('.md-datepicker-input-mask-opaque');
            this.$element = $element;
            this.$attrs = $attrs;
            this.$scope = $scope;
            this.date = null;
            this.isFocused = false;
            this.isDisabled;
            this.setDisabled($element[0].disabled || angular.isString($attrs.disabled));
            this.isCalendarOpen = false;
            this.openOnFocus = $attrs.hasOwnProperty('mdOpenOnFocus');
            this.mdInputContainer = null;
            this.calendarPaneOpenedFrom = null;
            this.calendarPane.id = 'md-date-pane' + $mdUtil.nextUid();
            $mdTheming($element);
            $mdTheming(angular.element(this.calendarPane));
            this.bodyClickHandler = angular.bind(this, this.handleBodyClick);
            this.windowResizeHandler = $mdUtil.debounce(angular.bind(this, this.closeCalendarPane), 100);
            if (!$attrs.tabindex) {
              $element.attr('tabindex', '-1');
            }
            this.installPropertyInterceptors();
            this.attachChangeListeners();
            this.attachInteractionListeners();
            var self = this;
            $scope.$on('$destroy', function() {
              self.detachCalendarPane();
            });
            if ($attrs.mdIsOpen) {
              $scope.$watch('ctrl.isOpen', function(shouldBeOpen) {
                if (shouldBeOpen) {
                  self.openCalendarPane({target: self.inputElement});
                } else {
                  self.closeCalendarPane();
                }
              });
            }
          }
          DatePickerCtrl.$inject = ["$scope", "$element", "$attrs", "$compile", "$timeout", "$window", "$mdConstant", "$mdTheming", "$mdUtil", "$mdDateLocale", "$$mdDateUtil", "$$rAF"];
          DatePickerCtrl.prototype.configureNgModel = function(ngModelCtrl, mdInputContainer) {
            this.ngModelCtrl = ngModelCtrl;
            this.mdInputContainer = mdInputContainer;
            var self = this;
            ngModelCtrl.$render = function() {
              var value = self.ngModelCtrl.$viewValue;
              if (value && !(value instanceof Date)) {
                throw Error('The ng-model for md-datepicker must be a Date instance. ' + 'Currently the model is a: ' + (typeof value));
              }
              self.date = value;
              self.inputElement.value = self.dateLocale.formatDate(value);
              self.mdInputContainer && self.mdInputContainer.setHasValue(!!value);
              self.resizeInputElement();
              self.updateErrorState();
            };
          };
          DatePickerCtrl.prototype.attachChangeListeners = function() {
            var self = this;
            self.$scope.$on('md-calendar-change', function(event, date) {
              self.ngModelCtrl.$setViewValue(date);
              self.date = date;
              self.inputElement.value = self.dateLocale.formatDate(date);
              self.mdInputContainer && self.mdInputContainer.setHasValue(!!date);
              self.closeCalendarPane();
              self.resizeInputElement();
              self.updateErrorState();
            });
            self.ngInputElement.on('input', angular.bind(self, self.resizeInputElement));
            self.ngInputElement.on('input', self.$mdUtil.debounce(self.handleInputEvent, DEFAULT_DEBOUNCE_INTERVAL, self));
          };
          DatePickerCtrl.prototype.attachInteractionListeners = function() {
            var self = this;
            var $scope = this.$scope;
            var keyCodes = this.$mdConstant.KEY_CODE;
            self.ngInputElement.on('keydown', function(event) {
              if (event.altKey && event.keyCode == keyCodes.DOWN_ARROW) {
                self.openCalendarPane(event);
                $scope.$digest();
              }
            });
            if (self.openOnFocus) {
              self.ngInputElement.on('focus', angular.bind(self, self.openCalendarPane));
            }
            $scope.$on('md-calendar-close', function() {
              self.closeCalendarPane();
            });
          };
          DatePickerCtrl.prototype.installPropertyInterceptors = function() {
            var self = this;
            if (this.$attrs.ngDisabled) {
              var scope = this.$scope.$parent;
              if (scope) {
                scope.$watch(this.$attrs.ngDisabled, function(isDisabled) {
                  self.setDisabled(isDisabled);
                });
              }
            }
            Object.defineProperty(this, 'placeholder', {
              get: function() {
                return self.inputElement.placeholder;
              },
              set: function(value) {
                self.inputElement.placeholder = value || '';
              }
            });
          };
          DatePickerCtrl.prototype.setDisabled = function(isDisabled) {
            this.isDisabled = isDisabled;
            this.inputElement.disabled = isDisabled;
            if (this.calendarButton) {
              this.calendarButton.disabled = isDisabled;
            }
          };
          DatePickerCtrl.prototype.updateErrorState = function(opt_date) {
            var date = opt_date || this.date;
            this.clearErrorState();
            if (this.dateUtil.isValidDate(date)) {
              date = this.dateUtil.createDateAtMidnight(date);
              if (this.dateUtil.isValidDate(this.minDate)) {
                var minDate = this.dateUtil.createDateAtMidnight(this.minDate);
                this.ngModelCtrl.$setValidity('mindate', date >= minDate);
              }
              if (this.dateUtil.isValidDate(this.maxDate)) {
                var maxDate = this.dateUtil.createDateAtMidnight(this.maxDate);
                this.ngModelCtrl.$setValidity('maxdate', date <= maxDate);
              }
              if (angular.isFunction(this.dateFilter)) {
                this.ngModelCtrl.$setValidity('filtered', this.dateFilter(date));
              }
            } else {
              this.ngModelCtrl.$setValidity('valid', date == null);
            }
            if (!this.ngModelCtrl.$valid) {
              this.inputContainer.classList.add(INVALID_CLASS);
            }
          };
          DatePickerCtrl.prototype.clearErrorState = function() {
            this.inputContainer.classList.remove(INVALID_CLASS);
            ['mindate', 'maxdate', 'filtered', 'valid'].forEach(function(field) {
              this.ngModelCtrl.$setValidity(field, true);
            }, this);
          };
          DatePickerCtrl.prototype.resizeInputElement = function() {
            this.inputElement.size = this.inputElement.value.length + EXTRA_INPUT_SIZE;
          };
          DatePickerCtrl.prototype.handleInputEvent = function() {
            var inputString = this.inputElement.value;
            var parsedDate = inputString ? this.dateLocale.parseDate(inputString) : null;
            this.dateUtil.setDateTimeToMidnight(parsedDate);
            var isValidInput = inputString == '' || (this.dateUtil.isValidDate(parsedDate) && this.dateLocale.isDateComplete(inputString) && this.isDateEnabled(parsedDate));
            if (isValidInput) {
              this.ngModelCtrl.$setViewValue(parsedDate);
              this.date = parsedDate;
            }
            this.updateErrorState(parsedDate);
          };
          DatePickerCtrl.prototype.isDateEnabled = function(opt_date) {
            return this.dateUtil.isDateWithinRange(opt_date, this.minDate, this.maxDate) && (!angular.isFunction(this.dateFilter) || this.dateFilter(opt_date));
          };
          DatePickerCtrl.prototype.attachCalendarPane = function() {
            var calendarPane = this.calendarPane;
            var body = document.body;
            calendarPane.style.transform = '';
            this.$element.addClass(OPEN_CLASS);
            this.mdInputContainer && this.mdInputContainer.element.addClass(OPEN_CLASS);
            angular.element(body).addClass('md-datepicker-is-showing');
            var elementRect = this.inputContainer.getBoundingClientRect();
            var bodyRect = body.getBoundingClientRect();
            var paneTop = elementRect.top - bodyRect.top;
            var paneLeft = elementRect.left - bodyRect.left;
            var viewportTop = (bodyRect.top < 0 && document.body.scrollTop == 0) ? -bodyRect.top : document.body.scrollTop;
            var viewportLeft = (bodyRect.left < 0 && document.body.scrollLeft == 0) ? -bodyRect.left : document.body.scrollLeft;
            var viewportBottom = viewportTop + this.$window.innerHeight;
            var viewportRight = viewportLeft + this.$window.innerWidth;
            if (paneLeft + CALENDAR_PANE_WIDTH > viewportRight) {
              if (viewportRight - CALENDAR_PANE_WIDTH > 0) {
                paneLeft = viewportRight - CALENDAR_PANE_WIDTH;
              } else {
                paneLeft = viewportLeft;
                var scale = this.$window.innerWidth / CALENDAR_PANE_WIDTH;
                calendarPane.style.transform = 'scale(' + scale + ')';
              }
              calendarPane.classList.add('md-datepicker-pos-adjusted');
            }
            if (paneTop + CALENDAR_PANE_HEIGHT > viewportBottom && viewportBottom - CALENDAR_PANE_HEIGHT > viewportTop) {
              paneTop = viewportBottom - CALENDAR_PANE_HEIGHT;
              calendarPane.classList.add('md-datepicker-pos-adjusted');
            }
            calendarPane.style.left = paneLeft + 'px';
            calendarPane.style.top = paneTop + 'px';
            document.body.appendChild(calendarPane);
            this.inputMask.style.left = elementRect.width + 'px';
            this.$$rAF(function() {
              calendarPane.classList.add('md-pane-open');
            });
          };
          DatePickerCtrl.prototype.detachCalendarPane = function() {
            this.$element.removeClass(OPEN_CLASS);
            this.mdInputContainer && this.mdInputContainer.element.removeClass(OPEN_CLASS);
            angular.element(document.body).removeClass('md-datepicker-is-showing');
            this.calendarPane.classList.remove('md-pane-open');
            this.calendarPane.classList.remove('md-datepicker-pos-adjusted');
            if (this.isCalendarOpen) {
              this.$mdUtil.enableScrolling();
            }
            if (this.calendarPane.parentNode) {
              this.calendarPane.parentNode.removeChild(this.calendarPane);
            }
          };
          DatePickerCtrl.prototype.openCalendarPane = function(event) {
            if (!this.isCalendarOpen && !this.isDisabled) {
              this.isCalendarOpen = this.isOpen = true;
              this.calendarPaneOpenedFrom = event.target;
              this.$mdUtil.disableScrollAround(this.calendarPane);
              this.attachCalendarPane();
              this.focusCalendar();
              var self = this;
              this.$mdUtil.nextTick(function() {
                self.documentElement.on('click touchstart', self.bodyClickHandler);
              }, false);
              window.addEventListener('resize', this.windowResizeHandler);
            }
          };
          DatePickerCtrl.prototype.closeCalendarPane = function() {
            if (this.isCalendarOpen) {
              var self = this;
              self.calendarPaneOpenedFrom.focus();
              self.calendarPaneOpenedFrom = null;
              if (self.openOnFocus) {
                this.$mdUtil.nextTick(detach);
              } else {
                detach();
              }
            }
            function detach() {
              self.detachCalendarPane();
              self.isCalendarOpen = self.isOpen = false;
              self.ngModelCtrl.$setTouched();
              self.documentElement.off('click touchstart', self.bodyClickHandler);
              window.removeEventListener('resize', self.windowResizeHandler);
            }
          };
          DatePickerCtrl.prototype.getCalendarCtrl = function() {
            return angular.element(this.calendarPane.querySelector('md-calendar')).controller('mdCalendar');
          };
          DatePickerCtrl.prototype.focusCalendar = function() {
            var self = this;
            this.$mdUtil.nextTick(function() {
              self.getCalendarCtrl().focus();
            }, false);
          };
          DatePickerCtrl.prototype.setFocused = function(isFocused) {
            if (!isFocused) {
              this.ngModelCtrl.$setTouched();
            }
            this.isFocused = isFocused;
          };
          DatePickerCtrl.prototype.handleBodyClick = function(event) {
            if (this.isCalendarOpen) {
              var isInCalendar = this.$mdUtil.getClosest(event.target, 'md-calendar');
              if (!isInCalendar) {
                this.closeCalendarPane();
              }
              this.$scope.$digest();
            }
          };
        })();
      })();
      (function() {
        "use strict";
        angular.module('material.components.icon').directive('mdIcon', ['$mdIcon', '$mdTheming', '$mdAria', '$sce', mdIconDirective]);
        function mdIconDirective($mdIcon, $mdTheming, $mdAria, $sce) {
          return {
            restrict: 'E',
            link: postLink
          };
          function postLink(scope, element, attr) {
            $mdTheming(element);
            var lastFontIcon = attr.mdFontIcon;
            var lastFontSet = $mdIcon.fontSet(attr.mdFontSet);
            prepareForFontIcon();
            attr.$observe('mdFontIcon', fontIconChanged);
            attr.$observe('mdFontSet', fontIconChanged);
            var originalSvgSrc = element[0].getAttribute(attr.$attr.mdSvgSrc);
            var label = attr.alt || attr.mdFontIcon || attr.mdSvgIcon || element.text();
            var attrName = attr.$normalize(attr.$attr.mdSvgIcon || attr.$attr.mdSvgSrc || '');
            if (!attr['aria-label']) {
              if (label !== '' && !parentsHaveText()) {
                $mdAria.expect(element, 'aria-label', label);
                $mdAria.expect(element, 'role', 'img');
              } else if (!element.text()) {
                $mdAria.expect(element, 'aria-hidden', 'true');
              }
            }
            if (attrName) {
              attr.$observe(attrName, function(attrVal) {
                if (!isInlineSvg(attrVal) && attrVal === originalSvgSrc) {
                  attrVal = $sce.trustAsUrl(attrVal);
                }
                element.empty();
                if (attrVal) {
                  $mdIcon(attrVal).then(function(svg) {
                    element.empty();
                    element.append(svg);
                  });
                }
              });
            }
            function parentsHaveText() {
              var parent = element.parent();
              if (parent.attr('aria-label') || parent.text()) {
                return true;
              } else if (parent.parent().attr('aria-label') || parent.parent().text()) {
                return true;
              }
              return false;
            }
            function prepareForFontIcon() {
              if (!attr.mdSvgIcon && !attr.mdSvgSrc) {
                if (attr.mdFontIcon) {
                  element.addClass('md-font ' + attr.mdFontIcon);
                }
                element.addClass(lastFontSet);
              }
            }
            function fontIconChanged() {
              if (!attr.mdSvgIcon && !attr.mdSvgSrc) {
                if (attr.mdFontIcon) {
                  element.removeClass(lastFontIcon);
                  element.addClass(attr.mdFontIcon);
                  lastFontIcon = attr.mdFontIcon;
                }
                var fontSet = $mdIcon.fontSet(attr.mdFontSet);
                if (lastFontSet !== fontSet) {
                  element.removeClass(lastFontSet);
                  element.addClass(fontSet);
                  lastFontSet = fontSet;
                }
              }
            }
          }
          function isInlineSvg(svgSrc) {
            var dataUrlRegex = /^data:image\/svg\+xml[\s*;\w\-\=]*?(base64)?,(.*)$/i;
            return dataUrlRegex.test(svgSrc);
          }
        }
      })();
      (function() {
        "use strict";
        angular.module('material.components.icon').constant('$$mdSvgRegistry', {
          'mdTabsArrow': 'data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMjQgMjQiPjxnPjxwb2x5Z29uIHBvaW50cz0iMTUuNCw3LjQgMTQsNiA4LDEyIDE0LDE4IDE1LjQsMTYuNiAxMC44LDEyICIvPjwvZz48L3N2Zz4=',
          'mdClose': 'data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMjQgMjQiPjxnPjxwYXRoIGQ9Ik0xOSA2LjQxbC0xLjQxLTEuNDEtNS41OSA1LjU5LTUuNTktNS41OS0xLjQxIDEuNDEgNS41OSA1LjU5LTUuNTkgNS41OSAxLjQxIDEuNDEgNS41OS01LjU5IDUuNTkgNS41OSAxLjQxLTEuNDEtNS41OS01LjU5eiIvPjwvZz48L3N2Zz4=',
          'mdCancel': 'data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMjQgMjQiPjxnPjxwYXRoIGQ9Ik0xMiAyYy01LjUzIDAtMTAgNC40Ny0xMCAxMHM0LjQ3IDEwIDEwIDEwIDEwLTQuNDcgMTAtMTAtNC40Ny0xMC0xMC0xMHptNSAxMy41OWwtMS40MSAxLjQxLTMuNTktMy41OS0zLjU5IDMuNTktMS40MS0xLjQxIDMuNTktMy41OS0zLjU5LTMuNTkgMS40MS0xLjQxIDMuNTkgMy41OSAzLjU5LTMuNTkgMS40MSAxLjQxLTMuNTkgMy41OSAzLjU5IDMuNTl6Ii8+PC9nPjwvc3ZnPg==',
          'mdMenu': 'data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMjQgMjQiPjxwYXRoIGQ9Ik0zLDZIMjFWOEgzVjZNMywxMUgyMVYxM0gzVjExTTMsMTZIMjFWMThIM1YxNloiIC8+PC9zdmc+',
          'mdToggleArrow': 'data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgNDggNDgiPjxwYXRoIGQ9Ik0yNCAxNmwtMTIgMTIgMi44MyAyLjgzIDkuMTctOS4xNyA5LjE3IDkuMTcgMi44My0yLjgzeiIvPjxwYXRoIGQ9Ik0wIDBoNDh2NDhoLTQ4eiIgZmlsbD0ibm9uZSIvPjwvc3ZnPg==',
          'mdCalendar': 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNMTkgM2gtMVYxaC0ydjJIOFYxSDZ2Mkg1Yy0xLjExIDAtMS45OS45LTEuOTkgMkwzIDE5YzAgMS4xLjg5IDIgMiAyaDE0YzEuMSAwIDItLjkgMi0yVjVjMC0xLjEtLjktMi0yLTJ6bTAgMTZINVY4aDE0djExek03IDEwaDV2NUg3eiIvPjwvc3ZnPg=='
        }).provider('$mdIcon', MdIconProvider);
        var config = {
          defaultViewBoxSize: 24,
          defaultFontSet: 'material-icons',
          fontSets: []
        };
        function MdIconProvider() {}
        MdIconProvider.prototype = {
          icon: function(id, url, viewBoxSize) {
            if (id.indexOf(':') == -1)
              id = '$default:' + id;
            config[id] = new ConfigurationItem(url, viewBoxSize);
            return this;
          },
          iconSet: function(id, url, viewBoxSize) {
            config[id] = new ConfigurationItem(url, viewBoxSize);
            return this;
          },
          defaultIconSet: function(url, viewBoxSize) {
            var setName = '$default';
            if (!config[setName]) {
              config[setName] = new ConfigurationItem(url, viewBoxSize);
            }
            config[setName].viewBoxSize = viewBoxSize || config.defaultViewBoxSize;
            return this;
          },
          defaultViewBoxSize: function(viewBoxSize) {
            config.defaultViewBoxSize = viewBoxSize;
            return this;
          },
          fontSet: function fontSet(alias, className) {
            config.fontSets.push({
              alias: alias,
              fontSet: className || alias
            });
            return this;
          },
          defaultFontSet: function defaultFontSet(className) {
            config.defaultFontSet = !className ? '' : className;
            return this;
          },
          defaultIconSize: function defaultIconSize(iconSize) {
            config.defaultIconSize = iconSize;
            return this;
          },
          $get: ['$templateRequest', '$q', '$log', '$mdUtil', '$sce', function($templateRequest, $q, $log, $mdUtil, $sce) {
            return MdIconService(config, $templateRequest, $q, $log, $mdUtil, $sce);
          }]
        };
        function ConfigurationItem(url, viewBoxSize) {
          this.url = url;
          this.viewBoxSize = viewBoxSize || config.defaultViewBoxSize;
        }
        function MdIconService(config, $templateRequest, $q, $log, $mdUtil, $sce) {
          var iconCache = {};
          var svgCache = {};
          var urlRegex = /[-\w@:%\+.~#?&//=]{2,}\.[a-z]{2,4}\b(\/[-\w@:%\+.~#?&//=]*)?/i;
          var dataUrlRegex = /^data:image\/svg\+xml[\s*;\w\-\=]*?(base64)?,(.*)$/i;
          Icon.prototype = {
            clone: cloneSVG,
            prepare: prepareAndStyle
          };
          getIcon.fontSet = findRegisteredFontSet;
          return getIcon;
          function getIcon(id) {
            id = id || '';
            if (!angular.isString(id)) {
              id = $sce.getTrustedUrl(id);
            }
            if (iconCache[id]) {
              return $q.when(transformClone(iconCache[id]));
            }
            if (urlRegex.test(id) || dataUrlRegex.test(id)) {
              return loadByURL(id).then(cacheIcon(id));
            }
            if (id.indexOf(':') == -1) {
              id = '$default:' + id;
            }
            var load = config[id] ? loadByID : loadFromIconSet;
            return load(id).then(cacheIcon(id));
          }
          function findRegisteredFontSet(alias) {
            var useDefault = angular.isUndefined(alias) || !(alias && alias.length);
            if (useDefault)
              return config.defaultFontSet;
            var result = alias;
            angular.forEach(config.fontSets, function(it) {
              if (it.alias == alias)
                result = it.fontSet || result;
            });
            return result;
          }
          function transformClone(cacheElement) {
            var clone = cacheElement.clone();
            var cacheSuffix = '_cache' + $mdUtil.nextUid();
            if (clone.id)
              clone.id += cacheSuffix;
            angular.forEach(clone.querySelectorAll('[id]'), function(item) {
              item.id += cacheSuffix;
            });
            return clone;
          }
          function cacheIcon(id) {
            return function updateCache(icon) {
              iconCache[id] = isIcon(icon) ? icon : new Icon(icon, config[id]);
              return iconCache[id].clone();
            };
          }
          function loadByID(id) {
            var iconConfig = config[id];
            return loadByURL(iconConfig.url).then(function(icon) {
              return new Icon(icon, iconConfig);
            });
          }
          function loadFromIconSet(id) {
            var setName = id.substring(0, id.lastIndexOf(':')) || '$default';
            var iconSetConfig = config[setName];
            return !iconSetConfig ? announceIdNotFound(id) : loadByURL(iconSetConfig.url).then(extractFromSet);
            function extractFromSet(set) {
              var iconName = id.slice(id.lastIndexOf(':') + 1);
              var icon = set.querySelector('#' + iconName);
              return icon ? new Icon(icon, iconSetConfig) : announceIdNotFound(id);
            }
            function announceIdNotFound(id) {
              var msg = 'icon ' + id + ' not found';
              $log.warn(msg);
              return $q.reject(msg || id);
            }
          }
          function loadByURL(url) {
            function loadByDataUrl(url) {
              var results = dataUrlRegex.exec(url);
              var isBase64 = /base64/i.test(url);
              var data = isBase64 ? window.atob(results[2]) : results[2];
              return $q.when(angular.element(data)[0]);
            }
            function loadByHttpUrl(url) {
              return $q(function(resolve, reject) {
                var announceAndReject = function(err) {
                  var msg = angular.isString(err) ? err : (err.message || err.data || err.statusText);
                  $log.warn(msg);
                  reject(err);
                },
                    extractSvg = function(response) {
                      if (!svgCache[url]) {
                        svgCache[url] = angular.element('<div>').append(response)[0].querySelector('svg');
                      }
                      resolve(svgCache[url]);
                    };
                $templateRequest(url, true).then(extractSvg, announceAndReject);
              });
            }
            return dataUrlRegex.test(url) ? loadByDataUrl(url) : loadByHttpUrl(url);
          }
          function isIcon(target) {
            return angular.isDefined(target.element) && angular.isDefined(target.config);
          }
          function Icon(el, config) {
            if (el && el.tagName != 'svg') {
              el = angular.element('<svg xmlns="http://www.w3.org/2000/svg">').append(el.cloneNode(true))[0];
            }
            if (!el.getAttribute('xmlns')) {
              el.setAttribute('xmlns', "http://www.w3.org/2000/svg");
            }
            this.element = el;
            this.config = config;
            this.prepare();
          }
          function prepareAndStyle() {
            var viewBoxSize = this.config ? this.config.viewBoxSize : config.defaultViewBoxSize;
            angular.forEach({
              'fit': '',
              'height': '100%',
              'width': '100%',
              'preserveAspectRatio': 'xMidYMid meet',
              'viewBox': this.element.getAttribute('viewBox') || ('0 0 ' + viewBoxSize + ' ' + viewBoxSize),
              'focusable': false
            }, function(val, attr) {
              this.element.setAttribute(attr, val);
            }, this);
          }
          function cloneSVG() {
            return this.element.cloneNode(true);
          }
        }
        MdIconService.$inject = ["config", "$templateRequest", "$q", "$log", "$mdUtil", "$sce"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.menu').controller('mdMenuCtrl', MenuController);
        function MenuController($mdMenu, $attrs, $element, $scope, $mdUtil, $timeout, $rootScope, $q) {
          var prefixer = $mdUtil.prefixer();
          var menuContainer;
          var self = this;
          var triggerElement;
          this.nestLevel = parseInt($attrs.mdNestLevel, 10) || 0;
          this.init = function init(setMenuContainer, opts) {
            opts = opts || {};
            menuContainer = setMenuContainer;
            triggerElement = $element[0].querySelector(prefixer.buildSelector(['ng-click', 'ng-mouseenter']));
            triggerElement.setAttribute('aria-expanded', 'false');
            this.isInMenuBar = opts.isInMenuBar;
            this.nestedMenus = $mdUtil.nodesToArray(menuContainer[0].querySelectorAll('.md-nested-menu'));
            menuContainer.on('$mdInterimElementRemove', function() {
              self.isOpen = false;
              $mdUtil.nextTick(function() {
                self.onIsOpenChanged(self.isOpen);
              });
            });
            $mdUtil.nextTick(function() {
              self.onIsOpenChanged(self.isOpen);
            });
            var menuContainerId = 'menu_container_' + $mdUtil.nextUid();
            menuContainer.attr('id', menuContainerId);
            angular.element(triggerElement).attr({
              'aria-owns': menuContainerId,
              'aria-haspopup': 'true'
            });
            $scope.$on('$destroy', angular.bind(this, function() {
              this.disableHoverListener();
              $mdMenu.destroy();
            }));
            menuContainer.on('$destroy', function() {
              $mdMenu.destroy();
            });
          };
          var openMenuTimeout,
              menuItems,
              deregisterScopeListeners = [];
          this.enableHoverListener = function() {
            deregisterScopeListeners.push($rootScope.$on('$mdMenuOpen', function(event, el) {
              if (menuContainer[0].contains(el[0])) {
                self.currentlyOpenMenu = el.controller('mdMenu');
                self.isAlreadyOpening = false;
                self.currentlyOpenMenu.registerContainerProxy(self.triggerContainerProxy.bind(self));
              }
            }));
            deregisterScopeListeners.push($rootScope.$on('$mdMenuClose', function(event, el) {
              if (menuContainer[0].contains(el[0])) {
                self.currentlyOpenMenu = undefined;
              }
            }));
            menuItems = angular.element($mdUtil.nodesToArray(menuContainer[0].children[0].children));
            menuItems.on('mouseenter', self.handleMenuItemHover);
            menuItems.on('mouseleave', self.handleMenuItemMouseLeave);
          };
          this.disableHoverListener = function() {
            while (deregisterScopeListeners.length) {
              deregisterScopeListeners.shift()();
            }
            menuItems && menuItems.off('mouseenter', self.handleMenuItemHover);
            menuItems && menuItems.off('mouseleave', self.handleMenuItemMouseLeave);
          };
          this.handleMenuItemHover = function(event) {
            if (self.isAlreadyOpening)
              return;
            var nestedMenu = (event.target.querySelector('md-menu') || $mdUtil.getClosest(event.target, 'MD-MENU'));
            openMenuTimeout = $timeout(function() {
              if (nestedMenu) {
                nestedMenu = angular.element(nestedMenu).controller('mdMenu');
              }
              if (self.currentlyOpenMenu && self.currentlyOpenMenu != nestedMenu) {
                var closeTo = self.nestLevel + 1;
                self.currentlyOpenMenu.close(true, {closeTo: closeTo});
                self.isAlreadyOpening = !!nestedMenu;
                nestedMenu && nestedMenu.open();
              } else if (nestedMenu && !nestedMenu.isOpen && nestedMenu.open) {
                self.isAlreadyOpening = !!nestedMenu;
                nestedMenu && nestedMenu.open();
              }
            }, nestedMenu ? 100 : 250);
            var focusableTarget = event.currentTarget.querySelector('.md-button:not([disabled])');
            focusableTarget && focusableTarget.focus();
          };
          this.handleMenuItemMouseLeave = function() {
            if (openMenuTimeout) {
              $timeout.cancel(openMenuTimeout);
              openMenuTimeout = undefined;
            }
          };
          this.open = function openMenu(ev) {
            ev && ev.stopPropagation();
            ev && ev.preventDefault();
            if (self.isOpen)
              return;
            self.enableHoverListener();
            self.isOpen = true;
            $mdUtil.nextTick(function() {
              self.onIsOpenChanged(self.isOpen);
            });
            triggerElement = triggerElement || (ev ? ev.target : $element[0]);
            triggerElement.setAttribute('aria-expanded', 'true');
            $scope.$emit('$mdMenuOpen', $element);
            $mdMenu.show({
              scope: $scope,
              mdMenuCtrl: self,
              nestLevel: self.nestLevel,
              element: menuContainer,
              target: triggerElement,
              preserveElement: true,
              parent: 'body'
            }).finally(function() {
              triggerElement.setAttribute('aria-expanded', 'false');
              self.disableHoverListener();
            });
          };
          $scope.$mdOpenMenu = this.open;
          this.onIsOpenChanged = function(isOpen) {
            if (isOpen) {
              menuContainer.attr('aria-hidden', 'false');
              $element[0].classList.add('_md-open');
              angular.forEach(self.nestedMenus, function(el) {
                el.classList.remove('_md-open');
              });
            } else {
              menuContainer.attr('aria-hidden', 'true');
              $element[0].classList.remove('_md-open');
            }
            $scope.$mdMenuIsOpen = self.isOpen;
          };
          this.focusMenuContainer = function focusMenuContainer() {
            var focusTarget = menuContainer[0].querySelector(prefixer.buildSelector(['md-menu-focus-target', 'md-autofocus']));
            if (!focusTarget)
              focusTarget = menuContainer[0].querySelector('.md-button');
            focusTarget.focus();
          };
          this.registerContainerProxy = function registerContainerProxy(handler) {
            this.containerProxy = handler;
          };
          this.triggerContainerProxy = function triggerContainerProxy(ev) {
            this.containerProxy && this.containerProxy(ev);
          };
          this.destroy = function() {
            return self.isOpen ? $mdMenu.destroy() : $q.when(false);
          };
          this.close = function closeMenu(skipFocus, closeOpts) {
            if (!self.isOpen)
              return;
            self.isOpen = false;
            $mdUtil.nextTick(function() {
              self.onIsOpenChanged(self.isOpen);
            });
            var eventDetails = angular.extend({}, closeOpts, {skipFocus: skipFocus});
            $scope.$emit('$mdMenuClose', $element, eventDetails);
            $mdMenu.hide(null, closeOpts);
            if (!skipFocus) {
              var el = self.restoreFocusTo || $element.find('button')[0];
              if (el instanceof angular.element)
                el = el[0];
              if (el)
                el.focus();
            }
          };
          this.positionMode = function positionMode() {
            var attachment = ($attrs.mdPositionMode || 'target').split(' ');
            if (attachment.length == 1) {
              attachment.push(attachment[0]);
            }
            return {
              left: attachment[0],
              top: attachment[1]
            };
          };
          this.offsets = function offsets() {
            var position = ($attrs.mdOffset || '0 0').split(' ').map(parseFloat);
            if (position.length == 2) {
              return {
                left: position[0],
                top: position[1]
              };
            } else if (position.length == 1) {
              return {
                top: position[0],
                left: position[0]
              };
            } else {
              throw Error('Invalid offsets specified. Please follow format <x, y> or <n>');
            }
          };
        }
        MenuController.$inject = ["$mdMenu", "$attrs", "$element", "$scope", "$mdUtil", "$timeout", "$rootScope", "$q"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.menu').directive('mdMenu', MenuDirective);
        function MenuDirective($mdUtil) {
          var INVALID_PREFIX = 'Invalid HTML for md-menu: ';
          return {
            restrict: 'E',
            require: ['mdMenu', '?^mdMenuBar'],
            controller: 'mdMenuCtrl',
            scope: true,
            compile: compile
          };
          function compile(templateElement) {
            templateElement.addClass('md-menu');
            var triggerElement = templateElement.children()[0];
            var prefixer = $mdUtil.prefixer();
            if (!prefixer.hasAttribute(triggerElement, 'ng-click')) {
              triggerElement = triggerElement.querySelector(prefixer.buildSelector(['ng-click', 'ng-mouseenter'])) || triggerElement;
            }
            if (triggerElement && (triggerElement.nodeName == 'MD-BUTTON' || triggerElement.nodeName == 'BUTTON') && !triggerElement.hasAttribute('type')) {
              triggerElement.setAttribute('type', 'button');
            }
            if (templateElement.children().length != 2) {
              throw Error(INVALID_PREFIX + 'Expected two children elements.');
            }
            triggerElement && triggerElement.setAttribute('aria-haspopup', 'true');
            var nestedMenus = templateElement[0].querySelectorAll('md-menu');
            var nestingDepth = parseInt(templateElement[0].getAttribute('md-nest-level'), 10) || 0;
            if (nestedMenus) {
              angular.forEach($mdUtil.nodesToArray(nestedMenus), function(menuEl) {
                if (!menuEl.hasAttribute('md-position-mode')) {
                  menuEl.setAttribute('md-position-mode', 'cascade');
                }
                menuEl.classList.add('_md-nested-menu');
                menuEl.setAttribute('md-nest-level', nestingDepth + 1);
              });
            }
            return link;
          }
          function link(scope, element, attr, ctrls) {
            var mdMenuCtrl = ctrls[0];
            var isInMenuBar = ctrls[1] != undefined;
            var menuContainer = angular.element('<div class="_md _md-open-menu-container md-whiteframe-z2"></div>');
            var menuContents = element.children()[1];
            element.addClass('_md');
            if (!menuContents.hasAttribute('role')) {
              menuContents.setAttribute('role', 'menu');
            }
            menuContainer.append(menuContents);
            element.on('$destroy', function() {
              menuContainer.remove();
            });
            element.append(menuContainer);
            menuContainer[0].style.display = 'none';
            mdMenuCtrl.init(menuContainer, {isInMenuBar: isInMenuBar});
          }
        }
        MenuDirective.$inject = ["$mdUtil"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.menu').provider('$mdMenu', MenuProvider);
        function MenuProvider($$interimElementProvider) {
          var MENU_EDGE_MARGIN = 8;
          menuDefaultOptions.$inject = ["$mdUtil", "$mdTheming", "$mdConstant", "$document", "$window", "$q", "$$rAF", "$animateCss", "$animate"];
          return $$interimElementProvider('$mdMenu').setDefaults({
            methods: ['target'],
            options: menuDefaultOptions
          });
          function menuDefaultOptions($mdUtil, $mdTheming, $mdConstant, $document, $window, $q, $$rAF, $animateCss, $animate) {
            var prefixer = $mdUtil.prefixer();
            var animator = $mdUtil.dom.animator;
            return {
              parent: 'body',
              onShow: onShow,
              onRemove: onRemove,
              hasBackdrop: true,
              disableParentScroll: true,
              skipCompile: true,
              preserveScope: true,
              skipHide: true,
              themable: true
            };
            function showBackdrop(scope, element, options) {
              if (options.nestLevel)
                return angular.noop;
              if (options.disableParentScroll && !$mdUtil.getClosest(options.target, 'MD-DIALOG')) {
                options.restoreScroll = $mdUtil.disableScrollAround(options.element, options.parent);
              } else {
                options.disableParentScroll = false;
              }
              if (options.hasBackdrop) {
                options.backdrop = $mdUtil.createBackdrop(scope, "_md-menu-backdrop _md-click-catcher");
                $animate.enter(options.backdrop, $document[0].body);
              }
              return function hideBackdrop() {
                if (options.backdrop)
                  options.backdrop.remove();
                if (options.disableParentScroll)
                  options.restoreScroll();
              };
            }
            function onRemove(scope, element, opts) {
              opts.cleanupInteraction && opts.cleanupInteraction();
              opts.cleanupResizing();
              opts.hideBackdrop();
              return (opts.$destroy === true) ? detachAndClean() : animateRemoval().then(detachAndClean);
              function animateRemoval() {
                return $animateCss(element, {addClass: '_md-leave'}).start();
              }
              function detachAndClean() {
                element.removeClass('_md-active');
                detachElement(element, opts);
                opts.alreadyOpen = false;
              }
            }
            function onShow(scope, element, opts) {
              sanitizeAndConfigure(opts);
              $mdTheming.inherit(opts.menuContentEl, opts.target);
              opts.cleanupResizing = startRepositioningOnResize();
              opts.hideBackdrop = showBackdrop(scope, element, opts);
              return showMenu().then(function(response) {
                opts.alreadyOpen = true;
                opts.cleanupInteraction = activateInteraction();
                return response;
              });
              function showMenu() {
                opts.parent.append(element);
                element[0].style.display = '';
                return $q(function(resolve) {
                  var position = calculateMenuPosition(element, opts);
                  element.removeClass('_md-leave');
                  $animateCss(element, {
                    addClass: '_md-active',
                    from: animator.toCss(position),
                    to: animator.toCss({transform: ''})
                  }).start().then(resolve);
                });
              }
              function sanitizeAndConfigure() {
                if (!opts.target) {
                  throw Error('$mdMenu.show() expected a target to animate from in options.target');
                }
                angular.extend(opts, {
                  alreadyOpen: false,
                  isRemoved: false,
                  target: angular.element(opts.target),
                  parent: angular.element(opts.parent),
                  menuContentEl: angular.element(element[0].querySelector('md-menu-content'))
                });
              }
              function startRepositioningOnResize() {
                var repositionMenu = (function(target, options) {
                  return $$rAF.throttle(function() {
                    if (opts.isRemoved)
                      return;
                    var position = calculateMenuPosition(target, options);
                    target.css(animator.toCss(position));
                  });
                })(element, opts);
                $window.addEventListener('resize', repositionMenu);
                $window.addEventListener('orientationchange', repositionMenu);
                return function stopRepositioningOnResize() {
                  $window.removeEventListener('resize', repositionMenu);
                  $window.removeEventListener('orientationchange', repositionMenu);
                };
              }
              function activateInteraction() {
                element.addClass('_md-clickable');
                if (opts.backdrop)
                  opts.backdrop.on('click', onBackdropClick);
                opts.menuContentEl.on('keydown', onMenuKeyDown);
                opts.menuContentEl[0].addEventListener('click', captureClickListener, true);
                var focusTarget = opts.menuContentEl[0].querySelector(prefixer.buildSelector(['md-menu-focus-target', 'md-autofocus']));
                if (!focusTarget) {
                  var firstChild = opts.menuContentEl[0].firstElementChild;
                  focusTarget = firstChild && (firstChild.querySelector('.md-button:not([disabled])') || firstChild.firstElementChild);
                }
                focusTarget && focusTarget.focus();
                return function cleanupInteraction() {
                  element.removeClass('_md-clickable');
                  if (opts.backdrop)
                    opts.backdrop.off('click', onBackdropClick);
                  opts.menuContentEl.off('keydown', onMenuKeyDown);
                  opts.menuContentEl[0].removeEventListener('click', captureClickListener, true);
                };
                function onMenuKeyDown(ev) {
                  var handled;
                  switch (ev.keyCode) {
                    case $mdConstant.KEY_CODE.ESCAPE:
                      opts.mdMenuCtrl.close(false, {closeAll: true});
                      handled = true;
                      break;
                    case $mdConstant.KEY_CODE.UP_ARROW:
                      if (!focusMenuItem(ev, opts.menuContentEl, opts, -1) && !opts.nestLevel) {
                        opts.mdMenuCtrl.triggerContainerProxy(ev);
                      }
                      handled = true;
                      break;
                    case $mdConstant.KEY_CODE.DOWN_ARROW:
                      if (!focusMenuItem(ev, opts.menuContentEl, opts, 1) && !opts.nestLevel) {
                        opts.mdMenuCtrl.triggerContainerProxy(ev);
                      }
                      handled = true;
                      break;
                    case $mdConstant.KEY_CODE.LEFT_ARROW:
                      if (opts.nestLevel) {
                        opts.mdMenuCtrl.close();
                      } else {
                        opts.mdMenuCtrl.triggerContainerProxy(ev);
                      }
                      handled = true;
                      break;
                    case $mdConstant.KEY_CODE.RIGHT_ARROW:
                      var parentMenu = $mdUtil.getClosest(ev.target, 'MD-MENU');
                      if (parentMenu && parentMenu != opts.parent[0]) {
                        ev.target.click();
                      } else {
                        opts.mdMenuCtrl.triggerContainerProxy(ev);
                      }
                      handled = true;
                      break;
                  }
                  if (handled) {
                    ev.preventDefault();
                    ev.stopImmediatePropagation();
                  }
                }
                function onBackdropClick(e) {
                  e.preventDefault();
                  e.stopPropagation();
                  scope.$apply(function() {
                    opts.mdMenuCtrl.close(true, {closeAll: true});
                  });
                }
                function captureClickListener(e) {
                  var target = e.target;
                  do {
                    if (target == opts.menuContentEl[0])
                      return;
                    if ((hasAnyAttribute(target, ['ng-click', 'ng-href', 'ui-sref']) || target.nodeName == 'BUTTON' || target.nodeName == 'MD-BUTTON') && !hasAnyAttribute(target, ['md-prevent-menu-close'])) {
                      var closestMenu = $mdUtil.getClosest(target, 'MD-MENU');
                      if (!target.hasAttribute('disabled') && (!closestMenu || closestMenu == opts.parent[0])) {
                        close();
                      }
                      break;
                    }
                  } while (target = target.parentNode);
                  function close() {
                    scope.$apply(function() {
                      opts.mdMenuCtrl.close(true, {closeAll: true});
                    });
                  }
                  function hasAnyAttribute(target, attrs) {
                    if (!target)
                      return false;
                    for (var i = 0,
                        attr; attr = attrs[i]; ++i) {
                      if (prefixer.hasAttribute(target, attr)) {
                        return true;
                      }
                    }
                    return false;
                  }
                }
              }
            }
            function focusMenuItem(e, menuEl, opts, direction) {
              var currentItem = $mdUtil.getClosest(e.target, 'MD-MENU-ITEM');
              var items = $mdUtil.nodesToArray(menuEl[0].children);
              var currentIndex = items.indexOf(currentItem);
              var didFocus;
              for (var i = currentIndex + direction; i >= 0 && i < items.length; i = i + direction) {
                var focusTarget = items[i].querySelector('.md-button');
                didFocus = attemptFocus(focusTarget);
                if (didFocus) {
                  break;
                }
              }
              return didFocus;
            }
            function attemptFocus(el) {
              if (el && el.getAttribute('tabindex') != -1) {
                el.focus();
                return ($document[0].activeElement == el);
              }
            }
            function detachElement(element, opts) {
              if (!opts.preserveElement) {
                if (toNode(element).parentNode === toNode(opts.parent)) {
                  toNode(opts.parent).removeChild(toNode(element));
                }
              } else {
                toNode(element).style.display = 'none';
              }
            }
            function calculateMenuPosition(el, opts) {
              var containerNode = el[0],
                  openMenuNode = el[0].firstElementChild,
                  openMenuNodeRect = openMenuNode.getBoundingClientRect(),
                  boundryNode = $document[0].body,
                  boundryNodeRect = boundryNode.getBoundingClientRect();
              var menuStyle = $window.getComputedStyle(openMenuNode);
              var originNode = opts.target[0].querySelector(prefixer.buildSelector('md-menu-origin')) || opts.target[0],
                  originNodeRect = originNode.getBoundingClientRect();
              var bounds = {
                left: boundryNodeRect.left + MENU_EDGE_MARGIN,
                top: Math.max(boundryNodeRect.top, 0) + MENU_EDGE_MARGIN,
                bottom: Math.max(boundryNodeRect.bottom, Math.max(boundryNodeRect.top, 0) + boundryNodeRect.height) - MENU_EDGE_MARGIN,
                right: boundryNodeRect.right - MENU_EDGE_MARGIN
              };
              var alignTarget,
                  alignTargetRect = {
                    top: 0,
                    left: 0,
                    right: 0,
                    bottom: 0
                  },
                  existingOffsets = {
                    top: 0,
                    left: 0,
                    right: 0,
                    bottom: 0
                  };
              var positionMode = opts.mdMenuCtrl.positionMode();
              if (positionMode.top == 'target' || positionMode.left == 'target' || positionMode.left == 'target-right') {
                alignTarget = firstVisibleChild();
                if (alignTarget) {
                  alignTarget = alignTarget.firstElementChild || alignTarget;
                  alignTarget = alignTarget.querySelector(prefixer.buildSelector('md-menu-align-target')) || alignTarget;
                  alignTargetRect = alignTarget.getBoundingClientRect();
                  existingOffsets = {
                    top: parseFloat(containerNode.style.top || 0),
                    left: parseFloat(containerNode.style.left || 0)
                  };
                }
              }
              var position = {};
              var transformOrigin = 'top ';
              switch (positionMode.top) {
                case 'target':
                  position.top = existingOffsets.top + originNodeRect.top - alignTargetRect.top;
                  break;
                case 'cascade':
                  position.top = originNodeRect.top - parseFloat(menuStyle.paddingTop) - originNode.style.top;
                  break;
                case 'bottom':
                  position.top = originNodeRect.top + originNodeRect.height;
                  break;
                default:
                  throw new Error('Invalid target mode "' + positionMode.top + '" specified for md-menu on Y axis.');
              }
              var rtl = ($mdUtil.bidi() == 'rtl');
              switch (positionMode.left) {
                case 'target':
                  position.left = existingOffsets.left + originNodeRect.left - alignTargetRect.left;
                  transformOrigin += rtl ? 'right' : 'left';
                  break;
                case 'target-left':
                  position.left = originNodeRect.left;
                  transformOrigin += 'left';
                  break;
                case 'target-right':
                  position.left = originNodeRect.right - openMenuNodeRect.width + (openMenuNodeRect.right - alignTargetRect.right);
                  transformOrigin += 'right';
                  break;
                case 'cascade':
                  var willFitRight = rtl ? (originNodeRect.left - openMenuNodeRect.width) < bounds.left : (originNodeRect.right + openMenuNodeRect.width) < bounds.right;
                  position.left = willFitRight ? originNodeRect.right - originNode.style.left : originNodeRect.left - originNode.style.left - openMenuNodeRect.width;
                  transformOrigin += willFitRight ? 'left' : 'right';
                  break;
                case 'right':
                  if (rtl) {
                    position.left = originNodeRect.right - originNodeRect.width;
                    transformOrigin += 'left';
                  } else {
                    position.left = originNodeRect.right - openMenuNodeRect.width;
                    transformOrigin += 'right';
                  }
                  break;
                case 'left':
                  if (rtl) {
                    position.left = originNodeRect.right - openMenuNodeRect.width;
                    transformOrigin += 'right';
                  } else {
                    position.left = originNodeRect.left;
                    transformOrigin += 'left';
                  }
                  break;
                default:
                  throw new Error('Invalid target mode "' + positionMode.left + '" specified for md-menu on X axis.');
              }
              var offsets = opts.mdMenuCtrl.offsets();
              position.top += offsets.top;
              position.left += offsets.left;
              clamp(position);
              var scaleX = Math.round(100 * Math.min(originNodeRect.width / containerNode.offsetWidth, 1.0)) / 100;
              var scaleY = Math.round(100 * Math.min(originNodeRect.height / containerNode.offsetHeight, 1.0)) / 100;
              return {
                top: Math.round(position.top),
                left: Math.round(position.left),
                transform: !opts.alreadyOpen ? $mdUtil.supplant('scale({0},{1})', [scaleX, scaleY]) : undefined,
                transformOrigin: transformOrigin
              };
              function clamp(pos) {
                pos.top = Math.max(Math.min(pos.top, bounds.bottom - containerNode.offsetHeight), bounds.top);
                pos.left = Math.max(Math.min(pos.left, bounds.right - containerNode.offsetWidth), bounds.left);
              }
              function firstVisibleChild() {
                for (var i = 0; i < openMenuNode.children.length; ++i) {
                  if ($window.getComputedStyle(openMenuNode.children[i]).display != 'none') {
                    return openMenuNode.children[i];
                  }
                }
              }
            }
          }
          function toNode(el) {
            if (el instanceof angular.element) {
              el = el[0];
            }
            return el;
          }
        }
        MenuProvider.$inject = ["$$interimElementProvider"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.menuBar').controller('MenuBarController', MenuBarController);
        var BOUND_MENU_METHODS = ['handleKeyDown', 'handleMenuHover', 'scheduleOpenHoveredMenu', 'cancelScheduledOpen'];
        function MenuBarController($scope, $rootScope, $element, $attrs, $mdConstant, $document, $mdUtil, $timeout) {
          this.$element = $element;
          this.$attrs = $attrs;
          this.$mdConstant = $mdConstant;
          this.$mdUtil = $mdUtil;
          this.$document = $document;
          this.$scope = $scope;
          this.$rootScope = $rootScope;
          this.$timeout = $timeout;
          var self = this;
          angular.forEach(BOUND_MENU_METHODS, function(methodName) {
            self[methodName] = angular.bind(self, self[methodName]);
          });
        }
        MenuBarController.$inject = ["$scope", "$rootScope", "$element", "$attrs", "$mdConstant", "$document", "$mdUtil", "$timeout"];
        MenuBarController.prototype.init = function() {
          var $element = this.$element;
          var $mdUtil = this.$mdUtil;
          var $scope = this.$scope;
          var self = this;
          var deregisterFns = [];
          $element.on('keydown', this.handleKeyDown);
          this.parentToolbar = $mdUtil.getClosest($element, 'MD-TOOLBAR');
          deregisterFns.push(this.$rootScope.$on('$mdMenuOpen', function(event, el) {
            if (self.getMenus().indexOf(el[0]) != -1) {
              $element[0].classList.add('_md-open');
              el[0].classList.add('_md-open');
              self.currentlyOpenMenu = el.controller('mdMenu');
              self.currentlyOpenMenu.registerContainerProxy(self.handleKeyDown);
              self.enableOpenOnHover();
            }
          }));
          deregisterFns.push(this.$rootScope.$on('$mdMenuClose', function(event, el, opts) {
            var rootMenus = self.getMenus();
            if (rootMenus.indexOf(el[0]) != -1) {
              $element[0].classList.remove('_md-open');
              el[0].classList.remove('_md-open');
            }
            if ($element[0].contains(el[0])) {
              var parentMenu = el[0];
              while (parentMenu && rootMenus.indexOf(parentMenu) == -1) {
                parentMenu = $mdUtil.getClosest(parentMenu, 'MD-MENU', true);
              }
              if (parentMenu) {
                if (!opts.skipFocus)
                  parentMenu.querySelector('button:not([disabled])').focus();
                self.currentlyOpenMenu = undefined;
                self.disableOpenOnHover();
                self.setKeyboardMode(true);
              }
            }
          }));
          $scope.$on('$destroy', function() {
            while (deregisterFns.length) {
              deregisterFns.shift()();
            }
          });
          this.setKeyboardMode(true);
        };
        MenuBarController.prototype.setKeyboardMode = function(enabled) {
          if (enabled)
            this.$element[0].classList.add('_md-keyboard-mode');
          else
            this.$element[0].classList.remove('_md-keyboard-mode');
        };
        MenuBarController.prototype.enableOpenOnHover = function() {
          if (this.openOnHoverEnabled)
            return;
          this.openOnHoverEnabled = true;
          var parentToolbar;
          if (parentToolbar = this.parentToolbar) {
            parentToolbar.dataset.mdRestoreStyle = parentToolbar.getAttribute('style');
            parentToolbar.style.position = 'relative';
            parentToolbar.style.zIndex = 100;
          }
          angular.element(this.getMenus()).on('mouseenter', this.handleMenuHover);
        };
        MenuBarController.prototype.handleMenuHover = function(e) {
          this.setKeyboardMode(false);
          if (this.openOnHoverEnabled) {
            this.scheduleOpenHoveredMenu(e);
          }
        };
        MenuBarController.prototype.disableOpenOnHover = function() {
          if (!this.openOnHoverEnabled)
            return;
          this.openOnHoverEnabled = false;
          var parentToolbar;
          if (parentToolbar = this.parentToolbar) {
            parentToolbar.style.cssText = parentToolbar.dataset.mdRestoreStyle || '';
          }
          angular.element(this.getMenus()).off('mouseenter', this.handleMenuHover);
        };
        MenuBarController.prototype.scheduleOpenHoveredMenu = function(e) {
          var menuEl = angular.element(e.currentTarget);
          var menuCtrl = menuEl.controller('mdMenu');
          this.setKeyboardMode(false);
          this.scheduleOpenMenu(menuCtrl);
        };
        MenuBarController.prototype.scheduleOpenMenu = function(menuCtrl) {
          var self = this;
          var $timeout = this.$timeout;
          if (menuCtrl != self.currentlyOpenMenu) {
            $timeout.cancel(self.pendingMenuOpen);
            self.pendingMenuOpen = $timeout(function() {
              self.pendingMenuOpen = undefined;
              if (self.currentlyOpenMenu) {
                self.currentlyOpenMenu.close(true, {closeAll: true});
              }
              menuCtrl.open();
            }, 200, false);
          }
        };
        MenuBarController.prototype.handleKeyDown = function(e) {
          var keyCodes = this.$mdConstant.KEY_CODE;
          var currentMenu = this.currentlyOpenMenu;
          var wasOpen = currentMenu && currentMenu.isOpen;
          this.setKeyboardMode(true);
          var handled,
              newMenu,
              newMenuCtrl;
          switch (e.keyCode) {
            case keyCodes.DOWN_ARROW:
              if (currentMenu) {
                currentMenu.focusMenuContainer();
              } else {
                this.openFocusedMenu();
              }
              handled = true;
              break;
            case keyCodes.UP_ARROW:
              currentMenu && currentMenu.close();
              handled = true;
              break;
            case keyCodes.LEFT_ARROW:
              newMenu = this.focusMenu(-1);
              if (wasOpen) {
                newMenuCtrl = angular.element(newMenu).controller('mdMenu');
                this.scheduleOpenMenu(newMenuCtrl);
              }
              handled = true;
              break;
            case keyCodes.RIGHT_ARROW:
              newMenu = this.focusMenu(+1);
              if (wasOpen) {
                newMenuCtrl = angular.element(newMenu).controller('mdMenu');
                this.scheduleOpenMenu(newMenuCtrl);
              }
              handled = true;
              break;
          }
          if (handled) {
            e && e.preventDefault && e.preventDefault();
            e && e.stopImmediatePropagation && e.stopImmediatePropagation();
          }
        };
        MenuBarController.prototype.focusMenu = function(direction) {
          var menus = this.getMenus();
          var focusedIndex = this.getFocusedMenuIndex();
          if (focusedIndex == -1) {
            focusedIndex = this.getOpenMenuIndex();
          }
          var changed = false;
          if (focusedIndex == -1) {
            focusedIndex = 0;
            changed = true;
          } else if (direction < 0 && focusedIndex > 0 || direction > 0 && focusedIndex < menus.length - direction) {
            focusedIndex += direction;
            changed = true;
          }
          if (changed) {
            menus[focusedIndex].querySelector('button').focus();
            return menus[focusedIndex];
          }
        };
        MenuBarController.prototype.openFocusedMenu = function() {
          var menu = this.getFocusedMenu();
          menu && angular.element(menu).controller('mdMenu').open();
        };
        MenuBarController.prototype.getMenus = function() {
          var $element = this.$element;
          return this.$mdUtil.nodesToArray($element[0].children).filter(function(el) {
            return el.nodeName == 'MD-MENU';
          });
        };
        MenuBarController.prototype.getFocusedMenu = function() {
          return this.getMenus()[this.getFocusedMenuIndex()];
        };
        MenuBarController.prototype.getFocusedMenuIndex = function() {
          var $mdUtil = this.$mdUtil;
          var focusedEl = $mdUtil.getClosest(this.$document[0].activeElement, 'MD-MENU');
          if (!focusedEl)
            return -1;
          var focusedIndex = this.getMenus().indexOf(focusedEl);
          return focusedIndex;
        };
        MenuBarController.prototype.getOpenMenuIndex = function() {
          var menus = this.getMenus();
          for (var i = 0; i < menus.length; ++i) {
            if (menus[i].classList.contains('_md-open'))
              return i;
          }
          return -1;
        };
      })();
      (function() {
        "use strict";
        angular.module('material.components.menuBar').directive('mdMenuBar', MenuBarDirective);
        function MenuBarDirective($mdUtil, $mdTheming) {
          return {
            restrict: 'E',
            require: 'mdMenuBar',
            controller: 'MenuBarController',
            compile: function compile(templateEl, templateAttrs) {
              if (!templateAttrs.ariaRole) {
                templateEl[0].setAttribute('role', 'menubar');
              }
              angular.forEach(templateEl[0].children, function(menuEl) {
                if (menuEl.nodeName == 'MD-MENU') {
                  if (!menuEl.hasAttribute('md-position-mode')) {
                    menuEl.setAttribute('md-position-mode', 'left bottom');
                    menuEl.querySelector('button, a, md-button').setAttribute('role', 'menuitem');
                  }
                  var contentEls = $mdUtil.nodesToArray(menuEl.querySelectorAll('md-menu-content'));
                  angular.forEach(contentEls, function(contentEl) {
                    contentEl.classList.add('_md-menu-bar-menu');
                    contentEl.classList.add('md-dense');
                    if (!contentEl.hasAttribute('width')) {
                      contentEl.setAttribute('width', 5);
                    }
                  });
                }
              });
              return function postLink(scope, el, attr, ctrl) {
                el.addClass('_md');
                $mdTheming(scope, el);
                ctrl.init();
              };
            }
          };
        }
        MenuBarDirective.$inject = ["$mdUtil", "$mdTheming"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.menuBar').directive('mdMenuDivider', MenuDividerDirective);
        function MenuDividerDirective() {
          return {
            restrict: 'E',
            compile: function(templateEl, templateAttrs) {
              if (!templateAttrs.role) {
                templateEl[0].setAttribute('role', 'separator');
              }
            }
          };
        }
      })();
      (function() {
        "use strict";
        angular.module('material.components.menuBar').controller('MenuItemController', MenuItemController);
        function MenuItemController($scope, $element, $attrs) {
          this.$element = $element;
          this.$attrs = $attrs;
          this.$scope = $scope;
        }
        MenuItemController.$inject = ["$scope", "$element", "$attrs"];
        MenuItemController.prototype.init = function(ngModel) {
          var $element = this.$element;
          var $attrs = this.$attrs;
          this.ngModel = ngModel;
          if ($attrs.type == 'checkbox' || $attrs.type == 'radio') {
            this.mode = $attrs.type;
            this.iconEl = $element[0].children[0];
            this.buttonEl = $element[0].children[1];
            if (ngModel) {
              this.initClickListeners();
            }
          }
        };
        MenuItemController.prototype.clearNgAria = function() {
          var el = this.$element[0];
          var clearAttrs = ['role', 'tabindex', 'aria-invalid', 'aria-checked'];
          angular.forEach(clearAttrs, function(attr) {
            el.removeAttribute(attr);
          });
        };
        MenuItemController.prototype.initClickListeners = function() {
          var self = this;
          var ngModel = this.ngModel;
          var $scope = this.$scope;
          var $attrs = this.$attrs;
          var $element = this.$element;
          var mode = this.mode;
          this.handleClick = angular.bind(this, this.handleClick);
          var icon = this.iconEl;
          var button = angular.element(this.buttonEl);
          var handleClick = this.handleClick;
          $attrs.$observe('disabled', setDisabled);
          setDisabled($attrs.disabled);
          ngModel.$render = function render() {
            self.clearNgAria();
            if (isSelected()) {
              icon.style.display = '';
              button.attr('aria-checked', 'true');
            } else {
              icon.style.display = 'none';
              button.attr('aria-checked', 'false');
            }
          };
          $scope.$$postDigest(ngModel.$render);
          function isSelected() {
            if (mode == 'radio') {
              var val = $attrs.ngValue ? $scope.$eval($attrs.ngValue) : $attrs.value;
              return ngModel.$modelValue == val;
            } else {
              return ngModel.$modelValue;
            }
          }
          function setDisabled(disabled) {
            if (disabled) {
              button.off('click', handleClick);
            } else {
              button.on('click', handleClick);
            }
          }
        };
        MenuItemController.prototype.handleClick = function(e) {
          var mode = this.mode;
          var ngModel = this.ngModel;
          var $attrs = this.$attrs;
          var newVal;
          if (mode == 'checkbox') {
            newVal = !ngModel.$modelValue;
          } else if (mode == 'radio') {
            newVal = $attrs.ngValue ? this.$scope.$eval($attrs.ngValue) : $attrs.value;
          }
          ngModel.$setViewValue(newVal);
          ngModel.$render();
        };
      })();
      (function() {
        "use strict";
        angular.module('material.components.menuBar').directive('mdMenuItem', MenuItemDirective);
        function MenuItemDirective($mdUtil) {
          return {
            require: ['mdMenuItem', '?ngModel'],
            priority: 210,
            compile: function(templateEl, templateAttrs) {
              if (isInsideMenuBar() && (templateAttrs.type == 'checkbox' || templateAttrs.type == 'radio')) {
                var text = templateEl[0].textContent;
                var buttonEl = angular.element('<md-button type="button"></md-button>');
                buttonEl.html(text);
                buttonEl.attr('tabindex', '0');
                templateEl.html('');
                templateEl.append(angular.element('<md-icon md-svg-icon="check"></md-icon>'));
                templateEl.append(buttonEl);
                templateEl[0].classList.add('md-indent');
                setDefault('role', (templateAttrs.type == 'checkbox') ? 'menuitemcheckbox' : 'menuitemradio', buttonEl);
                angular.forEach(['ng-disabled'], moveAttrToButton);
              } else {
                setDefault('role', 'menuitem', templateEl[0].querySelector('md-button, button, a'));
              }
              return function(scope, el, attrs, ctrls) {
                var ctrl = ctrls[0];
                var ngModel = ctrls[1];
                ctrl.init(ngModel);
              };
              function setDefault(attr, val, el) {
                el = el || templateEl;
                if (el instanceof angular.element) {
                  el = el[0];
                }
                if (!el.hasAttribute(attr)) {
                  el.setAttribute(attr, val);
                }
              }
              function moveAttrToButton(attr) {
                if (templateEl[0].hasAttribute(attr)) {
                  var val = templateEl[0].getAttribute(attr);
                  buttonEl[0].setAttribute(attr, val);
                  templateEl[0].removeAttribute(attr);
                }
              }
              function isInsideMenuBar() {
                return !!$mdUtil.getClosest(templateEl, 'md-menu-bar', true);
              }
            },
            controller: 'MenuItemController'
          };
        }
        MenuItemDirective.$inject = ["$mdUtil"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.progressCircular').directive('mdProgressCircular', MdProgressCircularDirective);
        function MdProgressCircularDirective($window, $mdProgressCircular, $mdTheming, $mdUtil, $interval, $log) {
          var rAF = $window.requestAnimationFrame || angular.noop;
          var cAF = $window.cancelAnimationFrame || angular.noop;
          var DEGREE_IN_RADIANS = $window.Math.PI / 180;
          var MODE_DETERMINATE = 'determinate';
          var MODE_INDETERMINATE = 'indeterminate';
          var DISABLED_CLASS = '_md-progress-circular-disabled';
          var INDETERMINATE_CLASS = '_md-mode-indeterminate';
          return {
            restrict: 'E',
            scope: {
              value: '@',
              mdDiameter: '@',
              mdMode: '@'
            },
            template: '<svg xmlns="http://www.w3.org/2000/svg">' + '<path fill="none"/>' + '</svg>',
            compile: function(element, attrs) {
              element.attr({
                'aria-valuemin': 0,
                'aria-valuemax': 100,
                'role': 'progressbar'
              });
              if (angular.isUndefined(attrs.mdMode)) {
                var hasValue = angular.isDefined(attrs.value);
                var mode = hasValue ? MODE_DETERMINATE : MODE_INDETERMINATE;
                var info = "Auto-adding the missing md-mode='{0}' to the ProgressCircular element";
                attrs.$set('mdMode', mode);
              } else {
                attrs.$set('mdMode', attrs.mdMode.trim());
              }
              return MdProgressCircularLink;
            }
          };
          function MdProgressCircularLink(scope, element, attrs) {
            var node = element[0];
            var svg = angular.element(node.querySelector('svg'));
            var path = angular.element(node.querySelector('path'));
            var startIndeterminate = $mdProgressCircular.startIndeterminate;
            var endIndeterminate = $mdProgressCircular.endIndeterminate;
            var rotationIndeterminate = 0;
            var lastAnimationId = 0;
            var lastDrawFrame;
            var interval;
            $mdTheming(element);
            element.toggleClass(DISABLED_CLASS, attrs.hasOwnProperty('disabled'));
            if (scope.mdMode === MODE_INDETERMINATE) {
              startIndeterminateAnimation();
            }
            scope.$on('$destroy', function() {
              cleanupIndeterminateAnimation();
              if (lastDrawFrame) {
                cAF(lastDrawFrame);
              }
            });
            scope.$watchGroup(['value', 'mdMode', function() {
              var isDisabled = node.disabled;
              if (isDisabled === true || isDisabled === false) {
                return isDisabled;
              }
              return angular.isDefined(element.attr('disabled'));
            }], function(newValues, oldValues) {
              var mode = newValues[1];
              var isDisabled = newValues[2];
              var wasDisabled = oldValues[2];
              if (isDisabled !== wasDisabled) {
                element.toggleClass(DISABLED_CLASS, !!isDisabled);
              }
              if (isDisabled) {
                cleanupIndeterminateAnimation();
              } else {
                if (mode !== MODE_DETERMINATE && mode !== MODE_INDETERMINATE) {
                  mode = MODE_INDETERMINATE;
                  attrs.$set('mdMode', mode);
                }
                if (mode === MODE_INDETERMINATE) {
                  startIndeterminateAnimation();
                } else {
                  var newValue = clamp(newValues[0]);
                  cleanupIndeterminateAnimation();
                  element.attr('aria-valuenow', newValue);
                  renderCircle(clamp(oldValues[0]), newValue);
                }
              }
            });
            scope.$watch('mdDiameter', function(newValue) {
              var diameter = getSize(newValue);
              var strokeWidth = getStroke(diameter);
              var transformOrigin = (diameter / 2) + 'px';
              var dimensions = {
                width: diameter + 'px',
                height: diameter + 'px'
              };
              svg[0].setAttribute('viewBox', '0 0 ' + diameter + ' ' + diameter);
              svg.css(dimensions).css('transform-origin', transformOrigin + ' ' + transformOrigin + ' ' + transformOrigin);
              element.css(dimensions);
              path.css('stroke-width', strokeWidth + 'px');
            });
            function renderCircle(animateFrom, animateTo, easing, duration, rotation) {
              var id = ++lastAnimationId;
              var startTime = $mdUtil.now();
              var changeInValue = animateTo - animateFrom;
              var diameter = getSize(scope.mdDiameter);
              var pathDiameter = diameter - getStroke(diameter);
              var ease = easing || $mdProgressCircular.easeFn;
              var animationDuration = duration || $mdProgressCircular.duration;
              if (animateTo === animateFrom) {
                path.attr('d', getSvgArc(animateTo, diameter, pathDiameter, rotation));
              } else {
                lastDrawFrame = rAF(function animation(now) {
                  var currentTime = $window.Math.max(0, $window.Math.min((now || $mdUtil.now()) - startTime, animationDuration));
                  path.attr('d', getSvgArc(ease(currentTime, animateFrom, changeInValue, animationDuration), diameter, pathDiameter, rotation));
                  if (id === lastAnimationId && currentTime < animationDuration) {
                    lastDrawFrame = rAF(animation);
                  }
                });
              }
            }
            function animateIndeterminate() {
              renderCircle(startIndeterminate, endIndeterminate, $mdProgressCircular.easeFnIndeterminate, $mdProgressCircular.durationIndeterminate, rotationIndeterminate);
              rotationIndeterminate = (rotationIndeterminate + endIndeterminate) % 100;
              var temp = startIndeterminate;
              startIndeterminate = -endIndeterminate;
              endIndeterminate = -temp;
            }
            function startIndeterminateAnimation() {
              if (!interval) {
                interval = $interval(animateIndeterminate, $mdProgressCircular.durationIndeterminate + 50, 0, false);
                animateIndeterminate();
                element.addClass(INDETERMINATE_CLASS).removeAttr('aria-valuenow');
              }
            }
            function cleanupIndeterminateAnimation() {
              if (interval) {
                $interval.cancel(interval);
                interval = null;
                element.removeClass(INDETERMINATE_CLASS);
              }
            }
          }
          function getSvgArc(current, diameter, pathDiameter, rotation) {
            var maximumAngle = 359.99 / 100;
            var startPoint = rotation || 0;
            var radius = diameter / 2;
            var pathRadius = pathDiameter / 2;
            var startAngle = startPoint * maximumAngle;
            var endAngle = current * maximumAngle;
            var start = polarToCartesian(radius, pathRadius, startAngle);
            var end = polarToCartesian(radius, pathRadius, endAngle + startAngle);
            var arcSweep = endAngle < 0 ? 0 : 1;
            var largeArcFlag;
            if (endAngle < 0) {
              largeArcFlag = endAngle >= -180 ? 0 : 1;
            } else {
              largeArcFlag = endAngle <= 180 ? 0 : 1;
            }
            return 'M' + start + 'A' + pathRadius + ',' + pathRadius + ' 0 ' + largeArcFlag + ',' + arcSweep + ' ' + end;
          }
          function polarToCartesian(radius, pathRadius, angleInDegrees) {
            var angleInRadians = (angleInDegrees - 90) * DEGREE_IN_RADIANS;
            return (radius + (pathRadius * $window.Math.cos(angleInRadians))) + ',' + (radius + (pathRadius * $window.Math.sin(angleInRadians)));
          }
          function clamp(value) {
            return $window.Math.max(0, $window.Math.min(value || 0, 100));
          }
          function getSize(value) {
            var defaultValue = $mdProgressCircular.progressSize;
            if (value) {
              var parsed = parseFloat(value);
              if (value.lastIndexOf('%') === value.length - 1) {
                parsed = (parsed / 100) * defaultValue;
              }
              return parsed;
            }
            return defaultValue;
          }
          function getStroke(diameter) {
            return $mdProgressCircular.strokeWidth / 100 * diameter;
          }
        }
        MdProgressCircularDirective.$inject = ["$window", "$mdProgressCircular", "$mdTheming", "$mdUtil", "$interval", "$log"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.progressCircular').provider("$mdProgressCircular", MdProgressCircularProvider);
        function MdProgressCircularProvider() {
          var progressConfig = {
            progressSize: 50,
            strokeWidth: 10,
            duration: 100,
            easeFn: linearEase,
            durationIndeterminate: 500,
            startIndeterminate: 3,
            endIndeterminate: 80,
            easeFnIndeterminate: materialEase,
            easingPresets: {
              linearEase: linearEase,
              materialEase: materialEase
            }
          };
          return {
            configure: function(options) {
              progressConfig = angular.extend(progressConfig, options || {});
              return progressConfig;
            },
            $get: function() {
              return progressConfig;
            }
          };
          function linearEase(t, b, c, d) {
            return c * t / d + b;
          }
          function materialEase(t, b, c, d) {
            var ts = (t /= d) * t;
            var tc = ts * t;
            return b + c * (6 * tc * ts + -15 * ts * ts + 10 * tc);
          }
        }
      })();
      (function() {
        "use strict";
        angular.module('material.components.tabs').directive('mdTab', MdTab);
        function MdTab() {
          return {
            require: '^?mdTabs',
            terminal: true,
            compile: function(element, attr) {
              var label = firstChild(element, 'md-tab-label'),
                  body = firstChild(element, 'md-tab-body');
              if (label.length == 0) {
                label = angular.element('<md-tab-label></md-tab-label>');
                if (attr.label)
                  label.text(attr.label);
                else
                  label.append(element.contents());
                if (body.length == 0) {
                  var contents = element.contents().detach();
                  body = angular.element('<md-tab-body></md-tab-body>');
                  body.append(contents);
                }
              }
              element.append(label);
              if (body.html())
                element.append(body);
              return postLink;
            },
            scope: {
              active: '=?mdActive',
              disabled: '=?ngDisabled',
              select: '&?mdOnSelect',
              deselect: '&?mdOnDeselect'
            }
          };
          function postLink(scope, element, attr, ctrl) {
            if (!ctrl)
              return;
            var index = ctrl.getTabElementIndex(element),
                body = firstChild(element, 'md-tab-body').remove(),
                label = firstChild(element, 'md-tab-label').remove(),
                data = ctrl.insertTab({
                  scope: scope,
                  parent: scope.$parent,
                  index: index,
                  element: element,
                  template: body.html(),
                  label: label.html()
                }, index);
            scope.select = scope.select || angular.noop;
            scope.deselect = scope.deselect || angular.noop;
            scope.$watch('active', function(active) {
              if (active)
                ctrl.select(data.getIndex(), true);
            });
            scope.$watch('disabled', function() {
              ctrl.refreshIndex();
            });
            scope.$watch(function() {
              return ctrl.getTabElementIndex(element);
            }, function(newIndex) {
              data.index = newIndex;
              ctrl.updateTabOrder();
            });
            scope.$on('$destroy', function() {
              ctrl.removeTab(data);
            });
          }
          function firstChild(element, tagName) {
            var children = element[0].children;
            for (var i = 0,
                len = children.length; i < len; i++) {
              var child = children[i];
              if (child.tagName === tagName.toUpperCase())
                return angular.element(child);
            }
            return angular.element();
          }
        }
      })();
      (function() {
        "use strict";
        angular.module('material.components.tabs').directive('mdTabItem', MdTabItem);
        function MdTabItem() {
          return {
            require: '^?mdTabs',
            link: function link(scope, element, attr, ctrl) {
              if (!ctrl)
                return;
              ctrl.attachRipple(scope, element);
            }
          };
        }
      })();
      (function() {
        "use strict";
        angular.module('material.components.tabs').directive('mdTabLabel', MdTabLabel);
        function MdTabLabel() {
          return {terminal: true};
        }
      })();
      (function() {
        "use strict";
        angular.module('material.components.tabs').directive('mdTabScroll', MdTabScroll);
        function MdTabScroll($parse) {
          return {
            restrict: 'A',
            compile: function($element, attr) {
              var fn = $parse(attr.mdTabScroll, null, true);
              return function ngEventHandler(scope, element) {
                element.on('mousewheel', function(event) {
                  scope.$apply(function() {
                    fn(scope, {$event: event});
                  });
                });
              };
            }
          };
        }
        MdTabScroll.$inject = ["$parse"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.tabs').controller('MdTabsController', MdTabsController);
        function MdTabsController($scope, $element, $window, $mdConstant, $mdTabInkRipple, $mdUtil, $animateCss, $attrs, $compile, $mdTheming) {
          var ctrl = this,
              locked = false,
              elements = getElements(),
              queue = [],
              destroyed = false,
              loaded = false;
          defineOneWayBinding('stretchTabs', handleStretchTabs);
          defineProperty('focusIndex', handleFocusIndexChange, ctrl.selectedIndex || 0);
          defineProperty('offsetLeft', handleOffsetChange, 0);
          defineProperty('hasContent', handleHasContent, false);
          defineProperty('maxTabWidth', handleMaxTabWidth, getMaxTabWidth());
          defineProperty('shouldPaginate', handleShouldPaginate, false);
          defineBooleanAttribute('noInkBar', handleInkBar);
          defineBooleanAttribute('dynamicHeight', handleDynamicHeight);
          defineBooleanAttribute('noPagination');
          defineBooleanAttribute('swipeContent');
          defineBooleanAttribute('noDisconnect');
          defineBooleanAttribute('autoselect');
          defineBooleanAttribute('noSelectClick');
          defineBooleanAttribute('centerTabs', handleCenterTabs, false);
          defineBooleanAttribute('enableDisconnect');
          ctrl.scope = $scope;
          ctrl.parent = $scope.$parent;
          ctrl.tabs = [];
          ctrl.lastSelectedIndex = null;
          ctrl.hasFocus = false;
          ctrl.lastClick = true;
          ctrl.shouldCenterTabs = shouldCenterTabs();
          ctrl.updatePagination = $mdUtil.debounce(updatePagination, 100);
          ctrl.redirectFocus = redirectFocus;
          ctrl.attachRipple = attachRipple;
          ctrl.insertTab = insertTab;
          ctrl.removeTab = removeTab;
          ctrl.select = select;
          ctrl.scroll = scroll;
          ctrl.nextPage = nextPage;
          ctrl.previousPage = previousPage;
          ctrl.keydown = keydown;
          ctrl.canPageForward = canPageForward;
          ctrl.canPageBack = canPageBack;
          ctrl.refreshIndex = refreshIndex;
          ctrl.incrementIndex = incrementIndex;
          ctrl.getTabElementIndex = getTabElementIndex;
          ctrl.updateInkBarStyles = $mdUtil.debounce(updateInkBarStyles, 100);
          ctrl.updateTabOrder = $mdUtil.debounce(updateTabOrder, 100);
          init();
          function init() {
            ctrl.selectedIndex = ctrl.selectedIndex || 0;
            compileTemplate();
            configureWatchers();
            bindEvents();
            $mdTheming($element);
            $mdUtil.nextTick(function() {
              elements = getElements();
              updateHeightFromContent();
              adjustOffset();
              updateInkBarStyles();
              ctrl.tabs[ctrl.selectedIndex] && ctrl.tabs[ctrl.selectedIndex].scope.select();
              loaded = true;
              updatePagination();
            });
          }
          function compileTemplate() {
            var template = $attrs.$mdTabsTemplate,
                element = angular.element($element[0].querySelector('md-tab-data'));
            element.html(template);
            $compile(element.contents())(ctrl.parent);
            delete $attrs.$mdTabsTemplate;
          }
          function bindEvents() {
            angular.element($window).on('resize', handleWindowResize);
            $scope.$on('$destroy', cleanup);
          }
          function configureWatchers() {
            $scope.$watch('$mdTabsCtrl.selectedIndex', handleSelectedIndexChange);
          }
          function defineOneWayBinding(key, handler) {
            var attr = $attrs.$normalize('md-' + key);
            if (handler)
              defineProperty(key, handler);
            $attrs.$observe(attr, function(newValue) {
              ctrl[key] = newValue;
            });
          }
          function defineBooleanAttribute(key, handler) {
            var attr = $attrs.$normalize('md-' + key);
            if (handler)
              defineProperty(key, handler);
            if ($attrs.hasOwnProperty(attr))
              updateValue($attrs[attr]);
            $attrs.$observe(attr, updateValue);
            function updateValue(newValue) {
              ctrl[key] = newValue !== 'false';
            }
          }
          function cleanup() {
            destroyed = true;
            angular.element($window).off('resize', handleWindowResize);
          }
          function handleStretchTabs(stretchTabs) {
            var elements = getElements();
            angular.element(elements.wrapper).toggleClass('md-stretch-tabs', shouldStretchTabs());
            updateInkBarStyles();
          }
          function handleCenterTabs(newValue) {
            ctrl.shouldCenterTabs = shouldCenterTabs();
          }
          function handleMaxTabWidth(newWidth, oldWidth) {
            if (newWidth !== oldWidth) {
              var elements = getElements();
              angular.forEach(elements.tabs, function(tab) {
                tab.style.maxWidth = newWidth + 'px';
              });
              $mdUtil.nextTick(ctrl.updateInkBarStyles);
            }
          }
          function handleShouldPaginate(newValue, oldValue) {
            if (newValue !== oldValue) {
              ctrl.maxTabWidth = getMaxTabWidth();
              ctrl.shouldCenterTabs = shouldCenterTabs();
              $mdUtil.nextTick(function() {
                ctrl.maxTabWidth = getMaxTabWidth();
                adjustOffset(ctrl.selectedIndex);
              });
            }
          }
          function handleHasContent(hasContent) {
            $element[hasContent ? 'removeClass' : 'addClass']('md-no-tab-content');
          }
          function handleOffsetChange(left) {
            var elements = getElements();
            var newValue = ctrl.shouldCenterTabs ? '' : '-' + left + 'px';
            angular.element(elements.paging).css($mdConstant.CSS.TRANSFORM, 'translate3d(' + newValue + ', 0, 0)');
            $scope.$broadcast('$mdTabsPaginationChanged');
          }
          function handleFocusIndexChange(newIndex, oldIndex) {
            if (newIndex === oldIndex)
              return;
            if (!getElements().tabs[newIndex])
              return;
            adjustOffset();
            redirectFocus();
          }
          function handleSelectedIndexChange(newValue, oldValue) {
            if (newValue === oldValue)
              return;
            ctrl.selectedIndex = getNearestSafeIndex(newValue);
            ctrl.lastSelectedIndex = oldValue;
            ctrl.updateInkBarStyles();
            updateHeightFromContent();
            adjustOffset(newValue);
            $scope.$broadcast('$mdTabsChanged');
            ctrl.tabs[oldValue] && ctrl.tabs[oldValue].scope.deselect();
            ctrl.tabs[newValue] && ctrl.tabs[newValue].scope.select();
          }
          function getTabElementIndex(tabEl) {
            var tabs = $element[0].getElementsByTagName('md-tab');
            return Array.prototype.indexOf.call(tabs, tabEl[0]);
          }
          function handleResizeWhenVisible() {
            if (handleResizeWhenVisible.watcher)
              return;
            handleResizeWhenVisible.watcher = $scope.$watch(function() {
              $mdUtil.nextTick(function() {
                if (!handleResizeWhenVisible.watcher)
                  return;
                if ($element.prop('offsetParent')) {
                  handleResizeWhenVisible.watcher();
                  handleResizeWhenVisible.watcher = null;
                  handleWindowResize();
                }
              }, false);
            });
          }
          function keydown(event) {
            switch (event.keyCode) {
              case $mdConstant.KEY_CODE.LEFT_ARROW:
                event.preventDefault();
                incrementIndex(-1, true);
                break;
              case $mdConstant.KEY_CODE.RIGHT_ARROW:
                event.preventDefault();
                incrementIndex(1, true);
                break;
              case $mdConstant.KEY_CODE.SPACE:
              case $mdConstant.KEY_CODE.ENTER:
                event.preventDefault();
                if (!locked)
                  select(ctrl.focusIndex);
                break;
            }
            ctrl.lastClick = false;
          }
          function select(index, canSkipClick) {
            if (!locked)
              ctrl.focusIndex = ctrl.selectedIndex = index;
            ctrl.lastClick = true;
            if (canSkipClick && ctrl.noSelectClick)
              return;
            $mdUtil.nextTick(function() {
              ctrl.tabs[index].element.triggerHandler('click');
            }, false);
          }
          function scroll(event) {
            if (!ctrl.shouldPaginate)
              return;
            event.preventDefault();
            ctrl.offsetLeft = fixOffset(ctrl.offsetLeft - event.wheelDelta);
          }
          function nextPage() {
            var elements = getElements();
            var viewportWidth = elements.canvas.clientWidth,
                totalWidth = viewportWidth + ctrl.offsetLeft,
                i,
                tab;
            for (i = 0; i < elements.tabs.length; i++) {
              tab = elements.tabs[i];
              if (tab.offsetLeft + tab.offsetWidth > totalWidth)
                break;
            }
            ctrl.offsetLeft = fixOffset(tab.offsetLeft);
          }
          function previousPage() {
            var i,
                tab,
                elements = getElements();
            for (i = 0; i < elements.tabs.length; i++) {
              tab = elements.tabs[i];
              if (tab.offsetLeft + tab.offsetWidth >= ctrl.offsetLeft)
                break;
            }
            ctrl.offsetLeft = fixOffset(tab.offsetLeft + tab.offsetWidth - elements.canvas.clientWidth);
          }
          function handleWindowResize() {
            ctrl.lastSelectedIndex = ctrl.selectedIndex;
            ctrl.offsetLeft = fixOffset(ctrl.offsetLeft);
            $mdUtil.nextTick(function() {
              ctrl.updateInkBarStyles();
              updatePagination();
            });
          }
          function handleInkBar(hide) {
            angular.element(getElements().inkBar).toggleClass('ng-hide', hide);
          }
          function handleDynamicHeight(value) {
            $element.toggleClass('md-dynamic-height', value);
          }
          function removeTab(tabData) {
            if (destroyed)
              return;
            var selectedIndex = ctrl.selectedIndex,
                tab = ctrl.tabs.splice(tabData.getIndex(), 1)[0];
            refreshIndex();
            if (ctrl.selectedIndex === selectedIndex) {
              tab.scope.deselect();
              ctrl.tabs[ctrl.selectedIndex] && ctrl.tabs[ctrl.selectedIndex].scope.select();
            }
            $mdUtil.nextTick(function() {
              updatePagination();
              ctrl.offsetLeft = fixOffset(ctrl.offsetLeft);
            });
          }
          function insertTab(tabData, index) {
            var hasLoaded = loaded;
            var proto = {
              getIndex: function() {
                return ctrl.tabs.indexOf(tab);
              },
              isActive: function() {
                return this.getIndex() === ctrl.selectedIndex;
              },
              isLeft: function() {
                return this.getIndex() < ctrl.selectedIndex;
              },
              isRight: function() {
                return this.getIndex() > ctrl.selectedIndex;
              },
              shouldRender: function() {
                return !ctrl.noDisconnect || this.isActive();
              },
              hasFocus: function() {
                return !ctrl.lastClick && ctrl.hasFocus && this.getIndex() === ctrl.focusIndex;
              },
              id: $mdUtil.nextUid()
            },
                tab = angular.extend(proto, tabData);
            if (angular.isDefined(index)) {
              ctrl.tabs.splice(index, 0, tab);
            } else {
              ctrl.tabs.push(tab);
            }
            processQueue();
            updateHasContent();
            $mdUtil.nextTick(function() {
              updatePagination();
              if (hasLoaded && ctrl.autoselect)
                $mdUtil.nextTick(function() {
                  $mdUtil.nextTick(function() {
                    select(ctrl.tabs.indexOf(tab));
                  });
                });
            });
            return tab;
          }
          function getElements() {
            var elements = {};
            var node = $element[0];
            elements.wrapper = node.querySelector('md-tabs-wrapper');
            elements.canvas = elements.wrapper.querySelector('md-tabs-canvas');
            elements.paging = elements.canvas.querySelector('md-pagination-wrapper');
            elements.inkBar = elements.paging.querySelector('md-ink-bar');
            elements.contents = node.querySelectorAll('md-tabs-content-wrapper > md-tab-content');
            elements.tabs = elements.paging.querySelectorAll('md-tab-item');
            elements.dummies = elements.canvas.querySelectorAll('md-dummy-tab');
            return elements;
          }
          function canPageBack() {
            return ctrl.offsetLeft > 0;
          }
          function canPageForward() {
            var elements = getElements();
            var lastTab = elements.tabs[elements.tabs.length - 1];
            return lastTab && lastTab.offsetLeft + lastTab.offsetWidth > elements.canvas.clientWidth + ctrl.offsetLeft;
          }
          function shouldStretchTabs() {
            switch (ctrl.stretchTabs) {
              case 'always':
                return true;
              case 'never':
                return false;
              default:
                return !ctrl.shouldPaginate && $window.matchMedia('(max-width: 600px)').matches;
            }
          }
          function shouldCenterTabs() {
            return ctrl.centerTabs && !ctrl.shouldPaginate;
          }
          function shouldPaginate() {
            if (ctrl.noPagination || !loaded)
              return false;
            var canvasWidth = $element.prop('clientWidth');
            angular.forEach(getElements().dummies, function(tab) {
              canvasWidth -= tab.offsetWidth;
            });
            return canvasWidth < 0;
          }
          function getNearestSafeIndex(newIndex) {
            if (newIndex === -1)
              return -1;
            var maxOffset = Math.max(ctrl.tabs.length - newIndex, newIndex),
                i,
                tab;
            for (i = 0; i <= maxOffset; i++) {
              tab = ctrl.tabs[newIndex + i];
              if (tab && (tab.scope.disabled !== true))
                return tab.getIndex();
              tab = ctrl.tabs[newIndex - i];
              if (tab && (tab.scope.disabled !== true))
                return tab.getIndex();
            }
            return newIndex;
          }
          function defineProperty(key, handler, value) {
            Object.defineProperty(ctrl, key, {
              get: function() {
                return value;
              },
              set: function(newValue) {
                var oldValue = value;
                value = newValue;
                handler && handler(newValue, oldValue);
              }
            });
          }
          function updatePagination() {
            updatePagingWidth();
            ctrl.maxTabWidth = getMaxTabWidth();
            ctrl.shouldPaginate = shouldPaginate();
          }
          function updatePagingWidth() {
            var elements = getElements();
            if (shouldStretchTabs()) {
              angular.element(elements.paging).css('width', '');
            } else {
              angular.element(elements.paging).css('width', calcPagingWidth() + 'px');
            }
          }
          function calcPagingWidth() {
            return calcTabsWidth(getElements().dummies);
          }
          function calcTabsWidth(tabs) {
            var width = 0;
            angular.forEach(tabs, function(tab) {
              width += Math.max(tab.offsetWidth, tab.getBoundingClientRect().width);
            });
            return Math.ceil(width);
          }
          function getMaxTabWidth() {
            return $element.prop('clientWidth');
          }
          function updateTabOrder() {
            var selectedItem = ctrl.tabs[ctrl.selectedIndex],
                focusItem = ctrl.tabs[ctrl.focusIndex];
            ctrl.tabs = ctrl.tabs.sort(function(a, b) {
              return a.index - b.index;
            });
            ctrl.selectedIndex = ctrl.tabs.indexOf(selectedItem);
            ctrl.focusIndex = ctrl.tabs.indexOf(focusItem);
          }
          function incrementIndex(inc, focus) {
            var newIndex,
                key = focus ? 'focusIndex' : 'selectedIndex',
                index = ctrl[key];
            for (newIndex = index + inc; ctrl.tabs[newIndex] && ctrl.tabs[newIndex].scope.disabled; newIndex += inc) {}
            if (ctrl.tabs[newIndex]) {
              ctrl[key] = newIndex;
            }
          }
          function redirectFocus() {
            getElements().dummies[ctrl.focusIndex].focus();
          }
          function adjustOffset(index) {
            var elements = getElements();
            if (index == null)
              index = ctrl.focusIndex;
            if (!elements.tabs[index])
              return;
            if (ctrl.shouldCenterTabs)
              return;
            var tab = elements.tabs[index],
                left = tab.offsetLeft,
                right = tab.offsetWidth + left;
            ctrl.offsetLeft = Math.max(ctrl.offsetLeft, fixOffset(right - elements.canvas.clientWidth + 32 * 2));
            ctrl.offsetLeft = Math.min(ctrl.offsetLeft, fixOffset(left));
          }
          function processQueue() {
            queue.forEach(function(func) {
              $mdUtil.nextTick(func);
            });
            queue = [];
          }
          function updateHasContent() {
            var hasContent = false;
            angular.forEach(ctrl.tabs, function(tab) {
              if (tab.template)
                hasContent = true;
            });
            ctrl.hasContent = hasContent;
          }
          function refreshIndex() {
            ctrl.selectedIndex = getNearestSafeIndex(ctrl.selectedIndex);
            ctrl.focusIndex = getNearestSafeIndex(ctrl.focusIndex);
          }
          function updateHeightFromContent() {
            if (!ctrl.dynamicHeight)
              return $element.css('height', '');
            if (!ctrl.tabs.length)
              return queue.push(updateHeightFromContent);
            var elements = getElements();
            var tabContent = elements.contents[ctrl.selectedIndex],
                contentHeight = tabContent ? tabContent.offsetHeight : 0,
                tabsHeight = elements.wrapper.offsetHeight,
                newHeight = contentHeight + tabsHeight,
                currentHeight = $element.prop('clientHeight');
            if (currentHeight === newHeight)
              return;
            if ($element.attr('md-align-tabs') === 'bottom') {
              currentHeight -= tabsHeight;
              newHeight -= tabsHeight;
              if ($element.attr('md-border-bottom') !== undefined)
                ++currentHeight;
            }
            locked = true;
            var fromHeight = {height: currentHeight + 'px'},
                toHeight = {height: newHeight + 'px'};
            $element.css(fromHeight);
            $animateCss($element, {
              from: fromHeight,
              to: toHeight,
              easing: 'cubic-bezier(0.35, 0, 0.25, 1)',
              duration: 0.5
            }).start().done(function() {
              $element.css({
                transition: 'none',
                height: ''
              });
              $mdUtil.nextTick(function() {
                $element.css('transition', '');
              });
              locked = false;
            });
          }
          function updateInkBarStyles() {
            var elements = getElements();
            if (!elements.tabs[ctrl.selectedIndex]) {
              angular.element(elements.inkBar).css({
                left: 'auto',
                right: 'auto'
              });
              return;
            }
            if (!ctrl.tabs.length)
              return queue.push(ctrl.updateInkBarStyles);
            if (!$element.prop('offsetParent'))
              return handleResizeWhenVisible();
            var index = ctrl.selectedIndex,
                totalWidth = elements.paging.offsetWidth,
                tab = elements.tabs[index],
                left = tab.offsetLeft,
                right = totalWidth - left - tab.offsetWidth;
            if (ctrl.shouldCenterTabs) {
              var tabWidth = calcTabsWidth(elements.tabs);
              if (totalWidth > tabWidth) {
                $mdUtil.nextTick(updateInkBarStyles, false);
              }
            }
            updateInkBarClassName();
            angular.element(elements.inkBar).css({
              left: left + 'px',
              right: right + 'px'
            });
          }
          function updateInkBarClassName() {
            var elements = getElements();
            var newIndex = ctrl.selectedIndex,
                oldIndex = ctrl.lastSelectedIndex,
                ink = angular.element(elements.inkBar);
            if (!angular.isNumber(oldIndex))
              return;
            ink.toggleClass('md-left', newIndex < oldIndex).toggleClass('md-right', newIndex > oldIndex);
          }
          function fixOffset(value) {
            var elements = getElements();
            if (!elements.tabs.length || !ctrl.shouldPaginate)
              return 0;
            var lastTab = elements.tabs[elements.tabs.length - 1],
                totalWidth = lastTab.offsetLeft + lastTab.offsetWidth;
            value = Math.max(0, value);
            value = Math.min(totalWidth - elements.canvas.clientWidth, value);
            return value;
          }
          function attachRipple(scope, element) {
            var elements = getElements();
            var options = {colorElement: angular.element(elements.inkBar)};
            $mdTabInkRipple.attach(scope, element, options);
          }
        }
        MdTabsController.$inject = ["$scope", "$element", "$window", "$mdConstant", "$mdTabInkRipple", "$mdUtil", "$animateCss", "$attrs", "$compile", "$mdTheming"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.tabs').directive('mdTabs', MdTabs);
        function MdTabs($$mdSvgRegistry) {
          return {
            scope: {selectedIndex: '=?mdSelected'},
            template: function(element, attr) {
              attr["$mdTabsTemplate"] = element.html();
              return '' + '<md-tabs-wrapper> ' + '<md-tab-data></md-tab-data> ' + '<md-prev-button ' + 'tabindex="-1" ' + 'role="button" ' + 'aria-label="Previous Page" ' + 'aria-disabled="{{!$mdTabsCtrl.canPageBack()}}" ' + 'ng-class="{ \'md-disabled\': !$mdTabsCtrl.canPageBack() }" ' + 'ng-if="$mdTabsCtrl.shouldPaginate" ' + 'ng-click="$mdTabsCtrl.previousPage()"> ' + '<md-icon md-svg-src="' + $$mdSvgRegistry.mdTabsArrow + '"></md-icon> ' + '</md-prev-button> ' + '<md-next-button ' + 'tabindex="-1" ' + 'role="button" ' + 'aria-label="Next Page" ' + 'aria-disabled="{{!$mdTabsCtrl.canPageForward()}}" ' + 'ng-class="{ \'md-disabled\': !$mdTabsCtrl.canPageForward() }" ' + 'ng-if="$mdTabsCtrl.shouldPaginate" ' + 'ng-click="$mdTabsCtrl.nextPage()"> ' + '<md-icon md-svg-src="' + $$mdSvgRegistry.mdTabsArrow + '"></md-icon> ' + '</md-next-button> ' + '<md-tabs-canvas ' + 'tabindex="{{ $mdTabsCtrl.hasFocus ? -1 : 0 }}" ' + 'aria-activedescendant="tab-item-{{$mdTabsCtrl.tabs[$mdTabsCtrl.focusIndex].id}}" ' + 'ng-focus="$mdTabsCtrl.redirectFocus()" ' + 'ng-class="{ ' + '\'md-paginated\': $mdTabsCtrl.shouldPaginate, ' + '\'md-center-tabs\': $mdTabsCtrl.shouldCenterTabs ' + '}" ' + 'ng-keydown="$mdTabsCtrl.keydown($event)" ' + 'role="tablist"> ' + '<md-pagination-wrapper ' + 'ng-class="{ \'md-center-tabs\': $mdTabsCtrl.shouldCenterTabs }" ' + 'md-tab-scroll="$mdTabsCtrl.scroll($event)"> ' + '<md-tab-item ' + 'tabindex="-1" ' + 'class="md-tab" ' + 'ng-repeat="tab in $mdTabsCtrl.tabs" ' + 'role="tab" ' + 'aria-controls="tab-content-{{::tab.id}}" ' + 'aria-selected="{{tab.isActive()}}" ' + 'aria-disabled="{{tab.scope.disabled || \'false\'}}" ' + 'ng-click="$mdTabsCtrl.select(tab.getIndex())" ' + 'ng-class="{ ' + '\'md-active\':    tab.isActive(), ' + '\'md-focused\':   tab.hasFocus(), ' + '\'md-disabled\':  tab.scope.disabled ' + '}" ' + 'ng-disabled="tab.scope.disabled" ' + 'md-swipe-left="$mdTabsCtrl.nextPage()" ' + 'md-swipe-right="$mdTabsCtrl.previousPage()" ' + 'md-tabs-template="::tab.label" ' + 'md-scope="::tab.parent"></md-tab-item> ' + '<md-ink-bar></md-ink-bar> ' + '</md-pagination-wrapper> ' + '<md-tabs-dummy-wrapper class="_md-visually-hidden md-dummy-wrapper"> ' + '<md-dummy-tab ' + 'class="md-tab" ' + 'tabindex="-1" ' + 'id="tab-item-{{::tab.id}}" ' + 'role="tab" ' + 'aria-controls="tab-content-{{::tab.id}}" ' + 'aria-selected="{{tab.isActive()}}" ' + 'aria-disabled="{{tab.scope.disabled || \'false\'}}" ' + 'ng-focus="$mdTabsCtrl.hasFocus = true" ' + 'ng-blur="$mdTabsCtrl.hasFocus = false" ' + 'ng-repeat="tab in $mdTabsCtrl.tabs" ' + 'md-tabs-template="::tab.label" ' + 'md-scope="::tab.parent"></md-dummy-tab> ' + '</md-tabs-dummy-wrapper> ' + '</md-tabs-canvas> ' + '</md-tabs-wrapper> ' + '<md-tabs-content-wrapper ng-show="$mdTabsCtrl.hasContent && $mdTabsCtrl.selectedIndex >= 0" class="_md"> ' + '<md-tab-content ' + 'id="tab-content-{{::tab.id}}" ' + 'class="_md" ' + 'role="tabpanel" ' + 'aria-labelledby="tab-item-{{::tab.id}}" ' + 'md-swipe-left="$mdTabsCtrl.swipeContent && $mdTabsCtrl.incrementIndex(1)" ' + 'md-swipe-right="$mdTabsCtrl.swipeContent && $mdTabsCtrl.incrementIndex(-1)" ' + 'ng-if="$mdTabsCtrl.hasContent" ' + 'ng-repeat="(index, tab) in $mdTabsCtrl.tabs" ' + 'ng-class="{ ' + '\'md-no-transition\': $mdTabsCtrl.lastSelectedIndex == null, ' + '\'md-active\':        tab.isActive(), ' + '\'md-left\':          tab.isLeft(), ' + '\'md-right\':         tab.isRight(), ' + '\'md-no-scroll\':     $mdTabsCtrl.dynamicHeight ' + '}"> ' + '<div ' + 'md-tabs-template="::tab.template" ' + 'md-connected-if="tab.isActive()" ' + 'md-scope="::tab.parent" ' + 'ng-if="$mdTabsCtrl.enableDisconnect || tab.shouldRender()"></div> ' + '</md-tab-content> ' + '</md-tabs-content-wrapper>';
            },
            controller: 'MdTabsController',
            controllerAs: '$mdTabsCtrl',
            bindToController: true
          };
        }
        MdTabs.$inject = ["$$mdSvgRegistry"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.tabs').directive('mdTabsDummyWrapper', MdTabsDummyWrapper);
        function MdTabsDummyWrapper($mdUtil) {
          return {
            require: '^?mdTabs',
            link: function link(scope, element, attr, ctrl) {
              if (!ctrl)
                return;
              var observer = new MutationObserver(function(mutations) {
                ctrl.updatePagination();
                ctrl.updateInkBarStyles();
              });
              var config = {
                childList: true,
                subtree: true,
                characterData: true
              };
              observer.observe(element[0], config);
              scope.$on('$destroy', function() {
                if (observer) {
                  observer.disconnect();
                }
              });
            }
          };
        }
        MdTabsDummyWrapper.$inject = ["$mdUtil"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.tabs').directive('mdTabsTemplate', MdTabsTemplate);
        function MdTabsTemplate($compile, $mdUtil) {
          return {
            restrict: 'A',
            link: link,
            scope: {
              template: '=mdTabsTemplate',
              connected: '=?mdConnectedIf',
              compileScope: '=mdScope'
            },
            require: '^?mdTabs'
          };
          function link(scope, element, attr, ctrl) {
            if (!ctrl)
              return;
            var compileScope = ctrl.enableDisconnect ? scope.compileScope.$new() : scope.compileScope;
            element.html(scope.template);
            $compile(element.contents())(compileScope);
            return $mdUtil.nextTick(handleScope);
            function handleScope() {
              scope.$watch('connected', function(value) {
                value === false ? disconnect() : reconnect();
              });
              scope.$on('$destroy', reconnect);
            }
            function disconnect() {
              if (ctrl.enableDisconnect)
                $mdUtil.disconnectScope(compileScope);
            }
            function reconnect() {
              if (ctrl.enableDisconnect)
                $mdUtil.reconnectScope(compileScope);
            }
          }
        }
        MdTabsTemplate.$inject = ["$compile", "$mdUtil"];
      })();
      (function() {
        angular.module("material.core").constant("$MD_THEME_CSS", "/*  Only used with Theme processes */html.md-THEME_NAME-theme, body.md-THEME_NAME-theme {  color: '{{foreground-1}}';  background-color: '{{background-color}}'; }md-autocomplete.md-THEME_NAME-theme {  background: '{{background-A100}}'; }  md-autocomplete.md-THEME_NAME-theme[disabled]:not([md-floating-label]) {    background: '{{background-100}}'; }  md-autocomplete.md-THEME_NAME-theme button md-icon path {    fill: '{{background-600}}'; }  md-autocomplete.md-THEME_NAME-theme button:after {    background: '{{background-600-0.3}}'; }.md-autocomplete-suggestions-container.md-THEME_NAME-theme {  background: '{{background-A100}}'; }  .md-autocomplete-suggestions-container.md-THEME_NAME-theme li {    color: '{{background-900}}'; }    .md-autocomplete-suggestions-container.md-THEME_NAME-theme li .highlight {      color: '{{background-600}}'; }    .md-autocomplete-suggestions-container.md-THEME_NAME-theme li:hover, .md-autocomplete-suggestions-container.md-THEME_NAME-theme li.selected {      background: '{{background-200}}'; }md-backdrop {  background-color: '{{background-900-0.0}}'; }  md-backdrop.md-opaque.md-THEME_NAME-theme {    background-color: '{{background-900-1.0}}'; }md-bottom-sheet.md-THEME_NAME-theme {  background-color: '{{background-50}}';  border-top-color: '{{background-300}}'; }  md-bottom-sheet.md-THEME_NAME-theme.md-list md-list-item {    color: '{{foreground-1}}'; }  md-bottom-sheet.md-THEME_NAME-theme .md-subheader {    background-color: '{{background-50}}'; }  md-bottom-sheet.md-THEME_NAME-theme .md-subheader {    color: '{{foreground-1}}'; }md-card.md-THEME_NAME-theme {  color: '{{foreground-1}}';  background-color: '{{background-hue-1}}';  border-radius: 2px; }  md-card.md-THEME_NAME-theme .md-card-image {    border-radius: 2px 2px 0 0; }  md-card.md-THEME_NAME-theme md-card-header md-card-avatar md-icon {    color: '{{background-color}}';    background-color: '{{foreground-3}}'; }  md-card.md-THEME_NAME-theme md-card-header md-card-header-text .md-subhead {    color: '{{foreground-2}}'; }  md-card.md-THEME_NAME-theme md-card-title md-card-title-text:not(:only-child) .md-subhead {    color: '{{foreground-2}}'; }.md-button.md-THEME_NAME-theme:not([disabled]):hover {  background-color: '{{background-500-0.2}}'; }.md-button.md-THEME_NAME-theme:not([disabled]).md-focused {  background-color: '{{background-500-0.2}}'; }.md-button.md-THEME_NAME-theme:not([disabled]).md-icon-button:hover {  background-color: transparent; }.md-button.md-THEME_NAME-theme.md-fab {  background-color: '{{accent-color}}';  color: '{{accent-contrast}}'; }  .md-button.md-THEME_NAME-theme.md-fab md-icon {    color: '{{accent-contrast}}'; }  .md-button.md-THEME_NAME-theme.md-fab:not([disabled]):hover {    background-color: '{{accent-A700}}'; }  .md-button.md-THEME_NAME-theme.md-fab:not([disabled]).md-focused {    background-color: '{{accent-A700}}'; }.md-button.md-THEME_NAME-theme.md-primary {  color: '{{primary-color}}'; }  .md-button.md-THEME_NAME-theme.md-primary.md-raised, .md-button.md-THEME_NAME-theme.md-primary.md-fab {    color: '{{primary-contrast}}';    background-color: '{{primary-color}}'; }    .md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]) md-icon, .md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]) md-icon {      color: '{{primary-contrast}}'; }    .md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]):hover, .md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]):hover {      background-color: '{{primary-600}}'; }    .md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]).md-focused, .md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]).md-focused {      background-color: '{{primary-600}}'; }  .md-button.md-THEME_NAME-theme.md-primary:not([disabled]) md-icon {    color: '{{primary-color}}'; }.md-button.md-THEME_NAME-theme.md-fab {  background-color: '{{accent-color}}';  color: '{{accent-contrast}}'; }  .md-button.md-THEME_NAME-theme.md-fab:not([disabled]) .md-icon {    color: '{{accent-contrast}}'; }  .md-button.md-THEME_NAME-theme.md-fab:not([disabled]):hover {    background-color: '{{accent-A700}}'; }  .md-button.md-THEME_NAME-theme.md-fab:not([disabled]).md-focused {    background-color: '{{accent-A700}}'; }.md-button.md-THEME_NAME-theme.md-raised {  color: '{{background-900}}';  background-color: '{{background-50}}'; }  .md-button.md-THEME_NAME-theme.md-raised:not([disabled]) md-icon {    color: '{{background-900}}'; }  .md-button.md-THEME_NAME-theme.md-raised:not([disabled]):hover {    background-color: '{{background-50}}'; }  .md-button.md-THEME_NAME-theme.md-raised:not([disabled]).md-focused {    background-color: '{{background-200}}'; }.md-button.md-THEME_NAME-theme.md-warn {  color: '{{warn-color}}'; }  .md-button.md-THEME_NAME-theme.md-warn.md-raised, .md-button.md-THEME_NAME-theme.md-warn.md-fab {    color: '{{warn-contrast}}';    background-color: '{{warn-color}}'; }    .md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]) md-icon, .md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]) md-icon {      color: '{{warn-contrast}}'; }    .md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]):hover, .md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]):hover {      background-color: '{{warn-600}}'; }    .md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]).md-focused, .md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]).md-focused {      background-color: '{{warn-600}}'; }  .md-button.md-THEME_NAME-theme.md-warn:not([disabled]) md-icon {    color: '{{warn-color}}'; }.md-button.md-THEME_NAME-theme.md-accent {  color: '{{accent-color}}'; }  .md-button.md-THEME_NAME-theme.md-accent.md-raised, .md-button.md-THEME_NAME-theme.md-accent.md-fab {    color: '{{accent-contrast}}';    background-color: '{{accent-color}}'; }    .md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]) md-icon, .md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]) md-icon {      color: '{{accent-contrast}}'; }    .md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]):hover, .md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]):hover {      background-color: '{{accent-A700}}'; }    .md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]).md-focused, .md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]).md-focused {      background-color: '{{accent-A700}}'; }  .md-button.md-THEME_NAME-theme.md-accent:not([disabled]) md-icon {    color: '{{accent-color}}'; }.md-button.md-THEME_NAME-theme[disabled], .md-button.md-THEME_NAME-theme.md-raised[disabled], .md-button.md-THEME_NAME-theme.md-fab[disabled], .md-button.md-THEME_NAME-theme.md-accent[disabled], .md-button.md-THEME_NAME-theme.md-warn[disabled] {  color: '{{foreground-3}}';  cursor: default; }  .md-button.md-THEME_NAME-theme[disabled] md-icon, .md-button.md-THEME_NAME-theme.md-raised[disabled] md-icon, .md-button.md-THEME_NAME-theme.md-fab[disabled] md-icon, .md-button.md-THEME_NAME-theme.md-accent[disabled] md-icon, .md-button.md-THEME_NAME-theme.md-warn[disabled] md-icon {    color: '{{foreground-3}}'; }.md-button.md-THEME_NAME-theme.md-raised[disabled], .md-button.md-THEME_NAME-theme.md-fab[disabled] {  background-color: '{{foreground-4}}'; }.md-button.md-THEME_NAME-theme[disabled] {  background-color: transparent; }._md a.md-THEME_NAME-theme:not(.md-button).md-primary {  color: '{{primary-color}}'; }  ._md a.md-THEME_NAME-theme:not(.md-button).md-primary:hover {    color: '{{primary-700}}'; }._md a.md-THEME_NAME-theme:not(.md-button).md-accent {  color: '{{accent-color}}'; }  ._md a.md-THEME_NAME-theme:not(.md-button).md-accent:hover {    color: '{{accent-700}}'; }._md a.md-THEME_NAME-theme:not(.md-button).md-accent {  color: '{{accent-color}}'; }  ._md a.md-THEME_NAME-theme:not(.md-button).md-accent:hover {    color: '{{accent-A700}}'; }._md a.md-THEME_NAME-theme:not(.md-button).md-warn {  color: '{{warn-color}}'; }  ._md a.md-THEME_NAME-theme:not(.md-button).md-warn:hover {    color: '{{warn-700}}'; }md-checkbox.md-THEME_NAME-theme .md-ripple {  color: '{{accent-A700}}'; }md-checkbox.md-THEME_NAME-theme.md-checked .md-ripple {  color: '{{background-600}}'; }md-checkbox.md-THEME_NAME-theme.md-checked.md-focused ._md-container:before {  background-color: '{{accent-color-0.26}}'; }md-checkbox.md-THEME_NAME-theme .md-ink-ripple {  color: '{{foreground-2}}'; }md-checkbox.md-THEME_NAME-theme.md-checked .md-ink-ripple {  color: '{{accent-color-0.87}}'; }md-checkbox.md-THEME_NAME-theme ._md-icon {  border-color: '{{foreground-2}}'; }md-checkbox.md-THEME_NAME-theme.md-checked ._md-icon {  background-color: '{{accent-color-0.87}}'; }md-checkbox.md-THEME_NAME-theme.md-checked ._md-icon:after {  border-color: '{{accent-contrast-0.87}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary .md-ripple {  color: '{{primary-600}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-ripple {  color: '{{background-600}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary .md-ink-ripple {  color: '{{foreground-2}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-ink-ripple {  color: '{{primary-color-0.87}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary ._md-icon {  border-color: '{{foreground-2}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked ._md-icon {  background-color: '{{primary-color-0.87}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked.md-focused ._md-container:before {  background-color: '{{primary-color-0.26}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked ._md-icon:after {  border-color: '{{primary-contrast-0.87}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary .md-indeterminate[disabled] ._md-container {  color: '{{foreground-3}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn .md-ripple {  color: '{{warn-600}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn .md-ink-ripple {  color: '{{foreground-2}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-ink-ripple {  color: '{{warn-color-0.87}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn ._md-icon {  border-color: '{{foreground-2}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked ._md-icon {  background-color: '{{warn-color-0.87}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked.md-focused:not([disabled]) ._md-container:before {  background-color: '{{warn-color-0.26}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked ._md-icon:after {  border-color: '{{background-200}}'; }md-checkbox.md-THEME_NAME-theme[disabled] ._md-icon {  border-color: '{{foreground-3}}'; }md-checkbox.md-THEME_NAME-theme[disabled].md-checked ._md-icon {  background-color: '{{foreground-3}}'; }md-checkbox.md-THEME_NAME-theme[disabled].md-checked ._md-icon:after {  border-color: '{{background-200}}'; }md-checkbox.md-THEME_NAME-theme[disabled] ._md-icon:after {  border-color: '{{foreground-3}}'; }md-checkbox.md-THEME_NAME-theme[disabled] ._md-label {  color: '{{foreground-3}}'; }md-chips.md-THEME_NAME-theme .md-chips {  box-shadow: 0 1px '{{foreground-4}}'; }  md-chips.md-THEME_NAME-theme .md-chips.md-focused {    box-shadow: 0 2px '{{primary-color}}'; }  md-chips.md-THEME_NAME-theme .md-chips ._md-chip-input-container input {    color: '{{foreground-1}}'; }    md-chips.md-THEME_NAME-theme .md-chips ._md-chip-input-container input::-webkit-input-placeholder {      color: '{{foreground-3}}'; }    md-chips.md-THEME_NAME-theme .md-chips ._md-chip-input-container input:-moz-placeholder {      color: '{{foreground-3}}'; }    md-chips.md-THEME_NAME-theme .md-chips ._md-chip-input-container input::-moz-placeholder {      color: '{{foreground-3}}'; }    md-chips.md-THEME_NAME-theme .md-chips ._md-chip-input-container input:-ms-input-placeholder {      color: '{{foreground-3}}'; }    md-chips.md-THEME_NAME-theme .md-chips ._md-chip-input-container input::-webkit-input-placeholder {      color: '{{foreground-3}}'; }md-chips.md-THEME_NAME-theme md-chip {  background: '{{background-300}}';  color: '{{background-800}}'; }  md-chips.md-THEME_NAME-theme md-chip md-icon {    color: '{{background-700}}'; }  md-chips.md-THEME_NAME-theme md-chip.md-focused {    background: '{{primary-color}}';    color: '{{primary-contrast}}'; }    md-chips.md-THEME_NAME-theme md-chip.md-focused md-icon {      color: '{{primary-contrast}}'; }  md-chips.md-THEME_NAME-theme md-chip._md-chip-editing {    background: transparent;    color: '{{background-800}}'; }md-chips.md-THEME_NAME-theme md-chip-remove .md-button md-icon path {  fill: '{{background-500}}'; }.md-contact-suggestion span.md-contact-email {  color: '{{background-400}}'; }md-content.md-THEME_NAME-theme {  color: '{{foreground-1}}';  background-color: '{{background-default}}'; }/** Theme styles for mdCalendar. */.md-calendar.md-THEME_NAME-theme {  background: '{{background-A100}}';  color: '{{background-A200-0.87}}'; }  .md-calendar.md-THEME_NAME-theme tr:last-child td {    border-bottom-color: '{{background-200}}'; }.md-THEME_NAME-theme .md-calendar-day-header {  background: '{{background-300}}';  color: '{{background-A200-0.87}}'; }.md-THEME_NAME-theme .md-calendar-date.md-calendar-date-today .md-calendar-date-selection-indicator {  border: 1px solid '{{primary-500}}'; }.md-THEME_NAME-theme .md-calendar-date.md-calendar-date-today.md-calendar-date-disabled {  color: '{{primary-500-0.6}}'; }.md-calendar-date.md-focus .md-THEME_NAME-theme .md-calendar-date-selection-indicator, .md-THEME_NAME-theme .md-calendar-date-selection-indicator:hover {  background: '{{background-300}}'; }.md-THEME_NAME-theme .md-calendar-date.md-calendar-selected-date .md-calendar-date-selection-indicator,.md-THEME_NAME-theme .md-calendar-date.md-focus.md-calendar-selected-date .md-calendar-date-selection-indicator {  background: '{{primary-500}}';  color: '{{primary-500-contrast}}';  border-color: transparent; }.md-THEME_NAME-theme .md-calendar-date-disabled,.md-THEME_NAME-theme .md-calendar-month-label-disabled {  color: '{{background-A200-0.435}}'; }/** Theme styles for mdDatepicker. */.md-THEME_NAME-theme .md-datepicker-input {  color: '{{foreground-1}}'; }  .md-THEME_NAME-theme .md-datepicker-input::-webkit-input-placeholder {    color: '{{foreground-3}}'; }  .md-THEME_NAME-theme .md-datepicker-input:-moz-placeholder {    color: '{{foreground-3}}'; }  .md-THEME_NAME-theme .md-datepicker-input::-moz-placeholder {    color: '{{foreground-3}}'; }  .md-THEME_NAME-theme .md-datepicker-input:-ms-input-placeholder {    color: '{{foreground-3}}'; }  .md-THEME_NAME-theme .md-datepicker-input::-webkit-input-placeholder {    color: '{{foreground-3}}'; }.md-THEME_NAME-theme .md-datepicker-input-container {  border-bottom-color: '{{foreground-4}}'; }  .md-THEME_NAME-theme .md-datepicker-input-container.md-datepicker-focused {    border-bottom-color: '{{primary-color}}'; }  .md-THEME_NAME-theme .md-datepicker-input-container.md-datepicker-invalid {    border-bottom-color: '{{warn-A700}}'; }.md-THEME_NAME-theme .md-datepicker-calendar-pane {  border-color: '{{background-hue-1}}'; }.md-THEME_NAME-theme .md-datepicker-triangle-button .md-datepicker-expand-triangle {  border-top-color: '{{foreground-3}}'; }.md-THEME_NAME-theme .md-datepicker-triangle-button:hover .md-datepicker-expand-triangle {  border-top-color: '{{foreground-2}}'; }.md-THEME_NAME-theme .md-datepicker-open .md-datepicker-calendar-icon {  fill: '{{primary-500}}'; }.md-THEME_NAME-theme .md-datepicker-open .md-datepicker-input-container,.md-THEME_NAME-theme .md-datepicker-input-mask-opaque {  background: '{{background-hue-1}}'; }.md-THEME_NAME-theme .md-datepicker-calendar {  background: '{{background-A100}}'; }md-dialog.md-THEME_NAME-theme {  border-radius: 4px;  background-color: '{{background-hue-1}}';  color: '{{foreground-1}}'; }  md-dialog.md-THEME_NAME-theme.md-content-overflow .md-actions, md-dialog.md-THEME_NAME-theme.md-content-overflow md-dialog-actions {    border-top-color: '{{foreground-4}}'; }md-divider.md-THEME_NAME-theme {  border-top-color: '{{foreground-4}}'; }.layout-row > md-divider.md-THEME_NAME-theme,.layout-xs-row > md-divider.md-THEME_NAME-theme, .layout-gt-xs-row > md-divider.md-THEME_NAME-theme,.layout-sm-row > md-divider.md-THEME_NAME-theme, .layout-gt-sm-row > md-divider.md-THEME_NAME-theme,.layout-md-row > md-divider.md-THEME_NAME-theme, .layout-gt-md-row > md-divider.md-THEME_NAME-theme,.layout-lg-row > md-divider.md-THEME_NAME-theme, .layout-gt-lg-row > md-divider.md-THEME_NAME-theme,.layout-xl-row > md-divider.md-THEME_NAME-theme {  border-right-color: '{{foreground-4}}'; }md-icon.md-THEME_NAME-theme {  color: '{{foreground-2}}'; }  md-icon.md-THEME_NAME-theme.md-primary {    color: '{{primary-color}}'; }  md-icon.md-THEME_NAME-theme.md-accent {    color: '{{accent-color}}'; }  md-icon.md-THEME_NAME-theme.md-warn {    color: '{{warn-color}}'; }md-input-container.md-THEME_NAME-theme .md-input {  color: '{{foreground-1}}';  border-color: '{{foreground-4}}'; }  md-input-container.md-THEME_NAME-theme .md-input::-webkit-input-placeholder {    color: '{{foreground-3}}'; }  md-input-container.md-THEME_NAME-theme .md-input:-moz-placeholder {    color: '{{foreground-3}}'; }  md-input-container.md-THEME_NAME-theme .md-input::-moz-placeholder {    color: '{{foreground-3}}'; }  md-input-container.md-THEME_NAME-theme .md-input:-ms-input-placeholder {    color: '{{foreground-3}}'; }  md-input-container.md-THEME_NAME-theme .md-input::-webkit-input-placeholder {    color: '{{foreground-3}}'; }md-input-container.md-THEME_NAME-theme > md-icon {  color: '{{foreground-1}}'; }md-input-container.md-THEME_NAME-theme label,md-input-container.md-THEME_NAME-theme ._md-placeholder {  color: '{{foreground-3}}'; }md-input-container.md-THEME_NAME-theme.md-input-invalid label.md-required:after {  color: '{{warn-A700}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-focused):not(.md-input-invalid) label.md-required:after {  color: '{{foreground-2}}'; }md-input-container.md-THEME_NAME-theme .md-input-messages-animation, md-input-container.md-THEME_NAME-theme .md-input-message-animation {  color: '{{warn-A700}}'; }  md-input-container.md-THEME_NAME-theme .md-input-messages-animation .md-char-counter, md-input-container.md-THEME_NAME-theme .md-input-message-animation .md-char-counter {    color: '{{foreground-1}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-has-value label {  color: '{{foreground-2}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused .md-input, md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-resized .md-input {  border-color: '{{primary-color}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused label {  color: '{{primary-color}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused md-icon {  color: '{{primary-color}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-accent .md-input {  border-color: '{{accent-color}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-accent label {  color: '{{accent-color}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-warn .md-input {  border-color: '{{warn-A700}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-warn label {  color: '{{warn-A700}}'; }md-input-container.md-THEME_NAME-theme.md-input-invalid .md-input {  border-color: '{{warn-A700}}'; }md-input-container.md-THEME_NAME-theme.md-input-invalid label {  color: '{{warn-A700}}'; }md-input-container.md-THEME_NAME-theme.md-input-invalid .md-input-message-animation, md-input-container.md-THEME_NAME-theme.md-input-invalid .md-char-counter {  color: '{{warn-A700}}'; }md-input-container.md-THEME_NAME-theme .md-input[disabled],[disabled] md-input-container.md-THEME_NAME-theme .md-input {  border-bottom-color: transparent;  color: '{{foreground-3}}';  background-image: linear-gradient(to right, \"{{foreground-3}}\" 0%, \"{{foreground-3}}\" 33%, transparent 0%);  background-image: -ms-linear-gradient(left, transparent 0%, \"{{foreground-3}}\" 100%); }md-list.md-THEME_NAME-theme md-list-item.md-2-line .md-list-item-text h3, md-list.md-THEME_NAME-theme md-list-item.md-2-line .md-list-item-text h4,md-list.md-THEME_NAME-theme md-list-item.md-3-line .md-list-item-text h3,md-list.md-THEME_NAME-theme md-list-item.md-3-line .md-list-item-text h4 {  color: '{{foreground-1}}'; }md-list.md-THEME_NAME-theme md-list-item.md-2-line .md-list-item-text p,md-list.md-THEME_NAME-theme md-list-item.md-3-line .md-list-item-text p {  color: '{{foreground-2}}'; }md-list.md-THEME_NAME-theme ._md-proxy-focus.md-focused div._md-no-style {  background-color: '{{background-100}}'; }md-list.md-THEME_NAME-theme md-list-item .md-avatar-icon {  background-color: '{{foreground-3}}';  color: '{{background-color}}'; }md-list.md-THEME_NAME-theme md-list-item > md-icon {  color: '{{foreground-2}}'; }  md-list.md-THEME_NAME-theme md-list-item > md-icon.md-highlight {    color: '{{primary-color}}'; }    md-list.md-THEME_NAME-theme md-list-item > md-icon.md-highlight.md-accent {      color: '{{accent-color}}'; }md-menu-content.md-THEME_NAME-theme {  background-color: '{{background-A100}}'; }  md-menu-content.md-THEME_NAME-theme md-menu-item {    color: '{{background-A200-0.87}}'; }    md-menu-content.md-THEME_NAME-theme md-menu-item md-icon {      color: '{{background-A200-0.54}}'; }    md-menu-content.md-THEME_NAME-theme md-menu-item .md-button[disabled] {      color: '{{background-A200-0.25}}'; }      md-menu-content.md-THEME_NAME-theme md-menu-item .md-button[disabled] md-icon {        color: '{{background-A200-0.25}}'; }  md-menu-content.md-THEME_NAME-theme md-menu-divider {    background-color: '{{background-A200-0.11}}'; }md-menu-bar.md-THEME_NAME-theme > button.md-button {  color: '{{foreground-2}}';  border-radius: 2px; }md-menu-bar.md-THEME_NAME-theme md-menu._md-open > button, md-menu-bar.md-THEME_NAME-theme md-menu > button:focus {  outline: none;  background: '{{background-200}}'; }md-menu-bar.md-THEME_NAME-theme._md-open:not(._md-keyboard-mode) md-menu:hover > button {  background-color: '{{ background-500-0.2}}'; }md-menu-bar.md-THEME_NAME-theme:not(._md-keyboard-mode):not(._md-open) md-menu button:hover,md-menu-bar.md-THEME_NAME-theme:not(._md-keyboard-mode):not(._md-open) md-menu button:focus {  background: transparent; }md-menu-content.md-THEME_NAME-theme .md-menu > .md-button:after {  color: '{{background-A200-0.54}}'; }md-menu-content.md-THEME_NAME-theme .md-menu._md-open > .md-button {  background-color: '{{ background-500-0.2}}'; }md-toolbar.md-THEME_NAME-theme.md-menu-toolbar {  background-color: '{{background-A100}}';  color: '{{background-A200}}'; }  md-toolbar.md-THEME_NAME-theme.md-menu-toolbar md-toolbar-filler {    background-color: '{{primary-color}}';    color: '{{background-A100-0.87}}'; }    md-toolbar.md-THEME_NAME-theme.md-menu-toolbar md-toolbar-filler md-icon {      color: '{{background-A100-0.87}}'; }md-nav-bar.md-THEME_NAME-theme .md-nav-bar {  background-color: transparent;  border-color: '{{foreground-4}}'; }md-nav-bar.md-THEME_NAME-theme .md-button._md-nav-button.md-unselected {  color: '{{foreground-2}}'; }md-nav-bar.md-THEME_NAME-theme md-nav-ink-bar {  color: '{{accent-color}}';  background: '{{accent-color}}'; }.md-panel {  background-color: '{{background-900-0.0}}'; }  .md-panel._md-panel-backdrop.md-THEME_NAME-theme {    background-color: '{{background-900-1.0}}'; }md-progress-circular.md-THEME_NAME-theme path {  stroke: '{{primary-color}}'; }md-progress-circular.md-THEME_NAME-theme.md-warn path {  stroke: '{{warn-color}}'; }md-progress-circular.md-THEME_NAME-theme.md-accent path {  stroke: '{{accent-color}}'; }md-progress-linear.md-THEME_NAME-theme ._md-container {  background-color: '{{primary-100}}'; }md-progress-linear.md-THEME_NAME-theme ._md-bar {  background-color: '{{primary-color}}'; }md-progress-linear.md-THEME_NAME-theme.md-warn ._md-container {  background-color: '{{warn-100}}'; }md-progress-linear.md-THEME_NAME-theme.md-warn ._md-bar {  background-color: '{{warn-color}}'; }md-progress-linear.md-THEME_NAME-theme.md-accent ._md-container {  background-color: '{{accent-A100}}'; }md-progress-linear.md-THEME_NAME-theme.md-accent ._md-bar {  background-color: '{{accent-color}}'; }md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-warn ._md-bar1 {  background-color: '{{warn-100}}'; }md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-warn ._md-dashed:before {  background: radial-gradient(\"{{warn-100}}\" 0%, \"{{warn-100}}\" 16%, transparent 42%); }md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-accent ._md-bar1 {  background-color: '{{accent-A100}}'; }md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-accent ._md-dashed:before {  background: radial-gradient(\"{{accent-A100}}\" 0%, \"{{accent-A100}}\" 16%, transparent 42%); }md-radio-button.md-THEME_NAME-theme ._md-off {  border-color: '{{foreground-2}}'; }md-radio-button.md-THEME_NAME-theme ._md-on {  background-color: '{{accent-color-0.87}}'; }md-radio-button.md-THEME_NAME-theme.md-checked ._md-off {  border-color: '{{accent-color-0.87}}'; }md-radio-button.md-THEME_NAME-theme.md-checked .md-ink-ripple {  color: '{{accent-color-0.87}}'; }md-radio-button.md-THEME_NAME-theme ._md-container .md-ripple {  color: '{{accent-A700}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary ._md-on, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary ._md-on,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary ._md-on,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary ._md-on {  background-color: '{{primary-color-0.87}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary .md-checked ._md-off, md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary.md-checked ._md-off, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary .md-checked ._md-off, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked ._md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary .md-checked ._md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary.md-checked ._md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary .md-checked ._md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked ._md-off {  border-color: '{{primary-color-0.87}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary .md-checked .md-ink-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary.md-checked .md-ink-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary .md-checked .md-ink-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary .md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary.md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary .md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-ink-ripple {  color: '{{primary-color-0.87}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary ._md-container .md-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary ._md-container .md-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary ._md-container .md-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary ._md-container .md-ripple {  color: '{{primary-600}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn ._md-on, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn ._md-on,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn ._md-on,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn ._md-on {  background-color: '{{warn-color-0.87}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn .md-checked ._md-off, md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn.md-checked ._md-off, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn .md-checked ._md-off, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked ._md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn .md-checked ._md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn.md-checked ._md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn .md-checked ._md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked ._md-off {  border-color: '{{warn-color-0.87}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn .md-checked .md-ink-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn.md-checked .md-ink-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn .md-checked .md-ink-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn .md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn.md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn .md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-ink-ripple {  color: '{{warn-color-0.87}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn ._md-container .md-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn ._md-container .md-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn ._md-container .md-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn ._md-container .md-ripple {  color: '{{warn-600}}'; }md-radio-group.md-THEME_NAME-theme[disabled],md-radio-button.md-THEME_NAME-theme[disabled] {  color: '{{foreground-3}}'; }  md-radio-group.md-THEME_NAME-theme[disabled] ._md-container ._md-off,  md-radio-button.md-THEME_NAME-theme[disabled] ._md-container ._md-off {    border-color: '{{foreground-3}}'; }  md-radio-group.md-THEME_NAME-theme[disabled] ._md-container ._md-on,  md-radio-button.md-THEME_NAME-theme[disabled] ._md-container ._md-on {    border-color: '{{foreground-3}}'; }md-radio-group.md-THEME_NAME-theme .md-checked .md-ink-ripple {  color: '{{accent-color-0.26}}'; }md-radio-group.md-THEME_NAME-theme.md-primary .md-checked:not([disabled]) .md-ink-ripple, md-radio-group.md-THEME_NAME-theme .md-checked:not([disabled]).md-primary .md-ink-ripple {  color: '{{primary-color-0.26}}'; }md-radio-group.md-THEME_NAME-theme .md-checked.md-primary .md-ink-ripple {  color: '{{warn-color-0.26}}'; }md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty) .md-checked ._md-container:before {  background-color: '{{accent-color-0.26}}'; }md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty).md-primary .md-checked ._md-container:before,md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty) .md-checked.md-primary ._md-container:before {  background-color: '{{primary-color-0.26}}'; }md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty).md-warn .md-checked ._md-container:before,md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty) .md-checked.md-warn ._md-container:before {  background-color: '{{warn-color-0.26}}'; }md-input-container.md-input-focused:not(.md-input-has-value) md-select.md-THEME_NAME-theme ._md-select-value {  color: '{{primary-color}}'; }  md-input-container.md-input-focused:not(.md-input-has-value) md-select.md-THEME_NAME-theme ._md-select-value._md-select-placeholder {    color: '{{primary-color}}'; }md-input-container.md-input-invalid md-select.md-THEME_NAME-theme ._md-select-value {  color: '{{warn-A700}}' !important;  border-bottom-color: '{{warn-A700}}' !important; }md-input-container.md-input-invalid md-select.md-THEME_NAME-theme.md-no-underline ._md-select-value {  border-bottom-color: transparent !important; }md-select.md-THEME_NAME-theme[disabled] ._md-select-value {  border-bottom-color: transparent;  background-image: linear-gradient(to right, \"{{foreground-3}}\" 0%, \"{{foreground-3}}\" 33%, transparent 0%);  background-image: -ms-linear-gradient(left, transparent 0%, \"{{foreground-3}}\" 100%); }md-select.md-THEME_NAME-theme ._md-select-value {  border-bottom-color: '{{foreground-4}}'; }  md-select.md-THEME_NAME-theme ._md-select-value._md-select-placeholder {    color: '{{foreground-3}}'; }md-select.md-THEME_NAME-theme.md-no-underline ._md-select-value {  border-bottom-color: transparent !important; }md-select.md-THEME_NAME-theme.ng-invalid.ng-touched ._md-select-value {  color: '{{warn-A700}}' !important;  border-bottom-color: '{{warn-A700}}' !important; }md-select.md-THEME_NAME-theme.ng-invalid.ng-touched.md-no-underline ._md-select-value {  border-bottom-color: transparent !important; }md-select.md-THEME_NAME-theme:not([disabled]):focus ._md-select-value {  border-bottom-color: '{{primary-color}}';  color: '{{ foreground-1 }}'; }  md-select.md-THEME_NAME-theme:not([disabled]):focus ._md-select-value._md-select-placeholder {    color: '{{ foreground-1 }}'; }md-select.md-THEME_NAME-theme:not([disabled]):focus.md-no-underline ._md-select-value {  border-bottom-color: transparent !important; }md-select.md-THEME_NAME-theme:not([disabled]):focus.md-accent ._md-select-value {  border-bottom-color: '{{accent-color}}'; }md-select.md-THEME_NAME-theme:not([disabled]):focus.md-warn ._md-select-value {  border-bottom-color: '{{warn-color}}'; }md-select.md-THEME_NAME-theme[disabled] ._md-select-value {  color: '{{foreground-3}}'; }  md-select.md-THEME_NAME-theme[disabled] ._md-select-value._md-select-placeholder {    color: '{{foreground-3}}'; }md-select-menu.md-THEME_NAME-theme md-content {  background: '{{background-A100}}'; }  md-select-menu.md-THEME_NAME-theme md-content md-optgroup {    color: '{{background-600-0.87}}'; }  md-select-menu.md-THEME_NAME-theme md-content md-option {    color: '{{background-900-0.87}}'; }    md-select-menu.md-THEME_NAME-theme md-content md-option[disabled] ._md-text {      color: '{{background-400-0.87}}'; }    md-select-menu.md-THEME_NAME-theme md-content md-option:not([disabled]):focus, md-select-menu.md-THEME_NAME-theme md-content md-option:not([disabled]):hover {      background: '{{background-200}}'; }    md-select-menu.md-THEME_NAME-theme md-content md-option[selected] {      color: '{{primary-500}}'; }      md-select-menu.md-THEME_NAME-theme md-content md-option[selected]:focus {        color: '{{primary-600}}'; }      md-select-menu.md-THEME_NAME-theme md-content md-option[selected].md-accent {        color: '{{accent-color}}'; }        md-select-menu.md-THEME_NAME-theme md-content md-option[selected].md-accent:focus {          color: '{{accent-A700}}'; }._md-checkbox-enabled.md-THEME_NAME-theme .md-ripple {  color: '{{primary-600}}'; }._md-checkbox-enabled.md-THEME_NAME-theme[selected] .md-ripple {  color: '{{background-600}}'; }._md-checkbox-enabled.md-THEME_NAME-theme .md-ink-ripple {  color: '{{foreground-2}}'; }._md-checkbox-enabled.md-THEME_NAME-theme[selected] .md-ink-ripple {  color: '{{primary-color-0.87}}'; }._md-checkbox-enabled.md-THEME_NAME-theme ._md-icon {  border-color: '{{foreground-2}}'; }._md-checkbox-enabled.md-THEME_NAME-theme[selected] ._md-icon {  background-color: '{{primary-color-0.87}}'; }._md-checkbox-enabled.md-THEME_NAME-theme[selected].md-focused ._md-container:before {  background-color: '{{primary-color-0.26}}'; }._md-checkbox-enabled.md-THEME_NAME-theme[selected] ._md-icon:after {  border-color: '{{primary-contrast-0.87}}'; }._md-checkbox-enabled.md-THEME_NAME-theme .md-indeterminate[disabled] ._md-container {  color: '{{foreground-3}}'; }._md-checkbox-enabled.md-THEME_NAME-theme md-option ._md-text {  color: '{{background-900-0.87}}'; }md-sidenav.md-THEME_NAME-theme, md-sidenav.md-THEME_NAME-theme md-content {  background-color: '{{background-hue-1}}'; }md-slider.md-THEME_NAME-theme ._md-track {  background-color: '{{foreground-3}}'; }md-slider.md-THEME_NAME-theme ._md-track-ticks {  color: '{{background-contrast}}'; }md-slider.md-THEME_NAME-theme ._md-focus-ring {  background-color: '{{accent-A200-0.2}}'; }md-slider.md-THEME_NAME-theme ._md-disabled-thumb {  border-color: '{{background-color}}';  background-color: '{{background-color}}'; }md-slider.md-THEME_NAME-theme._md-min ._md-thumb:after {  background-color: '{{background-color}}';  border-color: '{{foreground-3}}'; }md-slider.md-THEME_NAME-theme._md-min ._md-focus-ring {  background-color: '{{foreground-3-0.38}}'; }md-slider.md-THEME_NAME-theme._md-min[md-discrete] ._md-thumb:after {  background-color: '{{background-contrast}}';  border-color: transparent; }md-slider.md-THEME_NAME-theme._md-min[md-discrete] ._md-sign {  background-color: '{{background-400}}'; }  md-slider.md-THEME_NAME-theme._md-min[md-discrete] ._md-sign:after {    border-top-color: '{{background-400}}'; }md-slider.md-THEME_NAME-theme._md-min[md-discrete][md-vertical] ._md-sign:after {  border-top-color: transparent;  border-left-color: '{{background-400}}'; }md-slider.md-THEME_NAME-theme ._md-track._md-track-fill {  background-color: '{{accent-color}}'; }md-slider.md-THEME_NAME-theme ._md-thumb:after {  border-color: '{{accent-color}}';  background-color: '{{accent-color}}'; }md-slider.md-THEME_NAME-theme ._md-sign {  background-color: '{{accent-color}}'; }  md-slider.md-THEME_NAME-theme ._md-sign:after {    border-top-color: '{{accent-color}}'; }md-slider.md-THEME_NAME-theme[md-vertical] ._md-sign:after {  border-top-color: transparent;  border-left-color: '{{accent-color}}'; }md-slider.md-THEME_NAME-theme ._md-thumb-text {  color: '{{accent-contrast}}'; }md-slider.md-THEME_NAME-theme.md-warn ._md-focus-ring {  background-color: '{{warn-200-0.38}}'; }md-slider.md-THEME_NAME-theme.md-warn ._md-track._md-track-fill {  background-color: '{{warn-color}}'; }md-slider.md-THEME_NAME-theme.md-warn ._md-thumb:after {  border-color: '{{warn-color}}';  background-color: '{{warn-color}}'; }md-slider.md-THEME_NAME-theme.md-warn ._md-sign {  background-color: '{{warn-color}}'; }  md-slider.md-THEME_NAME-theme.md-warn ._md-sign:after {    border-top-color: '{{warn-color}}'; }md-slider.md-THEME_NAME-theme.md-warn[md-vertical] ._md-sign:after {  border-top-color: transparent;  border-left-color: '{{warn-color}}'; }md-slider.md-THEME_NAME-theme.md-warn ._md-thumb-text {  color: '{{warn-contrast}}'; }md-slider.md-THEME_NAME-theme.md-primary ._md-focus-ring {  background-color: '{{primary-200-0.38}}'; }md-slider.md-THEME_NAME-theme.md-primary ._md-track._md-track-fill {  background-color: '{{primary-color}}'; }md-slider.md-THEME_NAME-theme.md-primary ._md-thumb:after {  border-color: '{{primary-color}}';  background-color: '{{primary-color}}'; }md-slider.md-THEME_NAME-theme.md-primary ._md-sign {  background-color: '{{primary-color}}'; }  md-slider.md-THEME_NAME-theme.md-primary ._md-sign:after {    border-top-color: '{{primary-color}}'; }md-slider.md-THEME_NAME-theme.md-primary[md-vertical] ._md-sign:after {  border-top-color: transparent;  border-left-color: '{{primary-color}}'; }md-slider.md-THEME_NAME-theme.md-primary ._md-thumb-text {  color: '{{primary-contrast}}'; }md-slider.md-THEME_NAME-theme[disabled] ._md-thumb:after {  border-color: transparent; }md-slider.md-THEME_NAME-theme[disabled]:not(._md-min) ._md-thumb:after, md-slider.md-THEME_NAME-theme[disabled][md-discrete] ._md-thumb:after {  background-color: '{{foreground-3}}';  border-color: transparent; }md-slider.md-THEME_NAME-theme[disabled][readonly] ._md-sign {  background-color: '{{background-400}}'; }  md-slider.md-THEME_NAME-theme[disabled][readonly] ._md-sign:after {    border-top-color: '{{background-400}}'; }md-slider.md-THEME_NAME-theme[disabled][readonly][md-vertical] ._md-sign:after {  border-top-color: transparent;  border-left-color: '{{background-400}}'; }md-slider.md-THEME_NAME-theme[disabled][readonly] ._md-disabled-thumb {  border-color: transparent;  background-color: transparent; }md-slider-container[disabled] > *:first-child:not(md-slider),md-slider-container[disabled] > *:last-child:not(md-slider) {  color: '{{foreground-3}}'; }.md-subheader.md-THEME_NAME-theme {  color: '{{ foreground-2-0.23 }}';  background-color: '{{background-default}}'; }  .md-subheader.md-THEME_NAME-theme.md-primary {    color: '{{primary-color}}'; }  .md-subheader.md-THEME_NAME-theme.md-accent {    color: '{{accent-color}}'; }  .md-subheader.md-THEME_NAME-theme.md-warn {    color: '{{warn-color}}'; }md-switch.md-THEME_NAME-theme .md-ink-ripple {  color: '{{background-500}}'; }md-switch.md-THEME_NAME-theme ._md-thumb {  background-color: '{{background-50}}'; }md-switch.md-THEME_NAME-theme ._md-bar {  background-color: '{{background-500}}'; }md-switch.md-THEME_NAME-theme.md-checked .md-ink-ripple {  color: '{{accent-color}}'; }md-switch.md-THEME_NAME-theme.md-checked ._md-thumb {  background-color: '{{accent-color}}'; }md-switch.md-THEME_NAME-theme.md-checked ._md-bar {  background-color: '{{accent-color-0.5}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-focused ._md-thumb:before {  background-color: '{{accent-color-0.26}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-primary .md-ink-ripple {  color: '{{primary-color}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-primary ._md-thumb {  background-color: '{{primary-color}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-primary ._md-bar {  background-color: '{{primary-color-0.5}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-primary.md-focused ._md-thumb:before {  background-color: '{{primary-color-0.26}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-warn .md-ink-ripple {  color: '{{warn-color}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-warn ._md-thumb {  background-color: '{{warn-color}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-warn ._md-bar {  background-color: '{{warn-color-0.5}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-warn.md-focused ._md-thumb:before {  background-color: '{{warn-color-0.26}}'; }md-switch.md-THEME_NAME-theme[disabled] ._md-thumb {  background-color: '{{background-400}}'; }md-switch.md-THEME_NAME-theme[disabled] ._md-bar {  background-color: '{{foreground-4}}'; }md-tabs.md-THEME_NAME-theme md-tabs-wrapper {  background-color: transparent;  border-color: '{{foreground-4}}'; }md-tabs.md-THEME_NAME-theme .md-paginator md-icon {  color: '{{primary-color}}'; }md-tabs.md-THEME_NAME-theme md-ink-bar {  color: '{{accent-color}}';  background: '{{accent-color}}'; }md-tabs.md-THEME_NAME-theme .md-tab {  color: '{{foreground-2}}'; }  md-tabs.md-THEME_NAME-theme .md-tab[disabled], md-tabs.md-THEME_NAME-theme .md-tab[disabled] md-icon {    color: '{{foreground-3}}'; }  md-tabs.md-THEME_NAME-theme .md-tab.md-active, md-tabs.md-THEME_NAME-theme .md-tab.md-active md-icon, md-tabs.md-THEME_NAME-theme .md-tab.md-focused, md-tabs.md-THEME_NAME-theme .md-tab.md-focused md-icon {    color: '{{primary-color}}'; }  md-tabs.md-THEME_NAME-theme .md-tab.md-focused {    background: '{{primary-color-0.1}}'; }  md-tabs.md-THEME_NAME-theme .md-tab .md-ripple-container {    color: '{{accent-A100}}'; }md-tabs.md-THEME_NAME-theme.md-accent > md-tabs-wrapper {  background-color: '{{accent-color}}'; }  md-tabs.md-THEME_NAME-theme.md-accent > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]) {    color: '{{accent-A100}}'; }    md-tabs.md-THEME_NAME-theme.md-accent > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active, md-tabs.md-THEME_NAME-theme.md-accent > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active md-icon, md-tabs.md-THEME_NAME-theme.md-accent > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused, md-tabs.md-THEME_NAME-theme.md-accent > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused md-icon {      color: '{{accent-contrast}}'; }    md-tabs.md-THEME_NAME-theme.md-accent > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused {      background: '{{accent-contrast-0.1}}'; }  md-tabs.md-THEME_NAME-theme.md-accent > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-ink-bar {    color: '{{primary-600-1}}';    background: '{{primary-600-1}}'; }md-tabs.md-THEME_NAME-theme.md-primary > md-tabs-wrapper {  background-color: '{{primary-color}}'; }  md-tabs.md-THEME_NAME-theme.md-primary > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]) {    color: '{{primary-100}}'; }    md-tabs.md-THEME_NAME-theme.md-primary > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active, md-tabs.md-THEME_NAME-theme.md-primary > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active md-icon, md-tabs.md-THEME_NAME-theme.md-primary > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused, md-tabs.md-THEME_NAME-theme.md-primary > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused md-icon {      color: '{{primary-contrast}}'; }    md-tabs.md-THEME_NAME-theme.md-primary > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused {      background: '{{primary-contrast-0.1}}'; }md-tabs.md-THEME_NAME-theme.md-warn > md-tabs-wrapper {  background-color: '{{warn-color}}'; }  md-tabs.md-THEME_NAME-theme.md-warn > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]) {    color: '{{warn-100}}'; }    md-tabs.md-THEME_NAME-theme.md-warn > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active, md-tabs.md-THEME_NAME-theme.md-warn > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active md-icon, md-tabs.md-THEME_NAME-theme.md-warn > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused, md-tabs.md-THEME_NAME-theme.md-warn > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused md-icon {      color: '{{warn-contrast}}'; }    md-tabs.md-THEME_NAME-theme.md-warn > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused {      background: '{{warn-contrast-0.1}}'; }md-toolbar > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper {  background-color: '{{primary-color}}'; }  md-toolbar > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]) {    color: '{{primary-100}}'; }    md-toolbar > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active, md-toolbar > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active md-icon, md-toolbar > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused, md-toolbar > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused md-icon {      color: '{{primary-contrast}}'; }    md-toolbar > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused {      background: '{{primary-contrast-0.1}}'; }md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper {  background-color: '{{accent-color}}'; }  md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]) {    color: '{{accent-A100}}'; }    md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active, md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active md-icon, md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused, md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused md-icon {      color: '{{accent-contrast}}'; }    md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused {      background: '{{accent-contrast-0.1}}'; }  md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-ink-bar {    color: '{{primary-600-1}}';    background: '{{primary-600-1}}'; }md-toolbar.md-warn > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper {  background-color: '{{warn-color}}'; }  md-toolbar.md-warn > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]) {    color: '{{warn-100}}'; }    md-toolbar.md-warn > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active, md-toolbar.md-warn > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active md-icon, md-toolbar.md-warn > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused, md-toolbar.md-warn > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused md-icon {      color: '{{warn-contrast}}'; }    md-toolbar.md-warn > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused {      background: '{{warn-contrast-0.1}}'; }md-toast.md-THEME_NAME-theme .md-toast-content {  background-color: #323232;  color: '{{background-50}}'; }  md-toast.md-THEME_NAME-theme .md-toast-content .md-button {    color: '{{background-50}}'; }    md-toast.md-THEME_NAME-theme .md-toast-content .md-button.md-highlight {      color: '{{accent-color}}'; }      md-toast.md-THEME_NAME-theme .md-toast-content .md-button.md-highlight.md-primary {        color: '{{primary-color}}'; }      md-toast.md-THEME_NAME-theme .md-toast-content .md-button.md-highlight.md-warn {        color: '{{warn-color}}'; }md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar) {  background-color: '{{primary-color}}';  color: '{{primary-contrast}}'; }  md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar) md-icon {    color: '{{primary-contrast}}';    fill: '{{primary-contrast}}'; }  md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar) .md-button[disabled] md-icon {    color: '{{primary-contrast-0.26}}';    fill: '{{primary-contrast-0.26}}'; }  md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-accent {    background-color: '{{accent-color}}';    color: '{{accent-contrast}}'; }    md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-accent .md-ink-ripple {      color: '{{accent-contrast}}'; }    md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-accent md-icon {      color: '{{accent-contrast}}';      fill: '{{accent-contrast}}'; }    md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-accent .md-button[disabled] md-icon {      color: '{{accent-contrast-0.26}}';      fill: '{{accent-contrast-0.26}}'; }  md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-warn {    background-color: '{{warn-color}}';    color: '{{warn-contrast}}'; }md-tooltip.md-THEME_NAME-theme {  color: '{{background-A100}}'; }  md-tooltip.md-THEME_NAME-theme ._md-content {    background-color: '{{foreground-2}}'; }");
      })();
    })(window, window.angular);
    ;
    window.ngMaterial = {version: {full: "1.1.0-rc.5-master-7f01138"}};
  })();
  return _retrieveGlobal();
});

$__System.registerDynamic("b", ["5", "6", "9", "a"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  $__require('5');
  $__require('6');
  $__require('9');
  $__require('a');
  module.exports = 'ngMaterial';
  return module.exports;
});

$__System.registerDynamic("c", ["b"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('b');
  return module.exports;
});

$__System.register("d", [], function (_export) {
  /**
   * Main App Controller for the Angular Material Starter App
   * @param $scope
   * @param $mdSidenav
   * @param avatarsService
   * @constructor
   */
  "use strict";

  function DashboardController(dashboardService, $mdSidenav, $mdBottomSheet, $log) {

    $log = $log.getInstance("SessionController");
    $log.debug("instanceOf() ");

    var self = this;

    self.selected = null;
    self.containers = [];
    self.nodes = [];
    self.selectNode = selectNode;
    self.toggleList = toggleNodesList;
    //  self.terminal     = terminal;

    // Load all nodes

    dashboardService.loadNodes().then(function (payload) {
      self.nodes = [].concat(payload.data);

      self.selected = payload.data[0];

      dashboardService.loadContainers(self.selected.status.addresses[0].address).then(function (payload) {
        self.containers = payload.data;
      });
    });

    // *********************************
    // Internal methods
    // *********************************

    /**
     * Hide or Show the 'left' sideNav area
     */
    function toggleNodesList() {
      $log.debug("toggleNodesList() ");
      $mdSidenav('left').toggle();
    }

    /**
     * Show Containers
     * @param menuId
     */
    function selectNode(node) {
      $log.debug("selectNode( {metadata.name} ) ", node);

      self.selected = angular.isNumber(node) ? $scope.nodes[node] : node;

      dashboardService.loadContainers(node.status.addresses[0].address).then(function (payload) {
        self.containers = payload.data;
      });

      self.toggleList();
    }

    //  function terminal(container) {
    //    $log.debug("terminal")
    //
    //    var node = self.selected;
    //    $log.debug("node: {metadata.name} ip: {address} ", node.status.addresses[0]);
    //    $log.debug("containerId {Id}", container);
    //  }
  }

  return {
    setters: [],
    execute: function () {
      _export("default", ['dashboardService', '$mdSidenav', '$mdBottomSheet', '$log', DashboardController]);
    }
  };
});
$__System.register('e', [], function (_export) {
    'use strict';

    function DashboardService($log, $http) {
        var users = [{
            Names: ['Lia Lugo'],
            Id: 'beyond'
        }];

        $log = $log.getInstance("DashboardService");
        $log.debug("instanceOf() ");

        // Promise-based API
        return {
            loadNodes: function loadNodes() {
                $log.debug("loadNodes()");
                return $http.get('/api/nodes');
            },
            loadContainers: function loadContainers(node) {
                $log.debug("loadContainers()");
                return $http.get('/api/nodes/containers?node=' + node);
            }
        };
    }

    return {
        setters: [],
        execute: function () {
            _export('default', ['$log', '$http', DashboardService]);
        }
    };
});
$__System.register('f', ['10', 'd', 'e'], function (_export) {

  // Load the custom app ES6 modules

  'use strict';

  var ExternalLogger, DashboardController, DashboardService, URL_ICON_DOCKER, URL_ICON_MENU, URL_ICON_TERMINAL, $log, moduleName;
  return {
    setters: [function (_) {
      ExternalLogger = _.ExternalLogger;
    }, function (_d) {
      DashboardController = _d['default'];
    }, function (_e) {
      DashboardService = _e['default'];
    }],
    execute: function () {
      URL_ICON_DOCKER = 'assets/svg/docker.svg';
      URL_ICON_MENU = 'assets/svg/menu.svg';
      URL_ICON_TERMINAL = 'assets/svg/terminal.svg';
      $log = new ExternalLogger();

      $log = $log.getInstance("BOOTSTRAP");
      $log.debug("Configuring 'Dashboard' module");

      // Define the Angular 'Dashboard' module

      moduleName = angular.module("dashboard", []).service("dashboardService", DashboardService).controller("DashboardController", DashboardController).config(function ($mdIconProvider, $mdThemingProvider) {
        $log.debug("Configuring $mdIconProvider");

        // Register `dashboard` iconset & icons for $mdIcon service lookups
        $mdIconProvider.defaultIconSet(URL_ICON_DOCKER, 75).icon('menu', URL_ICON_MENU, 24).icon('terminal', URL_ICON_TERMINAL, 24).icon('docker', URL_ICON_DOCKER, 75);

        $mdThemingProvider.theme('dark-grey').backgroundPalette('grey').dark();
        $mdThemingProvider.theme('dark-orange').backgroundPalette('orange').dark();
        $mdThemingProvider.theme('dark-purple').backgroundPalette('deep-purple').dark();
        $mdThemingProvider.theme('dark-blue').backgroundPalette('blue').dark();
      }).name;

      _export('default', moduleName);
    }
  };
});
$__System.register('11', ['10', 'f'], function (_export) {
    'use strict';

    var ExternalLogger, dashboard, $log;
    return {
        setters: [function (_) {
            ExternalLogger = _.ExternalLogger;
        }, function (_f) {
            dashboard = _f['default'];
        }],
        execute: function () {
            $log = new ExternalLogger();

            $log = $log.getInstance("BOOTSTRAP");
            $log.debug("Configuring 'main' module");

            _export('default', angular.module('main', [dashboard]).name);
        }
    };
});
$__System.register('12', [], function (_export) {
    'use strict';

    /**
     * @author      Thomas Burleson
     * @date        November, 2013
     * @description
     *
     *  String supplant global utility (similar to but more powerful than sprintf() ).
     *
     *  Usages:
     *
     *      var user = {
     *              first : "Thomas",
     *              last  : "Burleson",
     *              address : {
     *                  city : "West Des Moines",
     *                  state: "Iowa"
     *              },
     *              contact : {
     *                  email : "ThomasBurleson@Gmail.com"
     *                  url   : "http://www.gridlinked.info"
     *              }
     *          },
     *          message = "Hello Mr. {first} {last}. How's life in {address.city}, {address.state} ?";
     *
     *     return supplant( message, user );
     *
     *
     * NOTE: this supplant() method is from Crockfords `Remedial Javascript`
     *
     */
    function supplant(template, values, pattern) {
        pattern = pattern || /\{([^\{\}]*)\}/g;

        return template.replace(pattern, function (a, b) {
            var p = b.split('.'),
                r = values;

            try {
                for (var s in p) {
                    r = r[p[s]];
                }
            } catch (e) {
                r = a;
            }

            return typeof r === 'string' || typeof r === 'number' ? r : a;
        });
    }

    // supplant() method from Crockfords `Remedial Javascript`
    return {
        setters: [],
        execute: function () {
            _export('default', supplant);

            Function.prototype.method = function (name, func) {
                this.prototype[name] = func;
                return this;
            };

            String.method("supplant", function (values, pattern) {
                var self = this;
                return supplant(self, values, pattern);
            });

            String.supplant = supplant;
        }
    };
});
$__System.register('10', ['12'], function (_export) {
    'use strict';

    /**
     * Decorate the $log to use inject the LogEnhancer features.
     *
     * @param {object} $provide The log console.
     * @returns {object} promise.
     * @private
     */
    function LogDecorator($provide) {
        // Register our $log decorator with AngularJS $provider

        $provide.decorator('$log', ["$delegate", function ($delegate) {

            return enhanceLog($delegate);
        }]);
    }

    function ExternalLogger() {
        /**
         * Determines if the requested console logging method is available, since it is not with IE.
         *
         * @param {Function} method The request console logging method.
         * @returns {object} Indicates if the console logging method is available.
         * @private
         */
        var prepareLogToConsole = function prepareLogToConsole(method) {
            var console = window.console,
                isFunction = function isFunction(fn) {
                return typeof fn == typeof Function;
            },
                isAvailableConsoleFor = function isAvailableConsoleFor(method) {
                var isPhantomJS = new BrowserDetect().browser != "PhantomJS";

                // NOTE: Tried using this for less logging in the console/terminal, but then logging in IDE is
                // wiped out as well return console && console[method] && isFunction(console[method]) && isPhantomJS;

                return console && console[method] && isFunction(console[method]);
            },
                logFn = function logFn(message) {
                if (isAvailableConsoleFor(method)) {
                    try {
                        console[method](message);
                    } catch (e) {}
                }
            };

            return logFn;
        },
            $log = {
            log: prepareLogToConsole("log"),
            info: prepareLogToConsole("info"),
            warn: prepareLogToConsole("warn"),
            debug: prepareLogToConsole("debug"),
            error: prepareLogToConsole("error")
        };

        // Publish instance of $log simulator; with enhanced functionality
        return new enhanceLog($log);
    }

    function enhanceLog($log) {
        var separator = "::",

        /**
         * Cached DateTime formatter
         */
        dateFormatter = new DateTime(),
            detector = new BrowserDetect(),

        /**
         * Capture the original $log functions; for use in enhancedLogFn()
         */
        _$log = (function ($log) {
            return {
                log: $log.log,
                info: $log.info,
                warn: $log.warn,
                debug: $log.debug,
                error: $log.error
            };
        })($log),

        /**
         * Chrome Dev tools supports color logging
         * @see https://developers.google.com/chrome-developer-tools/docs/console#styling_console_output_with_css
         */
        colorify = function colorify(message, colorCSS) {
            var isChrome = detector.browser == "Chrome",
                canColorize = isChrome && colorCSS !== undefined;

            return canColorize ? ["%c" + message, colorCSS] : [message];
        },

        /**
         * Partial application to pre-capture a logger function
         */
        prepareLogFn = function prepareLogFn(logFn, className, colorCSS) {
            /**
             * Invoke the specified `logFn` with the supplant functionality...
             */
            var supplant = String.supplant;
            var enhancedLogFn = function enhancedLogFn() {
                try {
                    var args = Array.prototype.slice.call(arguments);

                    // prepend a timestamp and optional classname to the original output message
                    args[0] = supplant("{0} - {1}{2}", [dateFormatter.now(), className, args[0]]);
                    args = colorify(supplant.apply(null, args), colorCSS);

                    logFn.apply(null, args);
                } catch (error) {
                    $log.error("LogEnhancer ERROR: " + error);
                }
            };

            // Only needed to support angular-mocks expectations
            enhancedLogFn.logs = [];

            return enhancedLogFn;
        },

        /**
         * Support to generate class-specific logger instance with classname only
         */
        getInstance = function getInstance(className, colorCSS, customSeparator) {
            className = className !== undefined ? className + (customSeparator || separator) : "";

            var instance = {
                log: prepareLogFn(_$log.log, className, colorCSS),
                info: prepareLogFn(_$log.info, className, colorCSS),
                warn: prepareLogFn(_$log.warn, className, colorCSS),
                debug: prepareLogFn(_$log.debug, className, colorCSS),
                error: prepareLogFn(_$log.error, className) // NO styling of ERROR messages
            };

            // Attach instance specific tryCatch() functionality...
            instance.tryCatch = makeTryCatch(instance.error, instance);

            return instance;
        };

        // Add special method to AngularJS $log
        $log.getInstance = getInstance;

        return $log;
    }

    /**
     * Implement a tryCatch() method that logs exceptions for method invocations AND
     * promise rejection activity.
     *
     * @param notifyFn      Function used to log.debug exception information
     * @param scope         Object Receiver for the notifyFn invocation
     *
     * @return Function used to guard and invoke the targeted actionFn
     */
    function makeTryCatch(notifyFn, scope) {
        /**
         * Report error (with stack trace if possible) to the logger function
         */
        var reportError = function reportError(reason) {
            if (notifyFn != null) {
                var error = reason && reason.stack ? reason : null,
                    message = reason != null ? String(reason) : "";

                if (error != null) {
                    message = error.message + "\n" + error.stack;
                }

                notifyFn.apply(scope, [message]);
            }

            return reason;
        },

        /**
         * Publish the tryCatch() guard 'n report function
         */
        tryCatch = function tryCatch(actionFn, scope, args) {
            try {
                // Invoke the targeted `actionFn`
                var result = angular.isFunction(actionFn) ? actionFn.apply(scope, args || []) : String(actionFn),
                    promise = angular.isObject(result) && result.then ? result : null;

                if (promise != null) {
                    // Catch and report any promise rejection reason...
                    promise.then(null, reportError);
                }

                actionFn = null;
                return result;
            } catch (e) {
                actionFn = null;
                throw reportError(e);
            }
        };

        return tryCatch;
    }

    /**
     * @author     Thomas Burleson
     * @author     StackOverflow - Harto, http://stackoverflow.com/questions/2315408/how-do-i-format-a-timestamp-in-javascript-to-display-it-in-graphs-utc-is-fine
     * @description
     *
     * DateTime utility class that spits out UTC timestamp strings usually used in a reporting, print-capable process.
     */
    function DateTime() {
        /**
         * Creates a date timestamp string.
         */
        var buildTimeString = function buildTimeString(date, format) {
            format = format || "%h:%m:%s:%z";

            function pad(value, isMilliSeconds) {
                if (typeof isMilliSeconds === "undefined") {
                    isMilliSeconds = false;
                }
                if (isMilliSeconds) {
                    if (value < 10) {
                        value = "00" + value;
                    } else if (value < 100) {
                        value = "0" + value;
                    }
                }
                return value.toString().length < 2 ? "0" + value : value;
            }

            return format.replace(/%([a-zA-Z])/g, function (_, fmtCode) {
                switch (fmtCode) {
                    case "Y":
                        return date.getFullYear();
                    case "M":
                        return pad(date.getMonth() + 1);
                    case "d":
                        return pad(date.getDate());
                    case "h":
                        return pad(date.getHours());
                    case "m":
                        return pad(date.getMinutes());
                    case "s":
                        return pad(date.getSeconds());
                    case "z":
                        return pad(date.getMilliseconds(), true);
                    default:
                        throw new Error("Unsupported format code: " + fmtCode);
                }
            });
        };

        // Publish API for DateTime utils
        return {
            now: function now() {
                return buildTimeString(new Date());
            }
        };
    }

    function BrowserDetect() {

        // NOTE: It's important to list PhantomJS first since it has the same browser information as Safari
        this.dataBrowser = [{
            string: "PhantomJS",
            subString: "PhantomJS",
            identity: "PhantomJS",
            versionSearch: "PhantomJS"
        }, {
            string: navigator.userAgent,
            subString: "Chrome",
            identity: "Chrome"
        }, {
            string: navigator.userAgent,
            subString: "OmniWeb",
            versionSearch: "OmniWeb/",
            identity: "OmniWeb"
        }, {
            string: navigator.vendor,
            subString: "Apple",
            identity: "Safari",
            versionSearch: "Version"
        }, {
            prop: window.opera,
            identity: "Opera",
            versionSearch: "Version"
        }, {
            string: navigator.vendor,
            subString: "iCab",
            identity: "iCab"
        }, {
            string: navigator.vendor,
            subString: "KDE",
            identity: "Konqueror"
        }, {
            string: navigator.userAgent,
            subString: "Firefox",
            identity: "Firefox"
        }, {
            string: navigator.vendor,
            subString: "Camino",
            identity: "Camino"
        }, { // for newer Netscapes (6+)
            string: navigator.userAgent,
            subString: "Netscape",
            identity: "Netscape"
        }, {
            string: navigator.userAgent,
            subString: "MSIE",
            identity: "Explorer",
            versionSearch: "MSIE"
        }, {
            string: navigator.userAgent,
            subString: "Gecko",
            identity: "Mozilla",
            versionSearch: "rv"
        }, {
            // for older Netscapes (4-)
            string: navigator.userAgent,
            subString: "Mozilla",
            identity: "Netscape",
            versionSearch: "Mozilla"
        }], this.dataOS = [{
            string: navigator.platform,
            subString: "Win",
            identity: "Windows"
        }, {
            string: navigator.platform,
            subString: "Mac",
            identity: "Mac"
        }, {
            string: navigator.userAgent,
            subString: "iPhone",
            identity: "iPhone/iPod"
        }, {
            string: navigator.platform,
            subString: "Linux",
            identity: "Linux"
        }];

        this.init();
    }

    return {
        setters: [function (_2) {}],
        execute: function () {
            _export('LogDecorator', LogDecorator);

            _export('ExternalLogger', ExternalLogger);

            BrowserDetect.prototype = {

                /**
                 * Sets the browser version and OS(Operating Systems) uses {@link mindspace.utils:BrowserDetect#searchString searchString}
                 * and {@link mindspace.utils:BrowserDetect#searchVersion searchVersion} internally
                 */
                init: function init() {
                    this.browser = this.searchString(this.dataBrowser) || "An unknown browser";
                    this.version = this.searchVersion(navigator.userAgent) || this.searchVersion(navigator.appVersion) || "an unknown version";
                    this.OS = this.searchString(this.dataOS) || "an unknown OS";

                    return this;
                },

                /**
                 * Checks whether the browser is IE8. Root element(html) is already set with class='ie8
                 * this function uses the same class reference and provides the status.
                 */
                isIE8: function isIE8() {
                    return document.documentElement.hasAttribute("class") && document.documentElement.getAttribute("class") === "ie8";
                },

                /**
                 * User for determining the browser and OS based on the input provided by the data param.
                 * Also sets the versionSearchString parameter which would be used by
                 * {@link mindspace.utils:BrowserDetect#searchVersion searchVersion}
                 */
                searchString: function searchString(data) {
                    for (var i = 0; i < data.length; i++) {
                        var dataString = data[i].string;
                        var dataProp = data[i].prop;

                        this.versionSearchString = data[i].versionSearch || data[i].identity;
                        if (dataString) {
                            if (dataString.indexOf(data[i].subString) != -1) {
                                return data[i].identity;
                            }
                        } else if (dataProp) {
                            return data[i].identity;
                        }
                    }
                },

                /**
                 * User for determining the browser version based on input string
                 */
                searchVersion: function searchVersion(dataString) {
                    var index = dataString.indexOf(this.versionSearchString);
                    if (index == -1) {
                        return;
                    }
                    return parseFloat(dataString.substring(index + this.versionSearchString.length + 1));
                }

            };
        }
    };
});
$__System.register('1', ['2', '3', '5', '10', '11', 'c'], function (_export) {
  // Load the Angular Material CSS associated with ngMaterial
  // then load the main.css to provide overrides, etc.

  /**
   * Manually bootstrap the application when AngularJS and
   * the application classes have been loaded.
   */

  // Load loggers for injection and pre-angular debugging

  // Load custom application modules

  // Load Angular libraries

  'use strict';

  var angular, LogDecorator, ExternalLogger, main, material;
  return {
    setters: [function (_) {}, function (_2) {}, function (_3) {
      angular = _3['default'];
    }, function (_5) {
      LogDecorator = _5.LogDecorator;
      ExternalLogger = _5.ExternalLogger;
    }, function (_4) {
      main = _4['default'];
    }, function (_c) {
      material = _c['default'];
    }],
    execute: function () {
      angular.element(document).ready(function () {

        var appName = 'kubernetes-web-terminal';
        var $log = new ExternalLogger();

        $log = $log.getInstance("BOOTSTRAP");
        $log.debug("Initializing '{0}'", [appName]);

        var body = document.getElementsByTagName("body")[0];
        var app = angular.module(appName, [material, main]).config(['$provide', LogDecorator]);

        angular.bootstrap(body, [app.name], { strictDi: false });
      });
    }
  };
});
$__System.register('github:angular/bower-material@master/angular-material.css!github:systemjs/plugin-css@0.1.23.js', [], false, function() {});
$__System.register('assets/app.css!github:systemjs/plugin-css@0.1.23.js', [], false, function() {});
})
(function(factory) {
  factory();
});
//# sourceMappingURL=build.js.map